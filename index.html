<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Collage - No-Crop Column Flow + Balanced Row</title>
  <style>
    body {
      margin: 20px;
      font-family: Arial, sans-serif;
    }
    .debug-info {
      margin-top: 20px;
      padding: 10px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }

    /* Collage defaults: prevent clipping, keep images contained */
    .img_collage {
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
    }
    .img_collage *,
    .img_collage img {
      box-sizing: border-box;
    }
    .img_collage img {
      display: block;
      image-rendering: auto;
      -webkit-user-drag: none;
      user-select: none;
      max-width: 100%;
      max-height: 100%;
    }
    .img_collage__tile {
      position: absolute;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      padding: 0;
      border: 0;
    }
  </style>
</head>
<body>

<h3>Image Collage - Fixed 640x500 (No Crop) — Column-first flow enabled</h3>

<!-- 說明：
  - data-flow="col" → 以「高度優先、由上到下，再由左到右」的欄式排法（滿高），適合 19/20 張等不等量
  - data-flow 可切換為 "row" → 使用 BalancedNoCrop 的等高列式排法（滿寬）
  - data-mincols / data-maxcols → 欄數搜尋範圍（欄式）
  - data-hgap / data-vgap → 欄間與圖間間距
  - data-minutil → 欄式利用率門檻（0~1，預設 0.88），低於門檻自動改用 row 方案以「自動補滿空白」
-->
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1300/720.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/678/888.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1020/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1041/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1021/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1025/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1043/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1003/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1024/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1027/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1028/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1029/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1031/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1032/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1033/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1035/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1036/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1037/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1040/800/1200.jpg"   alt="">
</div>

<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1020/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1041/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1021/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1035/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1036/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1037/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1040/800/1200.jpg"   alt="">
</div>

<script>
/*!
 * ColumnNoCrop v1.0 + BalancedNoCrop v4.0
 * - ColumnNoCrop（高度優先、欄式）：由上到下，再由左到右；每欄恰好填滿 H，不裁剪，不變形
 *   對 N=19/20 等不等量都穩定；自動搜索欄數與每欄張數分配，將橫向剩餘寬度分配到欄間距，避免水平留白帶來縫隙不齊
 * - BalancedNoCrop（寬度優先、列式）：滿寬、列高一致，已在前版驗證 >95% 利用率
 */
(function(){
  "use strict";
  const CLASS = "img_collage";

  // Debug config
  window.__COLLAGE_DEBUG = true;
  const DEBUG_ENABLED = !!window.__COLLAGE_DEBUG;
  const MAX_DEBUG_LINES = 500;

  // ---------- Debug Logger ----------
  function log(message, data) {
    if (DEBUG_ENABLED) {
      console.log(message, data ?? '');
      const debugDiv = document.getElementById('debugInfo');
      if (debugDiv) {
        const line = document.createElement('div');
        line.textContent = `${message} ${data !== undefined ? JSON.stringify(data) : ''}`;
        debugDiv.appendChild(line);
        // Trim debug lines to avoid DOM bloat
        while (debugDiv.childElementCount > MAX_DEBUG_LINES) {
          debugDiv.removeChild(debugDiv.firstChild);
        }
      }
    }
  }

  // ---------- Helpers ----------
  const raf2 = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

  // Basic debounce to reduce layout thrashing on resize
  function debounce(fn, delay = 80) {
    let t;
    return function(...args) {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  function preload(img){
    return new Promise(res=>{
      if (img.complete && img.naturalWidth>0) { res(); return; }
      img.addEventListener('load', res, {once:true});
      img.addEventListener('error', res, {once:true});
    });
  }

  function findRootChild(img, root) {
    let node = img;
    while (node && node.parentNode) {
      const parent = node.parentNode;
      if (parent === root) {
        if (node.classList && node.classList.contains('img_collage__tile')) {
          return null;
        }
        return node;
      }
      if (!(parent instanceof HTMLElement)) break;
      if (parent.classList && parent.classList.contains('img_collage__tile')) {
        return null;
      }
      node = parent;
    }
    return null;
  }

  function ensureTiles(root, imgs) {
    return imgs.map((img, index) => {
      const rootChild = findRootChild(img, root);
      let tile = img.__collageTile;
      const needsNewTile = !tile || tile.parentNode !== root;

      if (needsNewTile) {
        tile = document.createElement('div');
        tile.className = 'img_collage__tile';
        if (rootChild && rootChild.parentNode === root) {
          root.insertBefore(tile, rootChild);
          tile.appendChild(rootChild);
        } else {
          root.appendChild(tile);
          tile.appendChild(img);
        }
        img.__collageTile = tile;
      } else if (rootChild && rootChild.parentNode !== tile) {
        tile.appendChild(rootChild);
      } else if (!tile.contains(img)) {
        tile.appendChild(img);
      }

      tile.dataset.index = index;
      return tile;
    });
  }

  // Numeric parsing helpers (allow 0, clamp ranges)
  const EPS = 1e-6;
  function hasNumber(v){ return v !== undefined && v !== null && v !== '' && !Number.isNaN(+v); }
  function getDataNumber(ds, keys, def){
    if (!Array.isArray(keys)) keys = [keys];
    for (const k of keys) {
      if (hasNumber(ds[k])) return +ds[k];
    }
    return def;
  }
  function clampRange(x, lo, hi){ return Math.min(hi, Math.max(lo, x)); }
  function clampNonNeg(x){ return Math.max(0, x); }
  function clampInt(x, lo, hi){
    const n = Math.round(+x);
    const v = Number.isFinite(n) ? n : lo;
    return Math.min(hi, Math.max(lo, v));
  }

  // Quantize helpers — convert float slices to integers that exactly sum to target
  function _quantizeToSum(valuesF, targetInt){
    const n = valuesF.length;
    if (n === 0) return [];
    const T = Math.max(0, Math.round(targetInt));
    let vals = valuesF.map(v => Math.max(0, +v || 0));
    const sumF = vals.reduce((s, v) => s + v, 0);
    if (!(sumF > 0)) {
      // fallback: evenly distribute target when inputs are all zero/non-finite
      const out = new Array(n).fill(0);
      for (let k = 0; k < T; k++) out[k % n] += 1;
      return out;
    }
    // Scale to target first so floors never exceed target
    const alpha = T / sumF;
    vals = vals.map(v => v * alpha);

    // Floor and distribute remaining pixels by fractional part
    const ints = vals.map(v => Math.floor(v));
    let diff = T - ints.reduce((s, v) => s + v, 0);
    if (diff > 0) {
      const order = vals.map((v,i)=>({i, f: v - Math.floor(v)})).sort((a,b)=>b.f - a.f);
      for (let k = 0; k < diff; k++) {
        const idx = order[k % n].i;
        ints[idx] += 1;
      }
    } else if (diff < 0) {
      // Extremely rare due to rounding; remove from smallest fractional parts
      const order = vals.map((v,i)=>({i, f: v - Math.floor(v)})).sort((a,b)=>a.f - b.f);
      for (let k = 0; k < -diff; k++) {
        // find any slot with >0 to decrement
        let t = k % n, tries = 0;
        while (tries < n && ints[order[t].i] <= 0) { t = (t + 1) % n; tries++; }
        if (tries < n) ints[order[t].i] -= 1;
      }
    }
    return ints;
  }
  function _sum(arr){ return arr.reduce((s,v)=>s+v,0); }

  // ---------- ColumnNoCrop: compositions generator ----------
  function generateCompositions(n, k, cb, control) {
    // 產生 k 個正整數之組合，其和 = n；串流回呼避免大量內存
    control = control || {};
    const now = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : () => Date.now();
    const deadline = Number.isFinite(control.deadline) ? control.deadline : Infinity;
    const limit = Number.isFinite(control.limit) ? control.limit : Infinity;
    let count = 0;

    function shouldStop() {
      if (count >= limit) { control.stopped = true; control.truncated = true; return true; }
      if (now() > deadline) { control.stopped = true; control.truncated = true; return true; }
      return false;
    }

    function rec(parts, left, slots) {
      if (control.stopped) return;
      if (slots === 1) {
        cb([...parts, left]);
        count++;
        if (shouldStop()) return;
        return;
      }
      const maxT = left - (slots - 1);
      for (let t = 1; t <= maxT; t++) {
        if (control.stopped) return;
        parts.push(t);
        rec(parts, left - t, slots - 1);
        parts.pop();
        if (control.stopped) return;
      }
    }
    rec([], n, k);
    control.count = count;
  }

  // ---------- ColumnNoCrop: solver ----------
  function solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols, minImgH) {
    log('[ColumnNoCrop] Start', {W,H,N:aspects.length, minCols, maxCols});
    let best = null;

    // 計算可行欄數範圍：最多不超過 N；允許低於 minCols 以確保可解（例如 N 小或寬度不足時）
    const N = aspects.length;
    const cMax = Math.min(Math.max(minCols, maxCols), N);
    const cMin = 1;
    const nowFn = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : () => Date.now();

    // 優先嘗試較多欄，若無可行則逐步降欄（避免負 gap）
    for (let C = cMax; C >= cMin; C--) {
      const ctrl = { limit: 200000, deadline: nowFn() + 12 };
      generateCompositions(N, C, (counts) => {
        // 依輸入順序：上到下 → 下一欄
        let idx = 0;
        const cols = [];
        const widths = [];

        let invalid = false;
        for (let j = 0; j < C; j++) {
          const cnt = counts[j];
          const list = aspects.slice(idx, idx + cnt);
          idx += cnt;

          const H_eff = H - vgap * Math.max(0, cnt - 1);
          if (H_eff <= 0) { invalid = true; break; }

          const Sj = list.reduce((s, a) => s + 1 / Math.max(1e-6, a), 0); // Σ(1/a)
          if (!(Sj > 1e-6) || !Number.isFinite(Sj)) { invalid = true; break; }

          const wj = H_eff / Math.max(1e-6, Sj); // 欄寬 wj，使 Σ(wj/a) + gaps = H → 滿高
          if (!(wj > 0) || !Number.isFinite(wj)) { invalid = true; break; }

          // minimal image height constraint for this column
          const maxA = list.reduce((m, a) => Math.max(m, Math.max(1e-6, a)), 1e-6);
          const minHCol = wj / maxA;
          if (Number.isFinite(minImgH) && minImgH > 0 && minHCol < minImgH) { invalid = true; break; }

          cols.push({ count: cnt, aspects: list });
          widths.push(wj);
        }
        if (invalid) { return; }

        const sumW = widths.reduce((s, v) => s + v, 0);
        const neededGap = (C > 1) ? (W - sumW) / (C - 1) : 0; // 讓總寬 + gap*(C-1) 精確 = W

        // 若 neededGap 為負，代表以滿高無法鋪滿寬度 → 此欄數不可行，跳過
        if (neededGap < -1e-6) {
          return;
        }

        // 打分：gap 接近期望值、欄寬均衡 + 更高利用率 + 列數偏好
        const meanW = sumW / C;
        const varW = widths.reduce((s, v) => s + (v - meanW) * (v - meanW), 0) / C;
        const usedArea = widths.reduce((s, w, j) => s + w * Math.max(0, H - vgap * Math.max(0, counts[j] - 1)), 0);
        const utilEst = usedArea / Math.max(1e-6, W * H);
        const colsPref = Math.abs(C - Math.max(2, Math.round(Math.sqrt(N))));
        const score = Math.abs(neededGap - hgap) * 2.5 + Math.sqrt(varW) * 0.7 + (1 - utilEst) * 80 + colsPref * 0.3;

        if (!best || score < best.score) {
          best = { C, counts, cols, widths, neededGap, sumW, score };
        }
      }, ctrl);

      if (ctrl.truncated) {
        log('[ColumnNoCrop] compositions truncated', { C, visited: ctrl.count });
      }

      // 若已找到可行解且 gap 非負，即可提前結束（偏好較多欄的可行解）
      if (best) break;
    }

    if (best) {
      log('[ColumnNoCrop] Best', { cols: best.C, neededGap: +best.neededGap.toFixed(2), score: +best.score.toFixed(3) });
    } else {
      log('[ColumnNoCrop] No feasible partition');
    }
    return best;
  }

  // Quantized column positions: integer-safe widths/heights, distributed remainders to avoid sub-pixel seams
  function buildColumnPositions(best, W, H, hgap, vgap) {
    const EPS2 = 1e-6;
    const C = best.C;
    const gapF = C > 1 ? best.neededGap : 0;
    const g = C > 1 ? Math.max(0, Math.round(gapF)) : 0;       // integer horizontal gap
    const vInt = Math.max(0, Math.round(vgap));                 // integer vertical gap

    // 1) Quantize column widths so that Σ widths + g*(C-1) = W
    const avail = W - g * Math.max(0, C - 1);
    const widthsF = best.widths.slice();
    const sumWF = widthsF.reduce((s, v) => s + v, 0);
    const scaled = widthsF.map(w => w * avail / Math.max(EPS2, sumWF));

    const widthsI = scaled.map(w => Math.floor(w));
    const fracCol = scaled.map((w, i) => ({ i, f: w - Math.floor(w) })).sort((a, b) => b.f - a.f);
    let remW = Math.round(avail - widthsI.reduce((s, v) => s + v, 0));
    for (let k = 0; k < remW; k++) widthsI[fracCol[k % fracCol.length].i] += 1;

    const positions = [];
    let globalIndex = 0;
    let x = 0;

    // 2) For each column, quantize heights so that Σ heights + vInt*(n-1) = H
    for (let j = 0; j < C; j++) {
      const col = best.cols[j];
      const wInt = Math.max(0, widthsI[j]);

      // base heights by aspect
      const baseH = col.aspects.map(a => wInt / Math.max(EPS2, a));
      const availH = H - vInt * Math.max(0, col.count - 1);
      const sumHF = baseH.reduce((s, v) => s + v, 0);
      const scaledH = baseH.map(h => h * availH / Math.max(EPS2, sumHF));

      const heightsI = scaledH.map(h => Math.floor(h));
      const fracH = scaledH.map((h, i) => ({ i, f: h - Math.floor(h) })).sort((a, b) => b.f - a.f);
      let remH = Math.round(availH - heightsI.reduce((s, v) => s + v, 0));
      for (let k = 0; k < remH; k++) heightsI[fracH[k % fracH.length].i] += 1;

      // push tiles top-down with integer coordinates
      let y = 0;
      for (let i = 0; i < col.count; i++) {
        const hInt = Math.max(0, heightsI[i]);
        positions.push({ idx: globalIndex, x: Math.round(x), y: Math.round(y), width: wInt, height: hInt });
        y += hInt + vInt;
        globalIndex++;
      }
      x += wInt + (j < C - 1 ? g : 0);
    }

    // 3) Final correction: if there is a drift from rounding, absorb to the last column's last tile width
    const drift = Math.round(W - x);
    if (drift !== 0 && positions.length) {
      // find last column tiles: they have maximum x among positions
      let maxX = -Infinity, idxLast = -1;
      for (let p = 0; p < positions.length; p++) if (positions[p].x > maxX) { maxX = positions[p].x; idxLast = p; }
      if (idxLast >= 0) positions[idxLast].width = Math.max(0, positions[idxLast].width + drift);
    }
    return positions;
  }

  // ---------- Small-set visual layouts (N ≤ 4) ----------
  function buildSmallSetPositions(aspects, W, H, hgap, vgap) {
    const N = aspects.length;
    const pos = [];
    const innerW = (n) => W - hgap * Math.max(0, n - 1);
    const EPS2 = 1e-6;
    function pushIdx(idx, x, y, w, h){ pos.push({ idx, x: Math.round(x), y: Math.round(y), width: Math.max(0, Math.round(w)), height: Math.max(0, Math.round(h)) }); }

    if (N === 1) {
      const a = Math.max(EPS2, aspects[0]);
      let w = W, h = W / a;
      if (h > H) { h = H; w = H * a; }
      const x = (W - w) / 2; const y = (H - h) / 2;
      pushIdx(0, x, y, w, h);
      return pos;
    }

    if (N === 2) {
      const iw = innerW(2);
      const sA = Math.max(EPS2, aspects[0] + aspects[1]);
      const hF = iw / sA;
      const hI = Math.max(1, Math.round(hF));
      const wF = [aspects[0]*hI, aspects[1]*hI];
      const wI = _quantizeToSum(wF, iw);
      const top = Math.max(0, Math.round((H - hI) / 2));
      let x = 0;
      pushIdx(0, x, top, wI[0], hI); x += wI[0] + hgap;
      pushIdx(1, x, top, wI[1], hI);
      return pos;
    }

    if (N === 3) {
      const combos = [ [0,1,2], [0,2,1], [1,2,0] ];
      let best = null;
      for (const [i,j,k] of combos) {
        const iw1 = innerW(2), iw2 = innerW(1);
        const h1 = iw1 / Math.max(EPS2, aspects[i] + aspects[j]);
        const h2 = iw2 / Math.max(EPS2, aspects[k]);
        const alpha = (H - vgap) / Math.max(EPS2, h1 + h2);
        const H1 = h1 * alpha, H2 = h2 * alpha;
        const score = Math.abs(H1 - H2);
        if (!best || score < best.score) best = {i,j,k,H1,H2,iw1,iw2};
      }
      const {i,j,k,H1,H2,iw1,iw2} = best;
      const heightsI = _quantizeToSum([H1,H2], H - vgap);
      const H1I = Math.max(1, heightsI[0]), H2I = Math.max(1, heightsI[1]);

      // Row 1 widths
      const w1F = [aspects[i]*H1I, aspects[j]*H1I];
      const w1I = _quantizeToSum(w1F, iw1);
      // Row 2 width (single)
      const w2I = _quantizeToSum([aspects[k]*H2I], iw2);

      let x = 0; const y1 = 0;
      pushIdx(i, x, y1, w1I[0], H1I); x += w1I[0] + hgap;
      pushIdx(j, x, y1, w1I[1], H1I);

      const y2 = y1 + H1I + vgap;
      const xk = (W - w2I[0]) / 2;
      pushIdx(k, xk, y2, w2I[0], H2I);
      return pos;
    }

    if (N === 4) {
      const pairs = [ [ [0,1],[2,3] ], [ [0,2],[1,3] ], [ [0,3],[1,2] ] ];
      let best = null;
      for (const [[a,b],[c,d]] of pairs) {
        const s1 = aspects[a] + aspects[b];
        const s2 = aspects[c] + aspects[d];
        const diff = Math.abs(s1 - s2);
        if (!best || diff < best.diff) best = {rows:[[a,b],[c,d]]};
      }
      const [[r1a, r1b],[r2a, r2b]] = best.rows;
      const iw = innerW(2);

      // Base heights (float)
      const h1F = iw / Math.max(EPS2, aspects[r1a] + aspects[r1b]);
      const h2F = iw / Math.max(EPS2, aspects[r2a] + aspects[r2b]);
      const alpha = (H - vgap) / Math.max(EPS2, h1F + h2F);
      const H1F = h1F * alpha, H2F = h2F * alpha;

      // Quantize heights to sum exactly
      const heightsI = _quantizeToSum([H1F, H2F], H - vgap);
      const H1I = Math.max(1, heightsI[0]), H2I = Math.max(1, heightsI[1]);

      // Row 1 widths quantized to innerW
      const w1F = [aspects[r1a]*H1I, aspects[r1b]*H1I];
      const w1I = _quantizeToSum(w1F, iw);

      // Row 2 widths quantized to innerW
      const w2F = [aspects[r2a]*H2I, aspects[r2b]*H2I];
      const w2I = _quantizeToSum(w2F, iw);

      let x1 = 0; const y1 = 0;
      pushIdx(r1a, x1, y1, w1I[0], H1I); x1 += w1I[0] + hgap;
      pushIdx(r1b, x1, y1, w1I[1], H1I);

      let x2 = 0; const y2 = y1 + H1I + vgap;
      pushIdx(r2a, x2, y2, w2I[0], H2I); x2 += w2I[0] + hgap;
      pushIdx(r2b, x2, y2, w2I[1], H2I);
      return pos;
    }
    return pos;
  }
  
  // ---------- BalancedNoCrop（保留，作 row 方向後備/切換） ----------
  function balancedPartition(aspects, rows) {
    const idxs = aspects.map((_, i) => i).sort((a, b) => aspects[b] - aspects[a]);
    const sums = new Array(rows).fill(0);
    const buckets = new Array(rows).fill(0).map(() => []);
    for (const i of idxs) {
      let bi = 0, mn = sums[0];
      for (let r = 1; r < rows; r++) {
        if (sums[r] < mn) { mn = sums[r]; bi = r; }
      }
      buckets[bi].push(i);
      sums[bi] += aspects[i];
    }
    return buckets;
  }

  function computeRowHeights(buckets, aspects, W, hgap) {
    return buckets.map(row => {
      const S = row.reduce((s, i) => s + aspects[i], 0);
      const n = row.length;
      const innerW = Math.max(1e-6, W - hgap * Math.max(0, n - 1));
      return innerW / Math.max(1e-6, S);
    });
  }

  function scaleHeightsToH(heights, H, vgap) {
    const sumH = heights.reduce((s, v) => s + v, 0);
    const target = H - vgap * Math.max(0, heights.length - 1);
    const alpha = target / Math.max(1e-6, sumH);
    return heights.map(h => h * alpha);
  }

  function buildRowPositions(buckets, heights, aspects, W, H, hgap, vgap) {
    const pos = new Array(aspects.length);
    const rows = buckets.length;
    const hgapI = Math.max(0, Math.round(hgap));
    const vgapI = Math.max(0, Math.round(vgap));

    // Quantize row heights to integers that sum exactly to H - gaps
    const targetRowsH = Math.max(0, Math.round(H - vgapI * Math.max(0, rows - 1)));
    const heightsI = _quantizeToSum(heights, targetRowsH).map(h => Math.max(1, h));

    let y = 0;
    for (let r = 0; r < rows; r++) {
      const row = buckets[r];
      const n = row.length;
      const hI = heightsI[r];
      const innerWInt = Math.max(0, Math.round(W - hgapI * Math.max(0, n - 1)));
      const widthsF = row.map(i => Math.max(1e-6, aspects[i]) * hI);
      const widthsI = _quantizeToSum(widthsF, innerWInt);

      let x = 0;
      for (let k = 0; k < n; k++) {
        const i = row[k];
        const wI = Math.max(0, widthsI[k]);
        pos[i] = { x, y, width: wI, height: hI };
        x += wI + hgapI;
      }
      y += hI + vgapI;
    }
    return pos;
  }

  // Mosaic variant: per-image variable heights within a row (no-crop), portrait-friendly.
  // - jitter: 0..1 random variation around base height per image
  // - pboost: 0..1 extra boost for portrait (a<1) to gain more height
  // - align: 'center' | 'top' vertical alignment inside row block
  function buildRowPositionsMosaic(buckets, heights, aspects, W, hgap, vgap, opts) {
    const jitter = Math.max(0, Math.min(1, (opts && +opts.jitter) || 0.12));
    const pboost = Math.max(0, Math.min(1, (opts && +opts.pboost) || 0.15));
    const align = (opts && opts.align) || 'center';
    const targetH = (opts && opts.targetH) || 0;
    const hgapI = Math.max(0, Math.round(hgap));
    const vgapI = Math.max(0, Math.round(vgap));
    function sRand(seed) { const x = Math.sin(seed) * 43758.5453123; return x - Math.floor(x); }
  
    let scales = new Array(buckets.length).fill(1);
    let positions = new Array(aspects.length);
  
    // Fixed-point like refinement to approach total H with integer-safe row blocks
    for (let iter = 0; iter < 3; iter++) {
      positions = new Array(aspects.length);
      let y = 0;
      const blockHeights = [];
  
      for (let r = 0; r < buckets.length; r++) {
        const row = buckets[r];
        const n = row.length;
        const baseH = heights[r] * scales[r];
        const innerW = Math.max(1e-6, W - hgapI * Math.max(0, n - 1));
        const innerWInt = Math.max(0, Math.round(innerW));
  
        // Per-image factors (stable pseudo-random + portrait boost)
        const factors = [];
        for (let k = 0; k < n; k++) {
          const i = row[k];
          let f = 1 + (sRand(i * 97 + r * 131) - 0.5) * 2 * jitter;
          if (aspects[i] < 1) f += pboost;
          f = Math.max(0.6, Math.min(1.6, f));
          factors.push(f);
        }
  
        // Proportional widths, then quantize to exact inner width
        const widthsProp = row.map((i, k) => Math.max(1e-6, aspects[i]) * baseH * factors[k]);
        const widthsI = _quantizeToSum(widthsProp, innerWInt);
        const heightsI = row.map((i, k) => Math.max(1, Math.round(widthsI[k] / Math.max(1e-6, aspects[i]))));
        const rowBlockH = Math.max(...heightsI);
  
        let x = 0;
        for (let k = 0; k < n; k++) {
          const i = row[k];
          const wI = widthsI[k];
          const hI = heightsI[k];
          let top = y;
          if (align === 'center') top = y + Math.floor((rowBlockH - hI) / 2);
          positions[i] = { x, y: top, width: wI, height: hI };
          x += wI + hgapI;
        }
  
        blockHeights[r] = rowBlockH;
        y += rowBlockH + vgapI;
      }
  
      const totalH = blockHeights.reduce((s, v) => s + v, 0) + vgapI * Math.max(0, blockHeights.length - 1);
      const scaleAlpha = targetH ? targetH / Math.max(1e-6, totalH) : 1;
      // Early stop when within sub-pixel tolerance
      if (targetH && Math.abs(totalH - targetH) <= 0.5) {
        break;
      }
      scales = scales.map(s => s * scaleAlpha);
    }
  
    return positions;
  }

  function solveBalancedNoCrop(aspects, W, H, hgap, vgap, opts) {
    let best = null;
    const N2 = aspects.length;
    const sqrtN = Math.max(2, Math.round(Math.sqrt(N2)));
    const rowsMin = Math.max(2, sqrtN - 1);
    const rowsMax = Math.min(8, sqrtN + 2);
    for (let rows = rowsMin; rows <= rowsMax; rows++) {
      const buckets = balancedPartition(aspects, rows);
      if (buckets.some(b => b.length === 0)) continue;

      let heights = computeRowHeights(buckets, aspects, W, hgap);
      heights = scaleHeightsToH(heights, H, vgap);

      // Use mosaic (per-image variable height) when requested
      const pos = (opts && opts.mosaic)
        ? buildRowPositionsMosaic(buckets, heights, aspects, W, hgap, vgap, { jitter: opts.jitter, pboost: opts.pboost, align: opts.align, targetH: H })
        : buildRowPositions(buckets, heights, aspects, W, H, hgap, vgap);

      const used = pos.reduce((s, p) => s + p.width * p.height, 0);
      const util = used / (W * H);
      const minH = Math.min(...heights), maxH = Math.max(...heights);
      const uniform = maxH - minH;
      const rowsPref = Math.abs(rows - sqrtN);
      const score = (1 - util) * 120 + uniform * 0.6 + rowsPref * 0.5;
      if (!best || score < best.score) {
        best = { rows, pos, util, uniform, score };
      }
    }
    return best;
  }

  // ---------- Absolute placement ----------
  function place(root, tiles, imgs, positions) {
    root.style.position = 'relative';
    root.style.overflow = 'hidden';
    const animate = ((root.dataset.animate || 'true') + '').toLowerCase() !== 'false';
    const first = !root.__laid;
    for (let p = 0; p < positions.length; p++) {
      const P = positions[p];
      const i = (P.idx != null) ? P.idx : p; // 支援兩種格式
      const el = imgs[i];
      const tile = tiles[i];
      if (!el || !tile) continue;
      const tileStyle = tile.style;
      tileStyle.position = 'absolute';
      tileStyle.margin = '0';
      tileStyle.padding = '0';
      tileStyle.border = '0';
      tileStyle.display = 'flex';
      tileStyle.alignItems = 'center';
      tileStyle.justifyContent = 'center';
      tileStyle.overflow = 'hidden';
      tileStyle.left = P.x + 'px';
      tileStyle.top  = P.y + 'px';
      tileStyle.width  = P.width + 'px';
      tileStyle.height = P.height + 'px';
      // Smooth transitions only after first layout
      if (animate && !first) {
        tileStyle.transition = 'left 160ms ease, top 160ms ease, width 160ms ease, height 160ms ease';
        tileStyle.willChange = 'left, top, width, height';
      } else {
        tileStyle.transition = 'none';
        tileStyle.willChange = '';
      }
      const s = el.style;
      s.position = 'static';
      s.margin = '0';
      s.padding = '0';
      s.border = '0';
      s.maxWidth = '100%';
      s.maxHeight = '100%';
      s.width = 'auto';
      s.height = 'auto';
      s.display = 'block';
      s.flexShrink = '0';
      s.transition = 'none';
      s.willChange = '';
      try { s.removeProperty('object-fit'); } catch(_) {}
      try { s.removeProperty('object-position'); } catch(_) {}
    }
    // Debug: log first 10 tiles' box sizes vs natural aspect when enabled
    if (DEBUG_ENABLED && window.__COLLAGE_LOG_TILES) {
      const cap = Math.min(10, positions.length);
      for (let p = 0; p < cap; p++) {
        const P = positions[p];
        const i = (P.idx != null) ? P.idx : p;
        const iw = imgs[i].naturalWidth || 0, ih = imgs[i].naturalHeight || 0;
        const imgAR = ih > 0 ? iw / ih : 0;
        const boxAR = P.height > 0 ? P.width / P.height : 0;
        const boxW = +(P.width).toFixed(2);
        const boxH = +(P.height).toFixed(2);
        const boxARf = +(boxAR).toFixed(3);
        const imgARf = +(imgAR).toFixed(3);
        log('[Tile]', { idx: i, boxW, boxH, boxAR: boxARf, imgAR: imgARf });
      }
    }
    root.__laid = true;
  }

  // ---------- Layout one box ----------
  function layoutBox(root) {
    const W = root.clientWidth;
    const H = root.clientHeight;
    const flow = (root.dataset.flow || 'auto').toLowerCase(); // 'auto' | 'col' | 'row'
    const imgsCount = root.querySelectorAll('img').length;
    const defGap = imgsCount > 20 ? 2 : 4;
    const minUtil = clampRange(getDataNumber(root.dataset, ['minutil'], 0.88), 0, 1); // 利用率門檻（預設 0.88）
    const minImgH = clampNonNeg(getDataNumber(root.dataset, ['minimg','minimageheight'], 24));

    const autoCols = (function(){
      const N = imgsCount;
      if (N <= 2) return {min: N, max: N};
      if (N <= 4) return {min: 2, max: 3};
      if (N <= 7) return {min: 3, max: 4};
      if (N <= 12) return {min: 3, max: 6};
      if (N <= 20) return {min: 4, max: 7};
      return {min: 4, max: 8};
    })();

    const minCols = clampInt(getDataNumber(root.dataset, ['mincols'], autoCols.min), 1, 99);
    const maxCols = clampInt(getDataNumber(root.dataset, ['maxcols'], autoCols.max), 1, 99);
    const hgap = clampNonNeg(getDataNumber(root.dataset, ['hgap','hGap'], defGap));
    const vgap = clampNonNeg(getDataNumber(root.dataset, ['vgap','vGap'], defGap));
    // Dynamic minUtil threshold based on collection size
    let effMinUtil = minUtil;
    if (imgsCount > 30) effMinUtil = Math.max(effMinUtil, 0.94);
    else if (imgsCount > 16) effMinUtil = Math.max(effMinUtil, 0.92);

    const imgs = Array.from(root.querySelectorAll('img'));
    const tiles = ensureTiles(root, imgs);
    if (!imgs.length || W <= 0 || H <= 0) return;

    const aspects = imgs.map(img => {
      let a = hasNumber(img.dataset.aspect) ? +img.dataset.aspect : NaN;
      if (!(a > 0)) {
        const w = img.naturalWidth || 0, h = img.naturalHeight || 0;
        a = (w > 0 && h > 0) ? (w / h) : 4 / 3;
        try { img.dataset.aspect = String(a); } catch (_) {}
      }
      return a;
    });

    // Small set visual rules for N ≤ 4
    const Nsmall = aspects.length;
    if (Nsmall <= 4) {
      const positionsSmall = buildSmallSetPositions(aspects, W, H, hgap, vgap);
      place(root, tiles, imgs, positionsSmall);
      log('[SmallSet] layout used', { N: Nsmall });
      return;
    }
  
    if (flow === 'col' || flow === 'column' || flow === 'bycol' || flow === 'auto') {
      log('[ColumnNoCrop] === 開始佈局 ===');
      const best = solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols, minImgH);
      if (best) {
        const positions = buildColumnPositions(best, W, H, hgap, vgap);
        const used = positions.reduce((s, p) => s + p.width * p.height, 0);
        const util = used / (W * H);
        log('[ColumnNoCrop] Utilization', (util * 100).toFixed(2) + '%');

        // 若欄式利用率太低 → 自動改用 row 方案以補滿空白
        if (util >= effMinUtil) {
          place(root, tiles, imgs, positions);
          log('[ColumnNoCrop] === 佈局完成 ===');
          return;
        } else {
          log('[ColumnNoCrop] 利用率低於門檻，回退 BalancedNoCrop', {minUtil: effMinUtil});
        }
      } else {
        // 若無可行，回退 row
        log('[ColumnNoCrop] 無解，回退 BalancedNoCrop');
      }
    }

    // Row fallback / 或 flow=row
    log('[BalancedNoCrop] === 開始佈局 ===');
    const style = (root.dataset.style || '').toLowerCase();
    let jitter = getDataNumber(root.dataset, ['jitter'], NaN);
    let pboost = getDataNumber(root.dataset, ['portraitboost'], NaN);

    // Auto mosaic decision when style is not specified
    let mosaicAuto = false;
    if (!style) {
      const aMin = Math.min(...aspects);
      const aMax = Math.max(...aspects);
      const variety = aMax / Math.max(1e-6, aMin);
      const portraitShare = aspects.filter(a => a < 1).length / aspects.length;
      mosaicAuto = variety > 2.0 || portraitShare > 0.30;
    }
    const useMosaic = (style === 'mosaic') || mosaicAuto || (hasNumber(jitter) && jitter > 0);

    // Defaults when not provided
    if (!hasNumber(jitter)) jitter = useMosaic ? 0.12 : 0;
    if (!hasNumber(pboost)) pboost = useMosaic ? 0.15 : 0;

    const opts = { mosaic: useMosaic, jitter: clampRange(jitter, 0, 1), pboost: clampRange(pboost, 0, 1), align: 'center' };
    const sol = solveBalancedNoCrop(aspects, W, H, hgap, vgap, opts);
    if (sol) {
      place(root, tiles, imgs, sol.pos);
      log('[BalancedNoCrop] Utilization', (sol.util * 100).toFixed(2) + '%');
      log('[BalancedNoCrop] === 佈局完成 ===');
    }
  }

  // ---------- Init ----------
  async function init(selector = '.' + CLASS) {
    // Hide debug panel unless explicitly enabled
    const dbg = document.getElementById('debugInfo');
    if (dbg && !DEBUG_ENABLED) { dbg.style.display = 'none'; }

    const boxes = Array.from(document.querySelectorAll(selector));
    const roList = [];
    for (const root of boxes) {
      const imgs = Array.from(root.querySelectorAll('img'));
      await Promise.all(imgs.map(preload));
      await raf2();
      layoutBox(root);
      const debouncedLayout = debounce(() => layoutBox(root), 80);
      const ro = new ResizeObserver(debouncedLayout);
      ro.observe(root);
      roList.push(ro);
    }
    window.CollageModes = {
      relayout() { boxes.forEach(layoutBox); },
      disconnect() { roList.forEach(ro => ro.disconnect()); }
    };

    // Auto cleanup observers on page lifecycle end
    try {
      window.addEventListener('pagehide', () => {
        try { window.CollageModes && window.CollageModes.disconnect(); } catch(_) {}
      }, { once: true });
      window.addEventListener('beforeunload', () => {
        try { window.CollageModes && window.CollageModes.disconnect(); } catch(_) {}
      }, { once: true });
    } catch(_) {}

  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => init());
  } else {
    init();
  }
})();
</script>

</body>
</html>
