<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Collage - No-Crop Column Flow + Balanced Row</title>
  <style>
    body {
      margin: 20px;
      font-family: Arial, sans-serif;
    }
    .debug-info {
      margin-top: 20px;
      padding: 10px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }

    /* Collage defaults: prevent clipping, keep images contained */
    .img_collage {
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
    }
    .img_collage *,
    .img_collage img {
      box-sizing: border-box;
    }
    .img_collage img {
      display: block;
      image-rendering: auto;
      -webkit-user-drag: none;
      user-select: none;
      max-width: 100%;
      max-height: 100%;
    }
    .img_collage__tile {
      position: absolute;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      padding: 0;
      border: 0;
    }
  </style>
</head>
<body>

<h3>Image Collage - Fixed 640x500 (No Crop) — Column-first flow enabled</h3>

<!-- Explanation:
  - data-flow="col" → Column-first layout (height-priority): place images top-to-bottom, then left-to-right (fills container height). Good for uneven counts like 19/20.
  - data-flow can be switched to "row" → Use BalancedNoCrop row-based layout (width-priority, equal row heights).
  - data-mincols / data-maxcols → Search range for number of columns (used by column mode).
  - data-hgap / data-vgap → Horizontal and vertical gaps between columns/images.
  - data-minutil → Minimum utilization threshold for column mode (0..1, default 0.88). If below threshold, automatically fallback to row mode to fill empty space.
-->
<div
  class="img_collage"
  style="width:720px;height:200px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:720px;height:200px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:720px;height:200px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:720px;height:200px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/800/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1300/720.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/678/888.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1020/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1041/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1021/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1025/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1043/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1003/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1024/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1027/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1028/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1029/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1031/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1032/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1033/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1035/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1036/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1037/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1040/800/1200.jpg"   alt="">
</div>

<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1020/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1041/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1021/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1035/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1036/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1037/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1040/800/1200.jpg"   alt="">
</div>

<script>
/*!
 * ColumnNoCrop v1.0 + BalancedNoCrop v4.0
 * - ColumnNoCrop (height-priority, column mode): fills container height; place images top-to-bottom then left-to-right. Columns exactly fill H, no cropping, no distortion.
 *   Stable for uneven counts such as N=19/20. Automatically searches for column count and per-column image distribution. Extra horizontal space is allocated to column gaps to avoid uneven seams.
 * - BalancedNoCrop (width-priority, row mode): fills width with consistent row heights; previous versions demonstrated >95% utilization.
 */
(function(){
  "use strict";
  const CLASS = "img_collage";

  // Debug config
  window.__COLLAGE_DEBUG = true;
  const DEBUG_ENABLED = !!window.__COLLAGE_DEBUG;
  const MAX_DEBUG_LINES = 500;

  // ---------- Debug Logger ----------
  function log(message, data) {
    if (DEBUG_ENABLED) {
      console.log(message, data ?? '');
      const debugDiv = document.getElementById('debugInfo');
      if (debugDiv) {
        const line = document.createElement('div');
        line.textContent = `${message} ${data !== undefined ? JSON.stringify(data) : ''}`;
        debugDiv.appendChild(line);
        // Trim debug lines to avoid DOM bloat
        while (debugDiv.childElementCount > MAX_DEBUG_LINES) {
          debugDiv.removeChild(debugDiv.firstChild);
        }
      }
    }
  }

  // ---------- Helpers ----------
  const raf2 = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

  // Basic debounce to reduce layout thrashing on resize
  function debounce(fn, delay = 80) {
    let t;
    return function(...args) {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  function preload(img){
    return new Promise(res=>{
      if (img.complete && img.naturalWidth>0) { res(); return; }
      img.addEventListener('load', res, {once:true});
      img.addEventListener('error', res, {once:true});
    });
  }

  function findRootChild(img, root) {
    let node = img;
    while (node && node.parentNode) {
      const parent = node.parentNode;
      if (parent === root) {
        if (node.classList && node.classList.contains('img_collage__tile')) {
          return null;
        }
        return node;
      }
      if (!(parent instanceof HTMLElement)) break;
      if (parent.classList && parent.classList.contains('img_collage__tile')) {
        return null;
      }
      node = parent;
    }
    return null;
  }

  function ensureTiles(root, imgs) {
    return imgs.map((img, index) => {
      const rootChild = findRootChild(img, root);
      let tile = img.__collageTile;
      const needsNewTile = !tile || tile.parentNode !== root;

      if (needsNewTile) {
        tile = document.createElement('div');
        tile.className = 'img_collage__tile';
        if (rootChild && rootChild.parentNode === root) {
          root.insertBefore(tile, rootChild);
          tile.appendChild(rootChild);
        } else {
          root.appendChild(tile);
          tile.appendChild(img);
        }
        img.__collageTile = tile;
      } else if (rootChild && rootChild.parentNode !== tile) {
        tile.appendChild(rootChild);
      } else if (!tile.contains(img)) {
        tile.appendChild(img);
      }

      tile.dataset.index = index;
      return tile;
    });
  }

  // Numeric parsing helpers (allow 0, clamp ranges)
  const EPS = 1e-6;
  function hasNumber(v){ return v !== undefined && v !== null && v !== '' && !Number.isNaN(+v); }
  function getDataNumber(ds, keys, def){
    if (!Array.isArray(keys)) keys = [keys];
    for (const k of keys) {
      if (hasNumber(ds[k])) return +ds[k];
    }
    return def;
  }
  function clampRange(x, lo, hi){ return Math.min(hi, Math.max(lo, x)); }
  function clampNonNeg(x){ return Math.max(0, x); }
  function clampInt(x, lo, hi){
    const n = Math.round(+x);
    const v = Number.isFinite(n) ? n : lo;
    return Math.min(hi, Math.max(lo, v));
  }

  // Quantize helpers — convert float slices to integers that exactly sum to target
  function _quantizeToSum(valuesF, targetInt){
    const n = valuesF.length;
    if (n === 0) return [];
    const T = Math.max(0, Math.round(targetInt));
    let vals = valuesF.map(v => Math.max(0, +v || 0));
    const sumF = vals.reduce((s, v) => s + v, 0);
    if (!(sumF > 0)) {
      // fallback: evenly distribute target when inputs are all zero/non-finite
      const out = new Array(n).fill(0);
      for (let k = 0; k < T; k++) out[k % n] += 1;
      return out;
    }
    // Scale to target first so floors never exceed target
    const alpha = T / sumF;
    vals = vals.map(v => v * alpha);

    // Floor and distribute remaining pixels by fractional part
    const ints = vals.map(v => Math.floor(v));
    let diff = T - ints.reduce((s, v) => s + v, 0);
    if (diff > 0) {
      const order = vals.map((v,i)=>({i, f: v - Math.floor(v)})).sort((a,b)=>b.f - a.f);
      for (let k = 0; k < diff; k++) {
        const idx = order[k % n].i;
        ints[idx] += 1;
      }
    } else if (diff < 0) {
      // Extremely rare due to rounding; remove from smallest fractional parts
      const order = vals.map((v,i)=>({i, f: v - Math.floor(v)})).sort((a,b)=>a.f - b.f);
      for (let k = 0; k < -diff; k++) {
        // find any slot with >0 to decrement
        let t = k % n, tries = 0;
        while (tries < n && ints[order[t].i] <= 0) { t = (t + 1) % n; tries++; }
        if (tries < n) ints[order[t].i] -= 1;
      }
    }
    return ints;
  }
  function _sum(arr){ return arr.reduce((s,v)=>s+v,0); }

  // ---------- ColumnNoCrop: compositions generator ----------
  function generateCompositions(n, k, cb, control) {
    // Generate compositions of k positive integers that sum to n; stream via callback to avoid large memory usage
    control = control || {};
    const now = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : () => Date.now();
    const deadline = Number.isFinite(control.deadline) ? control.deadline : Infinity;
    const limit = Number.isFinite(control.limit) ? control.limit : Infinity;
    let count = 0;

    function shouldStop() {
      if (count >= limit) { control.stopped = true; control.truncated = true; return true; }
      if (now() > deadline) { control.stopped = true; control.truncated = true; return true; }
      return false;
    }

    function rec(parts, left, slots) {
      if (control.stopped) return;
      if (slots === 1) {
        cb([...parts, left]);
        count++;
        if (shouldStop()) return;
        return;
      }
      const maxT = left - (slots - 1);
      for (let t = 1; t <= maxT; t++) {
        if (control.stopped) return;
        parts.push(t);
        rec(parts, left - t, slots - 1);
        parts.pop();
        if (control.stopped) return;
      }
    }
    rec([], n, k);
    control.count = count;
  }

  // ---------- ColumnNoCrop: solver ----------
  function solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols, minImgH) {
    log('[ColumnNoCrop] Start', {W,H,N:aspects.length, minCols, maxCols});
    let best = null;

    // Compute feasible range for number of columns: cannot exceed N; allow values below minCols to ensure a solution when N is small or width is constrained
    const N = aspects.length;
    const cMax = Math.min(Math.max(minCols, maxCols), N);
    const cMin = 1;
    const nowFn = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : () => Date.now();

    // Prefer trying more columns first; if none are feasible, reduce the column count stepwise (avoids negative gaps)
    for (let C = cMax; C >= cMin; C--) {
      const ctrl = { limit: 200000, deadline: nowFn() + 12 };
      generateCompositions(N, C, (counts) => {
        // In input order: fill top-to-bottom, then move to the next column
        let idx = 0;
        const cols = [];
        const widths = [];

        let invalid = false;
        for (let j = 0; j < C; j++) {
          const cnt = counts[j];
          const list = aspects.slice(idx, idx + cnt);
          idx += cnt;

          const H_eff = H - vgap * Math.max(0, cnt - 1);
          if (H_eff <= 0) { invalid = true; break; }

          const Sj = list.reduce((s, a) => s + 1 / Math.max(1e-6, a), 0); // Σ(1/a)
          if (!(Sj > 1e-6) || !Number.isFinite(Sj)) { invalid = true; break; }

          const wj = H_eff / Math.max(1e-6, Sj); // 欄寬 wj，使 Σ(wj/a) + gaps = H → 滿高
          if (!(wj > 0) || !Number.isFinite(wj)) { invalid = true; break; }

          // minimal image height constraint for this column
          const maxA = list.reduce((m, a) => Math.max(m, Math.max(1e-6, a)), 1e-6);
          const minHCol = wj / maxA;
          if (Number.isFinite(minImgH) && minImgH > 0 && minHCol < minImgH) { invalid = true; break; }

          cols.push({ count: cnt, aspects: list });
          widths.push(wj);
        }
        if (invalid) { return; }

        const sumW = widths.reduce((s, v) => s + v, 0);
        const neededGap = (C > 1) ? (W - sumW) / (C - 1) : 0; // 讓總寬 + gap*(C-1) 精確 = W

        // 若 neededGap 為負，代表以滿高無法鋪滿寬度 → 此欄數不可行，跳過
        if (neededGap < -1e-6) {
          return;
        }

        // Scoring: prefer neededGap close to target hgap, balanced column widths, higher utilization, and a preferred column count
        const meanW = sumW / C;
        const varW = widths.reduce((s, v) => s + (v - meanW) * (v - meanW), 0) / C;
        const usedArea = widths.reduce((s, w, j) => s + w * Math.max(0, H - vgap * Math.max(0, counts[j] - 1)), 0);
        const utilEst = usedArea / Math.max(1e-6, W * H);
        const colsPref = Math.abs(C - Math.max(2, Math.round(Math.sqrt(N))));
        const score = Math.abs(neededGap - hgap) * 2.5 + Math.sqrt(varW) * 0.7 + (1 - utilEst) * 80 + colsPref * 0.3;

        if (!best || score < best.score) {
          best = { C, counts, cols, widths, neededGap, sumW, score };
        }
      }, ctrl);

      if (ctrl.truncated) {
        log('[ColumnNoCrop] compositions truncated', { C, visited: ctrl.count });
      }

      // 若已找到可行解且 gap 非負，即可提前結束（偏好較多欄的可行解）
      if (best) break;
    }

    if (best) {
      log('[ColumnNoCrop] Best', { cols: best.C, neededGap: +best.neededGap.toFixed(2), score: +best.score.toFixed(3) });
    } else {
      log('[ColumnNoCrop] No feasible partition');
    }
    return best;
  }

  // Quantized column positions: integer-safe widths/heights, distributed remainders to avoid sub-pixel seams
  function buildColumnPositions(best, W, H, hgap, vgap) {
    const EPS2 = 1e-6;
    const C = best.C;
    const gapF = C > 1 ? best.neededGap : 0;
    const g = C > 1 ? Math.max(0, Math.round(gapF)) : 0;       // integer horizontal gap
    const vInt = Math.max(0, Math.round(vgap));                 // integer vertical gap

    // 1) Quantize column widths so that Σ widths + g*(C-1) = W
    const avail = W - g * Math.max(0, C - 1);
    const widthsF = best.widths.slice();
    const sumWF = widthsF.reduce((s, v) => s + v, 0);
    const scaled = widthsF.map(w => w * avail / Math.max(EPS2, sumWF));

    const widthsI = scaled.map(w => Math.floor(w));
    const fracCol = scaled.map((w, i) => ({ i, f: w - Math.floor(w) })).sort((a, b) => b.f - a.f);
    let remW = Math.round(avail - widthsI.reduce((s, v) => s + v, 0));
    for (let k = 0; k < remW; k++) widthsI[fracCol[k % fracCol.length].i] += 1;

    const positions = [];
    let globalIndex = 0;
    let x = 0;

    // 2) For each column, quantize heights so that Σ heights + vInt*(n-1) = H
    for (let j = 0; j < C; j++) {
      const col = best.cols[j];
      const wInt = Math.max(0, widthsI[j]);

      // base heights by aspect
      const baseH = col.aspects.map(a => wInt / Math.max(EPS2, a));
      const availH = H - vInt * Math.max(0, col.count - 1);
      const sumHF = baseH.reduce((s, v) => s + v, 0);
      const scaledH = baseH.map(h => h * availH / Math.max(EPS2, sumHF));

      const heightsI = scaledH.map(h => Math.floor(h));
      const fracH = scaledH.map((h, i) => ({ i, f: h - Math.floor(h) })).sort((a, b) => b.f - a.f);
      let remH = Math.round(availH - heightsI.reduce((s, v) => s + v, 0));
      for (let k = 0; k < remH; k++) heightsI[fracH[k % fracH.length].i] += 1;

      // push tiles top-down with integer coordinates
      let y = 0;
      for (let i = 0; i < col.count; i++) {
        const hInt = Math.max(0, heightsI[i]);
        positions.push({ idx: globalIndex, x: Math.round(x), y: Math.round(y), width: wInt, height: hInt });
        y += hInt + vInt;
        globalIndex++;
      }
      x += wInt + (j < C - 1 ? g : 0);
    }

    // 3) Final correction: if there is a drift from rounding, absorb to the last column's last tile width
    const drift = Math.round(W - x);
    if (drift !== 0 && positions.length) {
      // find last column tiles: they have maximum x among positions
      let maxX = -Infinity, idxLast = -1;
      for (let p = 0; p < positions.length; p++) if (positions[p].x > maxX) { maxX = positions[p].x; idxLast = p; }
      if (idxLast >= 0) positions[idxLast].width = Math.max(0, positions[idxLast].width + drift);
    }
    return positions;
  }

  // ---------- Small-set visual layouts (N ≤ 4) ----------
  function buildSmallSetPositions(aspects, W, H, hgap, vgap) {
    const N = aspects.length;
    const pos = [];
    const innerW = (n) => W - hgap * Math.max(0, n - 1);
    const EPS2 = 1e-6;
    function pushIdx(idx, x, y, w, h, target){
      const list = Array.isArray(target) ? target : pos;
      list.push({
        idx,
        x: Math.round(x),
        y: Math.round(y),
        width: Math.max(0, Math.round(w)),
        height: Math.max(0, Math.round(h))
      });
    }

    if (N === 1) {
      const a = Math.max(EPS2, aspects[0]);
      let w = W, h = W / a;
      if (h > H) { h = H; w = H * a; }
      const x = (W - w) / 2; const y = (H - h) / 2;
      pushIdx(0, x, y, w, h);
      return pos;
    }

    if (N === 2) {
      const gapH = Math.max(0, Math.round(hgap));
      const iw = innerW(2);
      if (!(iw > 0)) return pos;
      const sA = Math.max(EPS2, aspects[0] + aspects[1]);
      const idealH = Math.min(H, iw / sA);
      const hI = Math.max(1, Math.round(Math.max(0, idealH)));
      const widthsF = [aspects[0] * hI, aspects[1] * hI];
      const limit = Math.max(1, Math.round(iw));
      let target = Math.round(widthsF[0] + widthsF[1]);
      target = Math.max(1, Math.min(limit, target));
      const widthsI = _quantizeToSum(widthsF, target);
      if (widthsI.length !== 2 || widthsI.some(w => w <= 0)) return pos;
      const totalRow = widthsI[0] + widthsI[1] + gapH * Math.max(0, 2 - 1);
      const xStart = Math.round(Math.max(0, (W - totalRow) / 2));
      const top = Math.round(Math.max(0, (H - hI) / 2));
      let x = xStart;
      pushIdx(0, x, top, widthsI[0], hI); x += widthsI[0] + gapH;
      pushIdx(1, x, top, widthsI[1], hI);
      return pos;
    }

    if (N === 3) {
      const gapH = Math.max(0, Math.round(hgap));
      const gapV = Math.max(0, Math.round(vgap));

      function computeStats(layout, tag) {
        if (!Array.isArray(layout) || layout.length !== N) return null;
        let tileArea = 0;
        let imgArea = 0;
        for (const tile of layout) {
          if (!tile) return null;
          const { width, height, idx } = tile;
          if (!(width >= 0 && height >= 0)) return null;
          tileArea += width * height;
          const aspect = Math.max(EPS2, aspects[idx]);
          if (width === 0 || height === 0) continue;
          const boxAspect = width / height;
          let imgW, imgH;
          if (boxAspect >= aspect) {
            imgH = height;
            imgW = height * aspect;
          } else {
            imgW = width;
            imgH = width / aspect;
          }
          imgArea += Math.max(0, imgW * imgH);
        }
        const containerArea = Math.max(EPS2, W * H);
        const coverage = imgArea / containerArea;
        const fill = tileArea / containerArea;
        const stat = layout.slice();
        stat._tag = tag;
        stat._coverage = coverage;
        stat._fill = fill;
        return stat;
      }

      function layoutSingleRow() {
        const iw = Math.max(0, W - gapH * Math.max(0, N - 1));
        if (!(iw > 0)) return [];
        const sumA = aspects.reduce((s, a) => s + Math.max(EPS2, a), 0);
        const idealH = Math.min(H, iw / Math.max(EPS2, sumA));
        const hI = Math.max(1, Math.round(Math.max(0, idealH)));
        const widthsF = aspects.map(a => Math.max(EPS2, a) * hI);
        const limit = Math.max(1, Math.round(iw));
        let target = Math.round(widthsF.reduce((s, w) => s + w, 0));
        target = Math.max(1, Math.min(limit, target));
        const widthsI = _quantizeToSum(widthsF, target);
        if (widthsI.length !== N || widthsI.some(w => w <= 0)) return [];
        const totalRow = widthsI.reduce((s, w) => s + w, 0) + gapH * Math.max(0, N - 1);
        const xStart = Math.round(Math.max(0, (W - totalRow) / 2));
        const yStart = Math.round(Math.max(0, (H - hI) / 2));
        const layout = [];
        let x = xStart;
        for (let i = 0; i < N; i++) {
          pushIdx(i, x, yStart, widthsI[i], hI, layout);
          x += widthsI[i] + gapH;
        }
        return layout;
      }

      function layoutTwoPlusOne() {
        const layouts = [];
        const combos = [ [0,1,2], [0,2,1], [1,2,0] ];
        for (const [i,j,k] of combos) {
          const iwTop = Math.max(0, innerW(2));
          const iwBottom = Math.max(0, innerW(1));
          if (!(iwTop > 0 && iwBottom > 0)) continue;
          const hTopF = iwTop / Math.max(EPS2, aspects[i] + aspects[j]);
          const hBottomF = iwBottom / Math.max(EPS2, aspects[k]);
          const alpha = Math.max(EPS2, H - gapV) / Math.max(EPS2, hTopF + hBottomF);
          const H1 = hTopF * alpha;
          const H2 = hBottomF * alpha;
          const heights = _quantizeToSum([H1, H2], Math.max(0, Math.round(H - gapV)));
          if (heights.length < 2) continue;
          const H1I = Math.max(1, heights[0]);
          const H2I = Math.max(1, heights[1]);

          const widthsTopF = [aspects[i] * H1I, aspects[j] * H1I];
          const widthsBottomF = [aspects[k] * H2I];
          const limitTop = Math.max(1, Math.round(iwTop));
          const limitBottom = Math.max(1, Math.round(iwBottom));
          let targetTop = Math.round(widthsTopF[0] + widthsTopF[1]);
          targetTop = Math.max(1, Math.min(limitTop, targetTop));
          const widthsTopI = _quantizeToSum(widthsTopF, targetTop);
          if (widthsTopI.length !== 2 || widthsTopI.some(w => w <= 0)) continue;

          let targetBottom = Math.round(widthsBottomF[0]);
          targetBottom = Math.max(1, Math.min(limitBottom, targetBottom));
          const widthsBottomI = _quantizeToSum(widthsBottomF, targetBottom);
          if (widthsBottomI.length !== 1 || widthsBottomI[0] <= 0) continue;

          const layout = [];
          const row1Width = widthsTopI[0] + widthsTopI[1] + gapH;
          const totalHeight = H1I + gapV + H2I;
          const offsetY = Math.round(Math.max(0, (H - totalHeight) / 2));
          let x = Math.round(Math.max(0, (W - row1Width) / 2));
          const y1 = offsetY;
          pushIdx(i, x, y1, widthsTopI[0], H1I, layout);
          x += widthsTopI[0] + gapH;
          pushIdx(j, x, y1, widthsTopI[1], H1I, layout);

          const y2 = y1 + H1I + gapV;
          const widthBottom = widthsBottomI[0];
          const xk = Math.round(Math.max(0, (W - widthBottom) / 2));
          pushIdx(k, xk, y2, widthBottom, H2I, layout);
          layouts.push(layout);
        }
        return layouts;
      }

      const candidates = [];
      const singleRow = layoutSingleRow();
      if (singleRow.length === N) {
        const stats = computeStats(singleRow, 'row3');
        if (stats) candidates.push(stats);
      }
      for (const layout of layoutTwoPlusOne()) {
        if (layout.length === N) {
          const stats = computeStats(layout, '2plus1');
          if (stats) candidates.push(stats);
        }
      }
      if (!candidates.length) return pos;
      candidates.sort((a, b) => {
        if (Math.abs(b._coverage - a._coverage) > 1e-6) return b._coverage - a._coverage;
        return b._fill - a._fill;
      });
      const best = candidates[0];
      best._tag = best._tag || 'row3';
      const result = best.map(tile => ({ ...tile }));
      result._tag = best._tag;
      return result;
    }

    if (N === 4) {
      const gapH = Math.max(0, hgap);
      const gapV = Math.max(0, vgap);
      const hgapI = Math.max(0, Math.round(gapH));
      const vgapI = Math.max(0, Math.round(gapV));

      function computeContainCoverage(layout){
        if (!Array.isArray(layout) || layout.length !== N) return null;
        let tileArea = 0;
        let imgArea = 0;
        for (const tile of layout) {
          if (!tile) return null;
          const { width, height, idx } = tile;
          if (!(width >= 0 && height >= 0 && Number.isFinite(width) && Number.isFinite(height))) return null;
          const areaTile = width * height;
          tileArea += areaTile;
          const aspect = Math.max(EPS2, aspects[idx]);
          if (height === 0 || width === 0) continue;
          const tileAspect = width / height;
          let imgW, imgH;
          if (tileAspect >= aspect) {
            imgH = height;
            imgW = height * aspect;
          } else {
            imgW = width;
            imgH = width / aspect;
          }
          imgArea += Math.max(0, imgW * imgH);
        }
        const containerArea = Math.max(EPS2, W * H);
        const coverage = imgArea / containerArea;
        const fill = tileArea / containerArea;
        return { layout, coverage, fill };
      }

      function layoutGrid2x2(){
        const grid = [];
        const pairs = [ [ [0,1],[2,3] ], [ [0,2],[1,3] ], [ [0,3],[1,2] ] ];
        let best = null;
        for (const [[a,b],[c,d]] of pairs) {
          const s1 = aspects[a] + aspects[b];
          const s2 = aspects[c] + aspects[d];
          const diff = Math.abs(s1 - s2);
          if (!best || diff < best.diff) best = { rows: [[a,b],[c,d]], diff };
        }
        if (!best) return grid;
        const [[r1a, r1b],[r2a, r2b]] = best.rows;
        const iw = Math.max(0, Math.round(innerW(2)));

        const h1F = iw / Math.max(EPS2, aspects[r1a] + aspects[r1b]);
        const h2F = iw / Math.max(EPS2, aspects[r2a] + aspects[r2b]);
        const alpha = Math.max(EPS2, H - gapV) / Math.max(EPS2, h1F + h2F);
        const H1F = h1F * alpha;
        const H2F = h2F * alpha;

        const heightsI = _quantizeToSum([H1F, H2F], Math.max(0, Math.round(H - gapV)));
        if (heightsI.length < 2 || heightsI[0] <= 0 || heightsI[1] <= 0) return [];
        const H1I = heightsI[0];
        const H2I = heightsI[1];

        const w1F = [aspects[r1a] * H1I, aspects[r1b] * H1I];
        const w1I = _quantizeToSum(w1F, iw);
        if (w1I.length < 2 || w1I[0] <= 0 || w1I[1] <= 0) return [];
        const w2F = [aspects[r2a] * H2I, aspects[r2b] * H2I];
        const w2I = _quantizeToSum(w2F, iw);
        if (w2I.length < 2 || w2I[0] <= 0 || w2I[1] <= 0) return [];

        let x1 = 0; const y1 = 0;
        pushIdx(r1a, x1, y1, w1I[0], H1I, grid); x1 += w1I[0] + hgapI;
        pushIdx(r1b, x1, y1, w1I[1], H1I, grid);

        let x2 = 0; const y2 = y1 + H1I + vgapI;
        pushIdx(r2a, x2, y2, w2I[0], H2I, grid); x2 += w2I[0] + hgapI;
        pushIdx(r2b, x2, y2, w2I[1], H2I, grid);
        return grid;
      }

      function layoutSingleRow(){
        const row = [];
        const n = aspects.length;
        const inner = Math.max(0, W - gapH * Math.max(0, n - 1));
        if (!(inner > 0)) return row;
        const sumA = aspects.reduce((s, a) => s + Math.max(EPS2, a), 0);
        const idealH = Math.min(H, inner / Math.max(EPS2, sumA));
        if (!(idealH > 0)) return row;
        const hI = Math.max(1, Math.round(Math.min(H, idealH)));
        const widthsF = aspects.map(a => Math.max(EPS2, a) * hI);
        let sumW = widthsF.reduce((s, w) => s + w, 0);
        const limit = Math.max(1, Math.round(inner));
        if (sumW > limit) {
          const scale = limit / sumW;
          for (let i = 0; i < widthsF.length; i++) widthsF[i] *= scale;
          sumW = widthsF.reduce((s, w) => s + w, 0);
        }
        const target = Math.max(1, Math.min(limit, Math.round(sumW)));
        const widthsI = _quantizeToSum(widthsF, target);
        if (widthsI.length !== n || widthsI.some(w => w <= 0)) return [];
        const totalRowW = widthsI.reduce((s, w) => s + w, 0) + hgapI * Math.max(0, n - 1);
        const xStart = Math.round(Math.max(0, (W - totalRowW) / 2));
        const yStart = Math.round(Math.max(0, (H - hI) / 2));
        let x = xStart;
        for (let i = 0; i < n; i++) {
          pushIdx(i, x, yStart, widthsI[i], hI, row);
          x += widthsI[i] + hgapI;
        }
        return row;
      }

      function permute3(groups){
        if (!Array.isArray(groups) || groups.length !== 3) return [];
        const [a,b,c] = groups;
        return [
          [a,b,c], [a,c,b],
          [b,a,c], [b,c,a],
          [c,a,b], [c,b,a]
        ];
      }

      function layoutColumns(groups){
        if (!Array.isArray(groups) || !groups.length) return [];
        const cols = [];
        const availWidth = W - gapH * Math.max(0, groups.length - 1);
        if (!(availWidth > 0)) return cols;
        const widthsF = groups.map(col => {
          const effectiveHf = H - gapV * Math.max(0, col.length - 1);
          if (!(effectiveHf > 0)) return 0;
          const denom = col.reduce((s, idx) => s + 1 / Math.max(EPS2, aspects[idx]), 0);
          if (!(denom > 0)) return 0;
          return effectiveHf / denom;
        });
        let sumWF = widthsF.reduce((s, w) => s + w, 0);
        if (!(sumWF > 0)) return cols;
        const scale = Math.min(1, availWidth / sumWF);
        const widthsAdj = widthsF.map(w => w * scale);
        const widthsI = widthsAdj.map(w => Math.max(0, Math.round(w)));
        if (widthsI.some(w => w <= 0)) return [];
        const limit = Math.max(1, Math.round(availWidth));
        let total = widthsI.reduce((s, w) => s + w, 0);
        if (total > limit) {
          const order = widthsAdj.map((w, i) => ({ i, w })).sort((a, b) => b.w - a.w);
          let ptr = 0;
          while (total > limit && ptr < order.length * 3) {
            const idx = order[ptr % order.length].i;
            if (widthsI[idx] > 1) {
              widthsI[idx] -= 1;
              total -= 1;
            }
            ptr++;
          }
          if (total > limit) return [];
        }
        const usedWidth = total + hgapI * Math.max(0, groups.length - 1);
        const xStart = Math.round(Math.max(0, (W - usedWidth) / 2));
        let x = xStart;
        for (let c = 0; c < groups.length; c++) {
          const colIdxs = groups[c];
          const width = widthsI[c];
          const effectiveHf = Math.max(0, H - gapV * Math.max(0, colIdxs.length - 1));
          const effectiveH = Math.max(0, Math.round(effectiveHf));
          if (!(effectiveH > 0)) return [];
          if (effectiveH < colIdxs.length) return [];
          const heightsF = colIdxs.map(idx => width / Math.max(EPS2, aspects[idx]));
          const heightsI = _quantizeToSum(heightsF, effectiveH);
          if (heightsI.length !== colIdxs.length || heightsI.some(h => h <= 0)) return [];
          let y = 0;
          for (let r = 0; r < colIdxs.length; r++) {
            const idx = colIdxs[r];
            pushIdx(idx, x, y, width, heightsI[r], cols);
            y += heightsI[r] + vgapI;
          }
          x += width + hgapI;
        }
        return cols;
      }

      function generateColumnLayouts(){
        const layouts = [];
        const indices = [0,1,2,3];
        for (let i = 0; i < indices.length; i++) {
          for (let j = i + 1; j < indices.length; j++) {
            const stackBase = [indices[i], indices[j]];
            const singles = indices.filter(idx => idx !== indices[i] && idx !== indices[j]);
            const stackOrders = [stackBase, [stackBase[1], stackBase[0]]];
            for (const stack of stackOrders) {
              const baseGroups = [ [singles[0]], [singles[1]], stack ];
              for (const perm of permute3(baseGroups)) {
                const layout = layoutColumns(perm);
                if (layout.length === N) layouts.push(layout);
              }
            }
          }
        }
        return layouts;
      }

      const candidates = [];
      const grid2x2 = layoutGrid2x2();
      if (grid2x2.length === N) {
        const stats = computeContainCoverage(grid2x2);
        if (stats) { stats.tag = 'grid2x2'; candidates.push(stats); }
      }
      const singleRow = layoutSingleRow();
      if (singleRow.length === N) {
        const stats = computeContainCoverage(singleRow);
        if (stats) { stats.tag = 'singleRow'; candidates.push(stats); }
      }
      for (const layout of generateColumnLayouts()) {
        const stats = computeContainCoverage(layout);
        if (stats) { stats.tag = 'mixedCols'; candidates.push(stats); }
      }
      const fallback = singleRow.length === N ? singleRow : grid2x2;
      if (!candidates.length) return fallback.length === N ? fallback : grid2x2;
      candidates.sort((a, b) => {
        if (Math.abs(b.coverage - a.coverage) > 1e-6) return b.coverage - a.coverage;
        return b.fill - a.fill;
      });
      const best = candidates[0];
      const chosen = best.layout.slice();
      chosen._tag = best.tag || 'grid2x2';
      return chosen;
    }
    return pos;
  }
  
  // ---------- BalancedNoCrop (kept as row-direction fallback / switching option) ----------
  function balancedPartition(aspects, rows) {
    const idxs = aspects.map((_, i) => i).sort((a, b) => aspects[b] - aspects[a]);
    const sums = new Array(rows).fill(0);
    const buckets = new Array(rows).fill(0).map(() => []);
    for (const i of idxs) {
      let bi = 0, mn = sums[0];
      for (let r = 1; r < rows; r++) {
        if (sums[r] < mn) { mn = sums[r]; bi = r; }
      }
      buckets[bi].push(i);
      sums[bi] += aspects[i];
    }
    return buckets;
  }

  function computeRowHeights(buckets, aspects, W, hgap) {
    return buckets.map(row => {
      const S = row.reduce((s, i) => s + aspects[i], 0);
      const n = row.length;
      const innerW = Math.max(1e-6, W - hgap * Math.max(0, n - 1));
      return innerW / Math.max(1e-6, S);
    });
  }

  function scaleHeightsToH(heights, H, vgap) {
    const sumH = heights.reduce((s, v) => s + v, 0);
    const target = H - vgap * Math.max(0, heights.length - 1);
    const alpha = target / Math.max(1e-6, sumH);
    return heights.map(h => h * alpha);
  }

  function buildRowPositions(buckets, heights, aspects, W, H, hgap, vgap) {
    const pos = new Array(aspects.length);
    const rows = buckets.length;
    const hgapI = Math.max(0, Math.round(hgap));
    const vgapI = Math.max(0, Math.round(vgap));

    // Quantize row heights to integers that sum exactly to H - gaps
    const targetRowsH = Math.max(0, Math.round(H - vgapI * Math.max(0, rows - 1)));
    const heightsI = _quantizeToSum(heights, targetRowsH).map(h => Math.max(1, h));

    let y = 0;
    for (let r = 0; r < rows; r++) {
      const row = buckets[r];
      const n = row.length;
      const hI = heightsI[r];
      const innerWInt = Math.max(0, Math.round(W - hgapI * Math.max(0, n - 1)));
      const widthsF = row.map(i => Math.max(1e-6, aspects[i]) * hI);
      const widthsI = _quantizeToSum(widthsF, innerWInt);

      let x = 0;
      for (let k = 0; k < n; k++) {
        const i = row[k];
        const wI = Math.max(0, widthsI[k]);
        pos[i] = { x, y, width: wI, height: hI };
        x += wI + hgapI;
      }
      y += hI + vgapI;
    }
    return pos;
  }

  // Mosaic variant: per-image variable heights within a row (no-crop), portrait-friendly.
  // - jitter: 0..1 random variation around base height per image
  // - pboost: 0..1 extra boost for portrait (a<1) to gain more height
  // - align: 'center' | 'top' vertical alignment inside row block
  function buildRowPositionsMosaic(buckets, heights, aspects, W, hgap, vgap, opts) {
    const jitter = Math.max(0, Math.min(1, (opts && +opts.jitter) || 0.12));
    const pboost = Math.max(0, Math.min(1, (opts && +opts.pboost) || 0.15));
    const align = (opts && opts.align) || 'center';
    const targetH = (opts && opts.targetH) || 0;
    const hgapI = Math.max(0, Math.round(hgap));
    const vgapI = Math.max(0, Math.round(vgap));
    function sRand(seed) { const x = Math.sin(seed) * 43758.5453123; return x - Math.floor(x); }
  
    let scales = new Array(buckets.length).fill(1);
    let positions = new Array(aspects.length);
  
    // Fixed-point like refinement to approach total H with integer-safe row blocks
    for (let iter = 0; iter < 3; iter++) {
      positions = new Array(aspects.length);
      let y = 0;
      const blockHeights = [];
  
      for (let r = 0; r < buckets.length; r++) {
        const row = buckets[r];
        const n = row.length;
        const baseH = heights[r] * scales[r];
        const innerW = Math.max(1e-6, W - hgapI * Math.max(0, n - 1));
        const innerWInt = Math.max(0, Math.round(innerW));
  
        // Per-image factors (stable pseudo-random + portrait boost)
        const factors = [];
        for (let k = 0; k < n; k++) {
          const i = row[k];
          let f = 1 + (sRand(i * 97 + r * 131) - 0.5) * 2 * jitter;
          if (aspects[i] < 1) f += pboost;
          f = Math.max(0.6, Math.min(1.6, f));
          factors.push(f);
        }
  
        // Proportional widths, then quantize to exact inner width
        const widthsProp = row.map((i, k) => Math.max(1e-6, aspects[i]) * baseH * factors[k]);
        const widthsI = _quantizeToSum(widthsProp, innerWInt);
        const heightsI = row.map((i, k) => Math.max(1, Math.round(widthsI[k] / Math.max(1e-6, aspects[i]))));
        const rowBlockH = Math.max(...heightsI);
  
        let x = 0;
        for (let k = 0; k < n; k++) {
          const i = row[k];
          const wI = widthsI[k];
          const hI = heightsI[k];
          let top = y;
          if (align === 'center') top = y + Math.floor((rowBlockH - hI) / 2);
          positions[i] = { x, y: top, width: wI, height: hI };
          x += wI + hgapI;
        }
  
        blockHeights[r] = rowBlockH;
        y += rowBlockH + vgapI;
      }
  
      const totalH = blockHeights.reduce((s, v) => s + v, 0) + vgapI * Math.max(0, blockHeights.length - 1);
      const scaleAlpha = targetH ? targetH / Math.max(1e-6, totalH) : 1;
      // Early stop when within sub-pixel tolerance
      if (targetH && Math.abs(totalH - targetH) <= 0.5) {
        break;
      }
      scales = scales.map(s => s * scaleAlpha);
    }
  
    return positions;
  }

  function solveBalancedNoCrop(aspects, W, H, hgap, vgap, opts) {
    let best = null;
    const N2 = aspects.length;
    const sqrtN = Math.max(2, Math.round(Math.sqrt(N2)));
    const rowsMin = Math.max(2, sqrtN - 1);
    const rowsMax = Math.min(8, sqrtN + 2);
    for (let rows = rowsMin; rows <= rowsMax; rows++) {
      const buckets = balancedPartition(aspects, rows);
      if (buckets.some(b => b.length === 0)) continue;

      let heights = computeRowHeights(buckets, aspects, W, hgap);
      heights = scaleHeightsToH(heights, H, vgap);

      // Use mosaic (per-image variable height) when requested
      const pos = (opts && opts.mosaic)
        ? buildRowPositionsMosaic(buckets, heights, aspects, W, hgap, vgap, { jitter: opts.jitter, pboost: opts.pboost, align: opts.align, targetH: H })
        : buildRowPositions(buckets, heights, aspects, W, H, hgap, vgap);

      const used = pos.reduce((s, p) => s + p.width * p.height, 0);
      const util = used / (W * H);
      const minH = Math.min(...heights), maxH = Math.max(...heights);
      const uniform = maxH - minH;
      const rowsPref = Math.abs(rows - sqrtN);
      const score = (1 - util) * 120 + uniform * 0.6 + rowsPref * 0.5;
      if (!best || score < best.score) {
        best = { rows, pos, util, uniform, score };
      }
    }
    return best;
  }

  // ---------- Absolute placement ----------
  function place(root, tiles, imgs, positions) {
    root.style.position = 'relative';
    root.style.overflow = 'hidden';
    const animate = ((root.dataset.animate || 'true') + '').toLowerCase() !== 'false';
    const first = !root.__laid;
    for (let p = 0; p < positions.length; p++) {
      const P = positions[p];
      const i = (P.idx != null) ? P.idx : p; // supports both position formats
      const el = imgs[i];
      const tile = tiles[i];
      if (!el || !tile) continue;
      const tileStyle = tile.style;
      tileStyle.position = 'absolute';
      tileStyle.margin = '0';
      tileStyle.padding = '0';
      tileStyle.border = '0';
      tileStyle.display = 'flex';
      tileStyle.alignItems = 'center';
      tileStyle.justifyContent = 'center';
      tileStyle.overflow = 'hidden';
      tileStyle.left = P.x + 'px';
      tileStyle.top  = P.y + 'px';
      tileStyle.width  = P.width + 'px';
      tileStyle.height = P.height + 'px';
      // Smooth transitions only after first layout
      if (animate && !first) {
        tileStyle.transition = 'left 160ms ease, top 160ms ease, width 160ms ease, height 160ms ease';
        tileStyle.willChange = 'left, top, width, height';
      } else {
        tileStyle.transition = 'none';
        tileStyle.willChange = '';
      }
      const s = el.style;
      s.position = 'static';
      s.margin = '0';
      s.padding = '0';
      s.border = '0';
      s.maxWidth = '100%';
      s.maxHeight = '100%';
      s.width = 'auto';
      s.height = 'auto';
      s.display = 'block';
      s.flexShrink = '0';
      s.transition = 'none';
      s.willChange = '';
      try { s.removeProperty('object-fit'); } catch(_) {}
      try { s.removeProperty('object-position'); } catch(_) {}
    }
    // Debug: log first 10 tiles' box sizes vs natural aspect when enabled
    if (DEBUG_ENABLED && window.__COLLAGE_LOG_TILES) {
      const cap = Math.min(10, positions.length);
      for (let p = 0; p < cap; p++) {
        const P = positions[p];
        const i = (P.idx != null) ? P.idx : p;
        const iw = imgs[i].naturalWidth || 0, ih = imgs[i].naturalHeight || 0;
        const imgAR = ih > 0 ? iw / ih : 0;
        const boxAR = P.height > 0 ? P.width / P.height : 0;
        const boxW = +(P.width).toFixed(2);
        const boxH = +(P.height).toFixed(2);
        const boxARf = +(boxAR).toFixed(3);
        const imgARf = +(imgAR).toFixed(3);
        log('[Tile]', { idx: i, boxW, boxH, boxAR: boxARf, imgAR: imgARf });
      }
    }
    root.__laid = true;
  }

  // ---------- Layout one box ----------
  function layoutBox(root) {
    const W = root.clientWidth;
    const H = root.clientHeight;
    const flow = (root.dataset.flow || 'auto').toLowerCase(); // 'auto' | 'col' | 'row'
    const imgsCount = root.querySelectorAll('img').length;
    const defGap = imgsCount > 20 ? 2 : 4;
    const minUtil = clampRange(getDataNumber(root.dataset, ['minutil'], 0.88), 0, 1); // 利用率門檻（預設 0.88）
    const minImgH = clampNonNeg(getDataNumber(root.dataset, ['minimg','minimageheight'], 24));

    const autoCols = (function(){
      const N = imgsCount;
      if (N <= 2) return {min: N, max: N};
      if (N <= 4) return {min: 2, max: 3};
      if (N <= 7) return {min: 3, max: 4};
      if (N <= 12) return {min: 3, max: 6};
      if (N <= 20) return {min: 4, max: 7};
      return {min: 4, max: 8};
    })();

    const minCols = clampInt(getDataNumber(root.dataset, ['mincols'], autoCols.min), 1, 99);
    const maxCols = clampInt(getDataNumber(root.dataset, ['maxcols'], autoCols.max), 1, 99);
    const hgap = clampNonNeg(getDataNumber(root.dataset, ['hgap','hGap'], defGap));
    const vgap = clampNonNeg(getDataNumber(root.dataset, ['vgap','vGap'], defGap));
    // Dynamic minUtil threshold based on collection size
    let effMinUtil = minUtil;
    if (imgsCount > 30) effMinUtil = Math.max(effMinUtil, 0.94);
    else if (imgsCount > 16) effMinUtil = Math.max(effMinUtil, 0.92);

    const imgs = Array.from(root.querySelectorAll('img'));
    const tiles = ensureTiles(root, imgs);
    if (!imgs.length || W <= 0 || H <= 0) return;

    const aspects = imgs.map(img => {
      let a = hasNumber(img.dataset.aspect) ? +img.dataset.aspect : NaN;
      if (!(a > 0)) {
        const w = img.naturalWidth || 0, h = img.naturalHeight || 0;
        a = (w > 0 && h > 0) ? (w / h) : 4 / 3;
        try { img.dataset.aspect = String(a); } catch (_) {}
      }
      return a;
    });

    // Small set visual rules for N ≤ 4
    const Nsmall = aspects.length;
    if (Nsmall <= 4) {
      const positionsSmall = buildSmallSetPositions(aspects, W, H, hgap, vgap);
      place(root, tiles, imgs, positionsSmall);
      const variant = positionsSmall && positionsSmall._tag;
      log('[SmallSet] layout used', { N: Nsmall, variant: variant || 'default' });
      return;
    }
  
    if (flow === 'col' || flow === 'column' || flow === 'bycol' || flow === 'auto') {
      log('[ColumnNoCrop] === Begin layout ===');
      const best = solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols, minImgH);
      if (best) {
        const positions = buildColumnPositions(best, W, H, hgap, vgap);
        const used = positions.reduce((s, p) => s + p.width * p.height, 0);
        const util = used / (W * H);
        log('[ColumnNoCrop] Utilization', (util * 100).toFixed(2) + '%');

        // If column-mode utilization is too low → automatically switch to row mode to fill empty space
        if (util >= effMinUtil) {
          place(root, tiles, imgs, positions);
          log('[ColumnNoCrop] === Layout complete ===');
          return;
        } else {
          log('[ColumnNoCrop] Utilization below threshold, falling back to BalancedNoCrop', {minUtil: effMinUtil});
        }
      } else {
        // If no feasible solution, fallback to row mode
        log('[ColumnNoCrop] No feasible solution, falling back to BalancedNoCrop');
      }
    }

    // Row fallback / or flow=row
    log('[BalancedNoCrop] === Begin layout ===');
    const style = (root.dataset.style || '').toLowerCase();
    let jitter = getDataNumber(root.dataset, ['jitter'], NaN);
    let pboost = getDataNumber(root.dataset, ['portraitboost'], NaN);

    // Auto mosaic decision when style is not specified
    let mosaicAuto = false;
    if (!style) {
      const aMin = Math.min(...aspects);
      const aMax = Math.max(...aspects);
      const variety = aMax / Math.max(1e-6, aMin);
      const portraitShare = aspects.filter(a => a < 1).length / aspects.length;
      mosaicAuto = variety > 2.0 || portraitShare > 0.30;
    }
    const useMosaic = (style === 'mosaic') || mosaicAuto || (hasNumber(jitter) && jitter > 0);

    // Defaults when not provided
    if (!hasNumber(jitter)) jitter = useMosaic ? 0.12 : 0;
    if (!hasNumber(pboost)) pboost = useMosaic ? 0.15 : 0;

    const opts = { mosaic: useMosaic, jitter: clampRange(jitter, 0, 1), pboost: clampRange(pboost, 0, 1), align: 'center' };
    const sol = solveBalancedNoCrop(aspects, W, H, hgap, vgap, opts);
    if (sol) {
      place(root, tiles, imgs, sol.pos);
      log('[BalancedNoCrop] Utilization', (sol.util * 100).toFixed(2) + '%');
      log('[BalancedNoCrop] === Layout complete ===');
    }
  }

  // ---------- Init ----------
  async function init(selector = '.' + CLASS) {
    // Hide debug panel unless explicitly enabled
    const dbg = document.getElementById('debugInfo');
    if (dbg && !DEBUG_ENABLED) { dbg.style.display = 'none'; }

    const boxes = Array.from(document.querySelectorAll(selector));
    const roList = [];
    for (const root of boxes) {
      const imgs = Array.from(root.querySelectorAll('img'));
      await Promise.all(imgs.map(preload));
      await raf2();
      layoutBox(root);
      const debouncedLayout = debounce(() => layoutBox(root), 80);
      const ro = new ResizeObserver(debouncedLayout);
      ro.observe(root);
      roList.push(ro);
    }
    window.CollageModes = {
      relayout() { boxes.forEach(layoutBox); },
      disconnect() { roList.forEach(ro => ro.disconnect()); }
    };

    // Auto cleanup observers on page lifecycle end
    try {
      window.addEventListener('pagehide', () => {
        try { window.CollageModes && window.CollageModes.disconnect(); } catch(_) {}
      }, { once: true });
      window.addEventListener('beforeunload', () => {
        try { window.CollageModes && window.CollageModes.disconnect(); } catch(_) {}
      }, { once: true });
    } catch(_) {}

  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => init());
  } else {
    init();
  }
})();
</script>

</body>
</html>
