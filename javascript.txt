JavaScript for Frontend Web Development: A Complete Learning Path (Beginner to Advanced)
Table of Contents
Introduction
Getting Started: Running JavaScript in a Browser
Variables and Data Types
Operators and Expressions
Control Flow (Conditionals and Loops)
Functions
6.1. Arrow Functions
Arrays
Objects
DOM Manipulation (Interacting with the Web Page)
Event Handling
Working with Forms
Asynchronous JavaScript
12.1. Callbacks
12.2. Promises
12.3. Async/Await
Modern JavaScript (ES6+) Features
13.1. Block-Scoped Variables (let & const)
13.2. Template Literals
13.3. Destructuring and Spread/Rest
13.4. Classes (ES6 Classes)
Modules in JavaScript
Closures
The this Keyword
Prototypes and Inheritance
Performance Tips
Best Practices
Conclusion

1. Introduction
Welcome to the JavaScript Frontend Web Development learning path! This comprehensive guide will take you from a beginner with no knowledge of JavaScript to an advanced user capable of building interactive web pages with vanilla JavaScript (meaning we will not use frameworks or libraries, just plain JavaScript). JavaScript is the programming language of the web, enabling dynamic and interactive content in web pages. Whether you want to create image sliders, form validations, or entire web applications, mastering JavaScript is key.
In this learning path, we'll start with the very basics: understanding how to include and run JavaScript in a web page. We'll then move through fundamental programming concepts (variables, data types, functions, control flow, etc.), gradually introducing more complex topics (working with the DOM, handling user events, forms, asynchronous operations). By the end, we'll cover advanced concepts like closures, the prototype chain, and performance optimization tips. We'll also touch on modern JavaScript features (ES6 and beyond) and how to organize code using modules.
How to Use This Guide: It's structured in a logical sequence – each section builds on the previous ones. You'll find step-by-step explanations, annotated code examples, and exercises/mini-projects to practice what you've learned. The tone is beginner-friendly, so don't worry if some terms sound unfamiliar – everything will be explained in simple language. By following along and coding as you go, you'll gain hands-on experience.
Before we dive in, remember: practice is crucial. Try out the examples, attempt the exercises, and play with the code. JavaScript is best learned by doing. You can experiment in your browser's developer console or by writing HTML files and including your scripts – we'll show you how in the next section.
Alright, let's get started on your journey to mastering JavaScript for interactive web development!
2. Getting Started: Running JavaScript in a Browser
To begin writing and testing JavaScript, you don't need any special software – a web browser and a simple text editor will do. There are two common ways to run JavaScript in a browser:
Using the Browser Console: All modern browsers have a JavaScript console. You can open it (for example, in Chrome press F12 or right-click → "Inspect" and find the Console tab). In the console, you can type JavaScript commands and see immediate results. This is great for quick experiments or debugging.
Including JavaScript in an HTML File: Typically, you'll write JavaScript in a <script> tag within an HTML file, or in a separate .js file that you include via a <script src="..."> tag. The browser executes the JavaScript when the HTML page is loaded.
Let's try a quick example by creating a simple HTML file that runs a JavaScript "Hello, World":
<!DOCTYPE html>
<html>
<head>
  <title>JS Test</title>
</head>
<body>

<h1 id="greeting">Hello</h1>

<!-- Include a script directly in HTML -->
<script>
  // This code runs when the page loads
  console.log("Hello from JavaScript!");  // This will print to the browser console
  document.getElementById("greeting").textContent = "Hello, World!";
  // The line above finds the <h1> element and changes its text content.
  alert("JavaScript is working!");  // This will pop up an alert in the browser
</script>

</body>
</html>
Save this as test.html and open it in a browser. You should see the heading text on the page change to "Hello, World!" and an alert message pop up, while "Hello from JavaScript!" is logged to the console. This demonstrates three things: - Using console.log() to output to the browser's console (useful for debugging). - Manipulating the page content via the DOM (we'll explain this more later). - Using alert() to show a message box (a simple way to output text to the user).
External JS Files: For larger scripts, it's often better to keep JavaScript in its own file. Create a file app.js and move your script code there. In the HTML, replace the script content with a src attribute:
<script src="app.js"></script>
This tells the browser to load and run the code from app.js. Make sure the script tag is placed at the end of the body or use the defer attribute in the <script> tag. Placing it at the end ensures the HTML elements are loaded before your script runs (so getElementById("greeting") finds the element). Alternatively, you can add the attribute defer to the script tag to achieve a similar effect (scripts with defer wait to execute until the HTML document is fully parsed).
Note: For now, we'll stick to writing scripts that run after the page loads. As you progress, you'll learn better techniques to structure and load scripts (like modules and the defer/async attributes for performance).
With our environment set up, let's start learning the fundamentals of the JavaScript language.
3. Variables and Data Types
Variables are used to store data values that can change (or vary) during the execution of your program. You can picture variables as containers or labeled boxes in memory that hold information. In JavaScript, you can create (declare) a variable using the keywords let, const, or (traditionally) var. In modern JavaScript, we prefer let and const for variable declarations, as they provide better scoping rules and help prevent certain bugs.
Declaring Variables
Use let for variables that you plan to change (their values will vary).
Use const for variables that you want to fix to a value (constant) and not reassign. This is great for values that shouldn't change, like configuration values or references to DOM elements.
Avoid using var in new code. var is the old way of declaring variables and has function-scoped (or global) behavior that can be confusing. let and const are block-scoped and generally safer.
Example of declaring variables:
let userName;            // declare a variable (initialized as undefined by default)
userName = "Alice";      // assign a value to the variable
console.log(userName);   // outputs "Alice"

let age = 25;            // declare and assign in one step
age = 26;                // reassign a new value
console.log(age);        // outputs 26

const birthYear = 1995;  // declare a constant
// birthYear = 1996;     // ERROR: cannot reassign a const variable
In the above snippet: - userName is declared then later assigned the string "Alice". - age is declared with initial value 25, then changed to 26. - birthYear is a constant and cannot be reassigned after the initial assignment.
Variable Naming Rules: You can name variables with letters, digits, $ or _, but the name cannot start with a digit. Names are case-sensitive (myVar vs myvar are different). It's good practice to use descriptive names (e.g., firstName instead of x) so your code is easier to understand. You should also avoid using JavaScript reserved words (like if, for, let, etc.) as variable names.
Data Types in JavaScript
JavaScript is a dynamically typed language, meaning a variable can hold any type of data and can even change type later. The main data types in JavaScript are:
Number: Used for all numerical values (integers, floats, etc.). Example: let count = 42;, let price = 19.99;. JavaScript does not differentiate between integer and floating-point – it's all just "Number". There are also special numeric values like Infinity, -Infinity, and NaN ("Not a Number", which is a result of invalid math operations).
String: Textual data enclosed in quotes (single '...' or double "..." quotes, or backticks `...` for template literals, which we'll cover later). Example: let city = "Singapore";.
Boolean: Logical true/false values. Example: let isLoggedIn = false; (only two boolean values: true and false).
Null: A special value meaning "no value". You can set a variable to null to indicate that it is intentionally empty or not set.
Undefined: This value means a variable has been declared but not assigned a value, or a function with no return returns undefined. By default, if you do let x; without assigning, x is undefined.
Object: A complex data type used to store collections of data or more complex entities. Objects can hold many values as properties. (We'll explore objects in detail later.)
Symbol: A unique and immutable value often used as an identifier (advanced use, we won't need it in basic sections).
BigInt: A numeric type for integers beyond the safe range of the Number type (useful for very large integers, introduced in ES2020). This is an advanced feature, so just be aware it exists.
For now, focus on Number, String, Boolean, Null, Undefined, and simple Objects/Arrays. These will cover the majority of use cases as you begin.
Examples of Data Types:
let score = 100;             // Number
let price = 49.99;           // Number (can be decimal)
let name = "Charlie";        // String (using double quotes)
let message = 'Hi there!';   // String (using single quotes)
let isOpen = true;           // Boolean
let notSet = null;           // Null (explicitly no value)
let x;                       // Undefined (declared but not assigned)
console.log(x);              // outputs undefined
You can use the typeof operator to check the type of a value or variable:
console.log(typeof score);    // "number"
console.log(typeof name);     // "string"
console.log(typeof isOpen);   // "boolean"
console.log(typeof notSet);   // "object"  (quirk: typeof null returns "object" due to a historical bug in JS)
console.log(typeof x);        // "undefined"
A Note on Dynamic Typing
Because variables can change type, you must be careful with operations that might produce unexpected results. For example:
let data = "5";
console.log(typeof data);  // "string"
data = 5;
console.log(typeof data);  // "number"
JavaScript will also sometimes convert types implicitly when combining values:
let result = 5 + "7";      // "57" (number 5 becomes string "5" and concatenates with "7")
result = "5" * "3";        // 15 (strings "5" and "3" are converted to numbers for multiplication)
Generally, be mindful when mixing types. We'll cover more on operators and type conversion next.
Exercise: Variables and Types
1. Create a variable to store your name and another for your age. Print a greeting using both (for example: "Hello, my name is Alice and I am 25 years old.").
2. What happens if you add a number and a string in JavaScript? Try console.log(10 + "5"); and see the result and type. Can you explain why it happened?
3. Declare a variable with let without initializing it, log its value, then assign a value and log it again to observe the change.
4. Operators and Expressions
Operators are symbols or keywords that perform operations on values (operands). An expression is a combination of values, variables, and operators that computes to a value. JavaScript supports various types of operators:
Arithmetic Operators
Used for mathematical calculations: - + (addition): Adds numbers or concatenates strings. - - (subtraction) - * (multiplication) - / (division) - % (modulus): Remainder of division. For example, 7 % 3 is 1 (because 7 divided by 3 leaves remainder 1). - ** (exponentiation): For example, 2 ** 3 is 8 (2 to the power of 3).
Examples:
let a = 10;
let b = 3;
console.log(a + b);   // 13
console.log(a - b);   // 7
console.log(a * b);   // 30
console.log(a / b);   // 3.333...
console.log(a % b);   // 1
console.log(2 ** 4);  // 16 (2 to the power of 4)
String concatenation: The + operator also concatenates (joins) strings:
let firstName = "John";
let lastName = "Doe";
let fullName = firstName + " " + lastName;
console.log(fullName);  // "John Doe"
Be cautious: if one operand is a string, the + will convert the other to string (as we saw "5" + 7 became "57"). For numeric addition, ensure both operands are numbers or convert them explicitly.
Assignment Operators
Used to assign values to variables. The simple assignment is =. There are also compound assignment operators for convenience: - +=: Add and assign. (x += 5; is equivalent to x = x + 5;) - -=: Subtract and assign. - *= , /=, %=, **= similarly perform the operation and reassign.
Example:
let x = 10;
x += 5;  // now x is 15 (same as x = x + 5)
x *= 2;  // now x is 30 (same as x = x * 2)
Comparison Operators
Used to compare two values, yielding a Boolean (true or false): - == (equality) and != (inequality) – not recommended, because they perform type coercion before comparison. - === (strict equality) and !== (strict inequality) – check if values are equal (or not equal) without converting types[1]. Use these in practice to avoid unexpected results. For example, 5 == "5" is true (because "5" is converted to 5) but 5 === "5" is false (different types)[2]. - < (less than), > (greater than), <= (less or equal), >= (greater or equal).
Examples:
console.log(5 == "5");    // true (not strict, types differ but value coerced)
console.log(5 === "5");   // false (strict, different types)[2]
console.log(10 != "10");  // false (they are considered equal after coercion)
console.log(10 !== "10"); // true (10 is not equal to "10" when types considered)
console.log(7 < 3);       // false
console.log(7 > 3);       // true
console.log(5 <= 5);      // true
console.log(8 >= 10);     // false
Logical Operators
Operate on Boolean values (and expressions that result in booleans): - && (AND): a && b is true if both a and b are true. - || (OR): a || b is true if either a or b is true. - ! (NOT): !a is true if a is false (it inverts the boolean value).
These are useful for combining conditions (we'll see them in the next section with if-statements). They also have a property of short-circuiting: in a && b, if a is false, b is not evaluated (because the whole expression can't possibly be true). In a || b, if a is true, b is not evaluated (since it's already true regardless of b).
Example:
let n = 7;
console.log(n > 0 && n < 10);  // true (n is between 0 and 10)
console.log(n % 2 === 0 || n % 5 === 0);  // false (n is not divisible by 2 or 5)
console.log(!(n === 7));  // false (n === 7 is true, !true is false)
Other Operators
Unary + and -: + can convert a value to a number (e.g., +"5" becomes 5), and - negates a number or can convert to number and negate (e.g., - "3" becomes -3).
++ / --: Increment or decrement. i++ increases i by 1 (returns the old value), ++i increases and returns the new value. Similarly for --.
let i = 0;
i++;
console.log(i);  // 1
++i;
console.log(i);  // 2
console.log(i--); // prints 2 (then i becomes 1)
console.log(--i); // i becomes 0, then prints 0
Use these with care to avoid confusion; you can always use i += 1 instead of i++ if preferred.
Ternary operator: A shorthand for if. Syntax: condition ? value_if_true : value_if_false. It evaluates the condition, and returns one of two values depending on the result.
let max = (a > b) ? a : b;  // if a > b, max = a, else max = b
Comma operator (,): Rarely used, allows multiple expressions where one is expected. It evaluates each operand (left to right) and returns the value of the last one. You likely won't need this as a beginner, and it can be confusing, so we won't focus on it.
Expressions: Whenever you use operators with values or variables, you form expressions. For example, 3 * (x + 2) is an expression that will be evaluated to some value depending on x. You can assign the result of an expression to a variable:
let result = 3 * (x + 2);
This computes the expression on the right and stores it in result.
Order of Operations: JavaScript follows typical operator precedence (similar to math). Multiplication and division happen before addition and subtraction, etc. You can always use parentheses ( ) to make the order explicit and ensure the intended calculation.
Exercise: Operators
1. Create two variables a and b with numeric values. Compute their sum, difference, product, and quotient, and log the results.
2. Use a comparison operator to check if a is greater than b and log the boolean result. Then check if they are equal using strict equality.
3. Try out the modulus operator: given an integer, determine if it's even or odd by checking number % 2. (Hint: if the remainder is 0, it's even.)
4. Write a small snippet using a ternary operator: For example, let access = (age >= 18) ? "Granted" : "Denied"; and test it with different age values.
5. Control Flow (Conditionals and Loops)
In programming, control flow refers to the order in which statements are executed and the ability to make decisions (branching) or repeat actions (loops). JavaScript provides several structures to control flow: if/else for branching, and various loops for repetition.
Conditional Statements: if, else if, else
The if statement allows you to execute code only if a certain condition is true. Optionally, you can include an else part to execute code when the condition is false.
Syntax:
if (condition) {
   // code to run if condition is true
} else if (otherCondition) {
   // (optional) code if the first condition was false, but another condition is true
} else {
   // (optional) code if none of the above conditions are true
}
The condition is an expression that is evaluated to a boolean (true/false). If it's true, the following block executes; if false, it skips to the next condition or else.
Example:
let temperature = 30;
if (temperature > 35) {
  console.log("It's really hot outside!");
} else if (temperature > 25) {
  console.log("It's warm outside.");
} else {
  console.log("It's cool or cold outside.");
}
In this example, if temperature is 30, the first condition (>35) is false, so it checks the else if: 30 > 25 is true, so it prints "It's warm outside." and then skips the else. If temperature were 40, it would print the first message; if it were 20, it would skip both if and else-if and run the else block.
Any expression can be a condition; JavaScript will convert it to boolean using its truthiness rules. Commonly, we compare values or call functions that return boolean. Remember to use strict comparisons (===, !==) for clarity and correctness when comparing values.
Truthy and Falsy Values
JavaScript has the concept of "truthy" and "falsy" values. In a boolean context (like an if condition), the following values are considered falsy: false, 0, "" (empty string), null, undefined, and NaN. Everything else is truthy. For example:
if ("hello") { console.log("This runs"); }      // "hello" is truthy (non-empty string)
if (0) { console.log("This will NOT run"); }    // 0 is falsy
Be careful relying on this implicit conversion; it's often clearer to explicitly compare (if (str !== "") instead of if (str), for instance).
The switch Statement
For multiple possible values of a variable, a switch can sometimes be cleaner than many else ifs. A switch checks a value against multiple case patterns:
let day = 3;
switch (day) {
  case 1:
    console.log("Monday");
    break;
  case 2:
    console.log("Tuesday");
    break;
  case 3:
    console.log("Wednesday");
    break;
  default:
    console.log("Unknown day");
}
Here, day is matched against the cases. Since day is 3, it will print "Wednesday". The break is important: without it, execution would continue into the next cases. The default case runs if none of the cases match. It's good practice to always include a default case to handle unexpected values (even if just for debugging)[3][4].
Loops
Loops allow repeating a block of code multiple times. JavaScript offers a few kinds of loops:
for loop: Ideal for running code a specific number of times or iterating over sequences.
while loop: Repeats as long as a condition remains true.
do...while loop: Similar to while, but ensures the loop runs at least once (condition is checked after one iteration).
for...of loop: A newer loop for iterating over iterable objects like arrays (we'll see in the array section).
for...in loop: Used for iterating over object properties (used less frequently, careful as it iterates enumerable properties including prototypes potentially).
for Loop
Syntax:
for (initialization; condition; finalExpression) {
   // code to run each loop iteration
}
- initialization: executed once at the start (e.g., let i = 0). - condition: checked before each iteration; loop runs while true. - finalExpression: executed at end of each iteration (e.g., i++ to increment a counter).
Example:
for (let i = 1; i <= 5; i++) {
  console.log("Counting: " + i);
}
This will print numbers 1 through 5. i starts at 1, and as long as i <= 5 is true, it runs the loop and then increments i by 1 each time.
while Loop
Executes as long as the condition remains true:
let j = 1;
while (j <= 5) {
  console.log("Counting: " + j);
  j++;
}
This will do the same as the for loop above. Be careful: if the condition never becomes false, you'll create an infinite loop. Always ensure something in the loop eventually makes the condition false (like incrementing j here).
do...while Loop
Runs the loop block once, then checks the condition:
let k = 1;
do {
  console.log("Counting: " + k);
  k++;
} while (k <= 5);
This will also print 1 to 5. The difference is that the condition is checked after the loop body, meaning the loop runs at least one time regardless of the condition initially.
Breaking out of Loops and Continuing
break: You can use break inside any loop (or switch) to exit immediately out of it. This is useful if you found what you were looking for and don't need to continue, for example.
continue: Skips the rest of the current loop iteration and moves to the next one.
Example:
for (let i = 1; i <= 10; i++) {
  if (i === 3) {
    continue;  // skip number 3
  }
  if (i === 7) {
    break;     // stop loop entirely when i is 7
  }
  console.log(i);
}
// This will print 1, 2, 4, 5, 6 and then stop.
Use these when needed to control loop flow. For instance, break is often used to exit early once a condition is met, which is also a performance optimization (no need to loop further)[5].
Looping over Arrays (intro)
We will discuss arrays in the next section, but a common pattern is:
let fruits = ["apple", "banana", "cherry"];
for (let index = 0; index < fruits.length; index++) {
  console.log(fruits[index]);
}
This iterates over the array by index. A more modern way is:
for (let fruit of fruits) {
  console.log(fruit);
}
The for...of loop directly gives you each element in the array without needing an index.
We will revisit loop techniques with arrays soon.
Exercise: Control Flow
1. Write an if...else statement that checks a variable score. If score is 90 or above, log "Grade: A"; if 80-89, log "Grade: B"; if 70-79, "Grade: C"; if 60-69, "Grade: D"; otherwise "Grade: F". (Try changing the score value to test each branch.)
2. Create a variable num. If it's positive, print "Positive", if it's negative print "Negative", and if it's zero print "Zero". Use an if, else if, else chain.
3. Use a for loop to calculate the sum of numbers from 1 to 100. (Hint: have a variable total initialized to 0, and loop i from 1 to 100, adding i to total each time. After the loop, total should be 5050.)
4. Use a while loop to find the first power of 2 greater than 1000. (In other words, multiply by 2 until the value exceeds 1000, then stop and print the value.)
5. Challenge: Create a simple "guess the number" routine. Choose a secret number (say 7). Use a loop to simulate guesses (either predetermined or random). For each guess, print "Too high", "Too low", or "Correct" and break out on correct. (This is just a thought exercise; in a real program, you'd get user input, but we haven't covered that yet.)
6. Functions
Functions are one of the most important concepts in JavaScript (and programming in general). A function is a reusable block of code designed to perform a particular task. You can define a function, then "call" it (execute it) multiple times with different inputs, rather than writing the same code over and over. Functions help organize code into logical pieces, avoid repetition, and make code more modular and readable.
Defining a Function (Function Declaration)
The basic syntax to declare a function is:
function functionName(parameter1, parameter2, ...) {
   // code to be executed when the function is called
   // optional: return some value
}
- functionName: the name you give to the function (like a variable, follows similar naming rules). - parameters: placeholders for values that will be passed into the function. - Inside the braces {}, you write the code that runs when the function is called. - A function can optionally use a return statement to send back a result. When return is executed, the function stops and returns that value to the caller.
Example:
function greet(name) {
  console.log("Hello, " + name + "!");
}
This function greet takes one parameter, name, and logs a greeting. It doesn't return a value (so it implicitly returns undefined).
To use (call) the function:
greet("Alice");   // prints "Hello, Alice!"
greet("Bob");     // prints "Hello, Bob!"
Each call executes the function body with the given argument in place of the parameter.
Let's look at a function that returns a value:
function add(x, y) {
  return x + y;    // returns the sum of x and y
}

let result = add(2, 3);
console.log(result);  // 5
console.log(add(10, 5));  // 15 (directly log the returned value)
The add function computes x + y and returns it. We can capture that result in a variable or use it directly.
Important: Code after a return in a function will not execute, as the function exits immediately on return.
Functions can access variables defined outside of them (this is called lexical scope), but it's generally best to rely on parameters and return values for input and output to keep functions self-contained and reusable.
Function Expressions
In JavaScript, functions are first-class citizens; you can treat them like any other value. A function expression is when you define a function and assign it to a variable:
let sayHi = function(name) {
  console.log("Hi, " + name);
};
sayHi("Charlie");  // "Hi, Charlie"
Here we created an anonymous function (no name after the function keyword) and assigned it to sayHi. We then call it via the variable. Function expressions are useful for passing functions as arguments to other functions, or for closures (more on that later).
There's also a concept of Immediately Invoked Function Expressions (IIFE) where a function is defined and called right away, but you won't need that immediately, and it's less common in modern code due to modules.
Arrow Functions (ES6)
Arrow functions are a shorter syntax for writing function expressions and also have some different behavior with this (which we'll discuss separately). An arrow function looks like:
const multiply = (a, b) => {
  return a * b;
};
This defines a function multiply that returns the product of a and b. For a simple one-liner, you can even omit the {} and return:
const multiplyShort = (a, b) => a * b;
If there's only one parameter, you can omit parentheses around it: n => n * 2 is a function that doubles a number. If there are no parameters, use () => ....
Arrow functions are often used for callbacks or short functions. They have the benefit of being more concise. However, they do not have their own this context (they inherit this from the surrounding lexical scope)[6], and they cannot be used as constructors. For regular usage where you don't need the special behaviors of a normal function, arrow functions are great for brevity.
We'll use arrow functions in some examples (especially in later sections like asynchronous code), but it's important to understand both forms.
Parameters and Arguments
You can define functions with multiple parameters, or none at all. If a function is called with fewer arguments than parameters, the missing parameters will be undefined inside the function. If it's called with more arguments, the extra arguments can be accessed via the arguments object in a normal function (or simply ignored, or handled via rest parameters which we'll cover later).
Example:
function describePerson(name, city) {
  console.log(name + " lives in " + city);
}
describePerson("Alice", "Paris");             // "Alice lives in Paris"
describePerson("Bob");                        // "Bob lives in undefined" (city was not provided)
describePerson("Charlie", "London", 25);      // "Charlie lives in London" (25 is extra, not used)
To handle default values, you can check inside the function or use ES6 default parameters:
function describePerson(name, city = "an unknown place") {
  console.log(name + " lives in " + city);
}
describePerson("Bob");  // "Bob lives in an unknown place"
Default parameters are a nice feature that assigns a default if an argument is missing or undefined.
Scope and Local Variables
Variables declared inside a function (using let or const or var) are local to that function. You cannot access them from outside. Conversely, a function has access to variables in outer scopes (this is a closure feature, which we'll elaborate on later). Generally, using local variables inside functions and passing things in/out via parameters and return values is the best practice.
Functions as Values
Since functions are values, you can pass them to other functions or return them from functions. For example:
function callTwice(func) {
  func();
  func();
}
function laugh() {
  console.log("Haha!");
}
callTwice(laugh);  // will print "Haha!" twice
We passed the function laugh as an argument to callTwice. This is powerful and allows callback patterns, event handling, etc., which you'll see a lot in JavaScript.
We will later see how functions can be used to handle events, timers, and more.
Exercise: Functions
1. Write a function square(num) that returns the square of a number (num * num). Test it with a few values (e.g., square(4) should return 16).
2. Write a function isEven(number) that returns true if the number is even, and false otherwise. Use the % operator to test evenness. Try it on a few numbers.
3. Create a function toCelcius(fahrenheit) that converts Fahrenheit to Celsius. Formula: C = (F - 32) * 5/9. Then create toFahrenheit(celcius) to do the reverse. Test with known values (e.g., 32°F = 0°C, 100°C = 212°F).
4. Write a function max(a, b, c) that returns the largest of three numbers a, b, c. (Hint: you can use a series of if/else or use Math.max in a smart way, but try the logic yourself.)
5. (Advanced) Write a function countChars(str, char) that counts how many times a given character char appears in the string str. For example, countChars("Hello", "l") should return 2. (Hint: loop through the string or use string methods. This will make use of concepts from loops and conditionals as well.)
6.1 Arrow Functions (More Examples)
To reinforce arrow functions: let's convert a couple of the above functions to arrow syntax:
const square = num => num * num;
console.log(square(5)); // 25

const isEven = number => number % 2 === 0;
console.log(isEven(10)); // true
console.log(isEven(7));  // false
If an arrow function needs multiple statements or you want to use a return, you use the {} block:
const maxOfTwo = (a, b) => {
  if (a > b) return a;
  return b;
};
console.log(maxOfTwo(3, 7)); // 7
This arrow function has a couple of statements, so we wrapped them in braces and explicitly returned a value.
Remember, arrow functions inherit their surrounding this value and cannot be used as constructors (you cannot do new myArrowFunction()), but for most purposes (especially for short callback functions), they are extremely convenient.
Next, we'll move to data structures like arrays and objects to handle collections of values.
7. Arrays
An array is a type of object in JavaScript that is used to store a list of values. Arrays are ordered, zero-indexed collections – meaning each item has an index starting from 0 (first item is index 0, second is index 1, etc.). Arrays are great for storing sequences of data (e.g., lists of names, numbers, etc.) and iterating over them.
Creating and Using Arrays
You can create an array using square brackets []:
let fruits = ["Apple", "Banana", "Cherry"];
Here we have an array with 3 string elements. Arrays can hold any type, and you can mix types (though usually they hold a consistent type of elements):
let mixed = [42, "hello", true, null];
This array has a number, a string, a boolean, and a null.
Accessing elements: Use bracket notation with the index:
console.log(fruits[0]);  // "Apple"
console.log(fruits[2]);  // "Cherry"
If you use an index that doesn't exist (e.g., fruits[5] in our case), you'll get undefined.
Modifying elements: You can reassign values at specific indices:
fruits[1] = "Blueberry";
console.log(fruits);  // ["Apple", "Blueberry", "Cherry"]
Array length: Every array has a length property indicating the number of elements:
console.log(fruits.length);  // 3
Be careful: last valid index is length - 1 (since index starts at 0). If an array is empty, length is 0.
Common Array Operations (Methods)
JavaScript arrays come with many built-in methods to manipulate them. Here are essential ones:
push(item) – add an item to the end of the array. Returns the new length.
pop() – remove the last item from the array and return it.
unshift(item) – add an item to the beginning of the array.
shift() – remove the first item from the array and return it.
indexOf(item) – search for an item and return its index (or -1 if not found).
includes(item) – returns true if the item is present in the array.
slice(start, end) – returns a new array with a copy of a portion of the array (does not modify original). start index is inclusive, end is exclusive.
splice(start, deleteCount, ...items) – powerful method to remove or insert elements. It modifies the original array. For example, arr.splice(2, 1) removes 1 element at index 2. arr.splice(1, 0, "x") inserts "x" at index 1 without removing any (second parameter 0).
join(separator) – join all elements into a string with separator between.
reverse() – reverse the array in place.
sort() – sort the array (by default, lexicographically as strings; you can pass a comparison function for numeric or custom sorts).
Let's see some in action:
let nums = [10, 20, 30];
nums.push(40);
console.log(nums);        // [10, 20, 30, 40]
let last = nums.pop();
console.log(last);        // 40 (removed element)
console.log(nums);        // [10, 20, 30]

nums.unshift(5);
console.log(nums);        // [5, 10, 20, 30]
let first = nums.shift();
console.log(first);       // 5
console.log(nums);        // [10, 20, 30]

console.log(nums.indexOf(20));   // 1 (20 is at index 1)
console.log(nums.includes(20));  // true
console.log(nums.includes(40));  // false

let sub = nums.slice(1, 3);
console.log(sub);         // [20, 30] (elements from index 1 up to 3, not including 3)
console.log(nums);        // [10, 20, 30] (original unchanged)

nums.splice(1, 1, 15, 17);
// At index 1, remove 1 element (the 20), and insert 15 and 17 in its place
console.log(nums);        // [10, 15, 17, 30]

console.log(nums.join(", "));    // "10, 15, 17, 30"

nums.reverse();
console.log(nums);        // [30, 17, 15, 10] (array is now reversed)
nums.sort();
console.log(nums);        // [10, 15, 17, 30] (sorted as numbers; actually sort as strings by default but these are fine)
A note on sort(): By default, sort converts elements to strings and compares lexicographically (dictionary order). For example, [2, 30, 100].sort() yields [100, 2, 30] as strings! To sort numbers properly, you pass a compare function:
let arr = [2, 30, 100];
arr.sort((a, b) => a - b);
console.log(arr);  // [2, 30, 100] (now correct numerically)
We sort ascending by subtracting (if a-b is negative, a comes first, etc.).
Iterating Over Arrays
We often use loops to go through array elements:
let cars = ["Toyota", "Honda", "Tesla"];
for (let i = 0; i < cars.length; i++) {
  console.log(cars[i]);
}
This prints each car brand. As mentioned earlier, we can use a for...of loop for convenience:
for (let car of cars) {
  console.log(car);
}
This does the same without needing an index.
There are also array iteration methods like forEach, map, filter, etc., which are very useful: - array.forEach(function(element, index) { ... }) – calls the function for each element (doesn't return anything). - array.map(func) – creates a new array by applying func to each element. - array.filter(func) – creates a new array with only elements where func returns true. - array.find(func) – finds the first element where func returns true (for example, find an object in array by some property). - array.reduce(func, initialValue) – reduces the array to a single value (like summing all elements, etc.).
These are more advanced functional programming techniques. For now, knowing how to loop and basic push/pop operations is enough. But as a quick peek:
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(n => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

let evens = numbers.filter(n => n % 2 === 0);
console.log(evens);    // [2, 4]

let sum = numbers.reduce((acc, curr) => acc + curr, 0);
console.log(sum);      // 15 (adds all numbers, starting from 0)
We'll not dwell on these now, but it's good to be aware that such methods exist.
Array and String relationship
Strings can be thought of as arrays of characters (though they are immutable). You can do some array-like operations on strings: e.g., str.split(",") to split into an array, or array join to make a string. And you can access characters by index: "hello"[1] gives "e". But note, strings are immutable, meaning you cannot change a character by index (you'd have to create a new string).
Exercise: Arrays
1. Create an array of several of your favorite foods. Then:
a. Log the number of items (length).
b. Log the first and last item.
c. Add a new food to the end using push.
d. Remove the first food using shift.
e. Print the modified array.
2. Given an array of numbers, e.g. let values = [8, 3, 12, 5, 22], write code to find the largest number. (Try it with a loop, or sort the array and take the last element).
3. Write a function sumArray(arr) that returns the sum of all numbers in an array. Use a loop to accumulate the sum. Test it on a few arrays.
4. Use an array to store a sequence of numbers 1 to 10, then use a loop to print out only the even numbers from the array.
5. (Advanced) Write a function removeDuplicates(arr) that takes an array and returns a new array with duplicates removed. (Hint: You can use a second array to push items that haven't been seen, or use includes to check before adding. Or more advanced, use a Set, but that might be beyond scope here.)
8. Objects
Objects are the heart of JavaScript. An object in JavaScript is a collection of key-value pairs, where each key (also called a property name) maps to a value. The value can be of any type: primitive (number, string, etc.), another object, a function (in which case it's called a method of the object), and so on. Objects allow you to group related data and functions together, modeling real-world entities and structures.
Creating Objects
The easiest way to create an object is using object literal syntax with curly braces {}:
let person = {
  name: "Alice",
  age: 30,
  city: "Singapore"
};
This defines an object person with three properties: name, age, and city. Each property has a value.
You can also start with an empty object and add properties:
let car = {};
car.brand = "Toyota";
car.model = "Corolla";
car.year = 2010;
But usually literal initialization is cleaner when you know the properties upfront.
Accessing Object Properties
There are two ways to access (read or write) properties: dot notation and bracket notation.
Dot notation: objectName.propertyName
Bracket notation: objectName["propertyName"]
Example:
console.log(person.name);       // "Alice"
console.log(person.age);        // 30

person.age = 31;                // update age
person.country = "Singapore";   // add new property
console.log(person.country);    // "Singapore"
Using bracket notation:
console.log(person["name"]);    // "Alice"
let prop = "city";
console.log(person[prop]);      // "Singapore" (because prop was "city")
Bracket notation is useful when property name is in a variable or not a valid identifier (e.g., has a space or starts with a number, though those are not common cases). Most of the time, you'll use dot notation for standard property names.
If you try to access a property that doesn't exist, you get undefined. You can check for existence using the in operator or by comparing to undefined:
if ("age" in person) {
  console.log("Age is", person.age);
}
if (person.job === undefined) {
  console.log("job is not defined in person.");
}
Methods (Functions on Objects)
Functions can be stored in object properties. When a function is a property of an object, we call it a method of that object. Methods typically perform actions related to that object.
Example:
let calculator = {
  x: 10,
  y: 20,
  add: function() {
    return this.x + this.y;
  }
};
console.log(calculator.add());  // 30
Here calculator.add is a function that uses this.x and this.y. The keyword this inside an object method refers to the object itself (the one that the method was called on)[7]. In the example, inside add, this refers to calculator, so this.x is calculator.x.
We could add another method:
calculator.multiply = function() {
  return this.x * this.y;
};
console.log(calculator.multiply()); // 200
Notice how we define functions: we can use the function keyword or, in shorthand (ES6), define methods without the function keyword:
let person2 = {
  name: "Bob",
  greet() {
    console.log("Hi, I'm " + this.name);
  }
};
person2.greet(); // "Hi, I'm Bob"
This is equivalent to greet: function() { ... } but shorter. Using this.name inside the method accesses the name property of the same object.
We'll discuss this more in the dedicated section, because understanding its behavior is crucial (especially in different contexts and with arrow functions).
Iterating over Object Properties
If you need to inspect all properties of an object, you can use a for...in loop:
for (let key in person) {
  console.log(key + ": " + person[key]);
}
This will print each property name and value in person. However, for...in will also iterate over inherited properties (from the prototype chain). To ensure it's the object's own property, you can use person.hasOwnProperty(key). But for most straightforward uses on plain objects, for...in is fine.
Modern JS also has Object.keys(person) which returns an array of own property names, or Object.entries(person) for an array of [key, value] pairs, and Object.values(person) for values.
Example:
console.log(Object.keys(person));   // ["name", "age", "city", "country"]
console.log(Object.values(person)); // ["Alice", 31, "Singapore", "Singapore"]
Nested Objects and Arrays
Objects can contain other objects or arrays as values, enabling you to model complex data:
let company = {
  name: "TechCorp",
  address: {
    street: "123 Main St",
    city: "Metropolis"
  },
  employees: [
    { name: "Alice", role: "Developer" },
    { name: "Bob", role: "Designer" }
  ]
};
Here, company.address is itself an object with its own properties, and company.employees is an array of objects. You can access nested data like:
console.log(company.address.city);         // "Metropolis"
console.log(company.employees[1].role);    // "Designer"
Understanding how to traverse nested structures is important for working with JSON data or configuration objects, etc.
Object vs Array: When to use what?
Use arrays for ordered collections of items (especially if they are of the same type/kind of thing). Use objects for named properties, representing a concept or entity with various attributes. Sometimes you might use an array of objects (like employees above) to represent multiple entities.
Special Objects: Math, Date, etc.
JavaScript has some built-in objects like Math (with properties and methods for mathematical constants and functions, e.g., Math.PI, Math.max(), Math.random()) and Date for dealing with dates and times. You create a date with new Date(), for example:
let now = new Date();
console.log(now.getFullYear()); // prints the current year
These are beyond just object literal usage, but it's good to know they exist as utility objects.
Exercise: Objects
1. Create an object book with properties: title, author, year. Then:
a. Log the title and author.
b. Add a new property publisher.
c. Change the year property to a new value.
d. Log the updated object.
2. Create an object rectangle with properties width and height. Add a method area that returns the area (width * height). Test the method. Add another method perimeter that returns 2*(width+height). Test it.
3. Write a function printContact(person) that takes a person object (with name and phone properties) and prints something like "Name: Alice, Phone: 123-4567". Try it with a couple of person objects.
4. Make an object counter with a property count (starting at 0) and methods increment() (add 1 to count), decrement() (minus 1), and reset() (set count to 0). Use this.count inside methods to access the current count. Test calling these methods and check counter.count.
5. (Advanced) Nested object challenge: Create an object library that has a property books which is an array of book objects (each book has title, author). Add a method findBook(title) on library that returns the book object with the matching title, or null if not found. Test it by adding a few books to the library and searching for some titles.
9. DOM Manipulation (Interacting with the Web Page)
One of the main things that makes JavaScript powerful in the browser is the ability to interact with the DOM. The DOM (Document Object Model) is a representation of the HTML document as a tree of objects (nodes). Every element in HTML (like paragraphs, buttons, divs, etc.) becomes a node in this tree that JavaScript can access and manipulate. By using JavaScript to alter the DOM, you can change the content, structure, and style of the page on the fly, enabling interactive experiences.
The document Object
The document global object is the entry point for DOM manipulation. It represents the web page loaded in the browser.
Commonly used document methods to select elements: - document.getElementById("id") – Selects a single element with the given id. - document.getElementsByClassName("class") – Selects all elements with the given class (returns an HTMLCollection, which is array-like). - document.getElementsByTagName("tagName") – Selects elements by tag name (e.g., "div", "p"). - document.querySelector(cssSelector) – Selects the first element that matches a CSS selector (e.g., #id, .class, div > p, etc.). - document.querySelectorAll(cssSelector) – Selects all elements that match the CSS selector (returns a NodeList, which can be iterated).
querySelector and querySelectorAll are very powerful because you can use any CSS selector. For example:
let mainTitle = document.getElementById("main-title");
let items = document.getElementsByClassName("item");
let firstParagraph = document.querySelector("p");
let allParas = document.querySelectorAll("p");
let special = document.querySelector(".container > .special");
These assume the HTML has elements corresponding to those selectors.
Manipulating Content and Attributes
Once you have a reference to a DOM element, you can manipulate it. For example, if you selected an element as let elem = document.getElementById("main-title"), you can: - Change its text content: elem.textContent = "New Title";. This sets the textual content inside the element (without HTML). - Change its HTML content: elem.innerHTML = "<span>New</span> Title";. This interprets the string as HTML, so use it carefully (especially with user input to avoid security issues). - Change or read an attribute: e.g., elem.id (to get or set the id), elem.src for an image src, elem.href for a link, or generic elem.getAttribute("attrName") / elem.setAttribute("attrName", value). - Change CSS styles: elem.style.color = "red"; or elem.style.fontSize = "20px"; etc. You can manipulate any CSS property via the style object (in camelCase form). - Change classes: elem.className = "highlight" (sets the class string), or better, use elem.classList which provides methods like add, remove, toggle:
elem.classList.add("active");
elem.classList.remove("hidden");
elem.classList.toggle("open");
- Remove or create elements (see below).
Example:
<h1 id="main-title">Welcome</h1>
<p class="desc">Hello, <span id="name">friend</span>!</p>
let title = document.getElementById("main-title");
title.textContent = "Welcome to My Site";  // update text

let nameSpan = document.getElementById("name");
nameSpan.textContent = "Alice";            // change "friend" to "Alice"

let descPara = document.querySelector(".desc");
descPara.style.color = "blue";             // change text color of the paragraph
descPara.style.fontWeight = "bold";        // make it bold via inline style
Creating and Removing Elements
You can dynamically create new elements and add them to the DOM, or remove existing ones:
Create element: document.createElement("tagName") creates a new element object. E.g., let newDiv = document.createElement("div");.
Set its content or attributes: e.g., newDiv.textContent = "Hello"; or newDiv.id = "section1";.
Append to the DOM: Use a method like parent.appendChild(newElement) or parent.append(...children) to add the element as a child of a parent node. There's also parent.insertBefore(newElem, referenceElem) to insert in a specific position.
Remove an element: If elem is a DOM node, elem.remove() will remove it from its parent. Alternatively, parent.removeChild(child) if older browser support needed.
Example:
// Create a new list item and add to a ul with id "todoList"
let todoList = document.getElementById("todoList");
let newItem = document.createElement("li");
newItem.textContent = "Learn DOM manipulation";
todoList.appendChild(newItem);
This assumes <ul id="todoList"> exists in HTML. Now it will have a new <li> at the end.
To remove:
newItem.remove();  // this will remove the item we just added
Or:
todoList.removeChild(todoList.firstElementChild);  // remove first <li>
DOM Tree Navigation
From a given DOM node, you can navigate: - elem.parentElement – the parent node (element) in the DOM tree. - elem.children – a collection of child elements (ignores text nodes). - elem.firstElementChild, elem.lastElementChild – first and last child element. - elem.nextElementSibling, elem.previousElementSibling – adjacent siblings in the DOM (elements only). - There's also older elem.childNodes (includes text nodes, comments, etc.) but most often children and related are sufficient.
Example:
<ul id="menu">
  <li>Home</li>
  <li id="about">About</li>
  <li>Contact</li>
</ul>
let aboutItem = document.getElementById("about");
console.log(aboutItem.parentElement.id);         // "menu" (the ul)
console.log(aboutItem.previousElementSibling.textContent);  // "Home"
console.log(aboutItem.nextElementSibling.textContent);      // "Contact"
This shows how to traverse relative to an element.
Putting it together – an example mini-project
Let's demonstrate a small dynamic behavior: imagine you have a list of items and a button to add a new item.
<h2>Tasks</h2>
<ul id="tasks">
  <li>Buy groceries</li>
  <li>Call Alice</li>
</ul>
<button id="addTaskBtn">Add Task</button>
Now some JavaScript:
let tasksUl = document.getElementById("tasks");
let addBtn = document.getElementById("addTaskBtn");

addBtn.addEventListener("click", function() {
  // when button is clicked, prompt for a new task and add to list
  let newTask = prompt("Enter a new task:");
  if (newTask) {  // if user entered something (prompt returns null if cancelled)
    let li = document.createElement("li");
    li.textContent = newTask;
    tasksUl.appendChild(li);
  }
});
Here we've introduced the concept of an event listener (we'll cover events in the next section). When the button is clicked, we use prompt() to get input from the user (a simple way to get input; not pretty but works for demonstration). Then if a string was provided, we create a new <li> element, set its text, and append it to the <ul>. This dynamically updates the page with a new list item.
We also see reading user input and altering the DOM accordingly.
Note: prompt() and alert() are basic blocking dialogs. In practice, you might instead have an <input> field or form to get user input for adding tasks. But for quick demos, prompt is fine.
Exercise: DOM Manipulation (These exercises assume you have an HTML document to play with.) 1. Create a simple HTML page with a <div id="box" style="width:100px; height:100px; background:red;"></div> and a button <button id="toggleBtn">Toggle</button>. Using JavaScript, make it so that clicking the button toggles the visibility of the red box (hint: you can toggle a CSS class like "hidden" that sets display: none, or toggle the inline style box.style.display).
2. Add an input field <input id="nameInput" type="text"> and a button <button id="helloBtn">Say Hello</button> to the page. Write JS so that when the button is clicked, it reads the value from the input and then displays a greeting message in a new <p> or in an existing <p id="greetMsg">Hello, [name]!</p>. (If the input is empty, maybe show an error or do nothing.)
3. Make a simple image carousel: have an <img id="photo"> element on the page and two buttons "Next" and "Prev". In JS, have an array of image URLs. When Next is clicked, change the src of the image to the next URL in the array (and wrap around at the end). Similarly for Prev. (This practices changing element attributes and using event listeners, coming up next.)
4. (Advanced) Create a list of items in HTML, e.g., <ul id="list"><li>Item 1</li><li>Item 2</li></ul>. Add a button "Remove Last Item". When clicked, remove the last <li> from the list (if there is one). Also add a button "Add Item", which adds a new <li> with a random or sequential name ("Item 3", "Item 4", etc.). This tests creating and removing DOM nodes.
5. (Advanced) Create a small HTML form: <input type="text" id="todoText"> and <button id="addTodo">Add</button> and an empty <ul id="todoList"></ul>. When the button is clicked, take the text, create a new <li> with that text and add to the list, then clear the input. Also, each added list item could have a "Done" button appended to it that, when clicked, removes that item from the list (hint: use event delegation or attach event when creating the element).
10. Event Handling
Web pages become interactive largely through events. An event is an action or occurrence such as a user clicking a button, typing in a field, moving the mouse, submitting a form, or a page finishing loading. JavaScript can listen for these events and run code (event handlers) in response, allowing us to create interactive behaviors.
Adding Event Listeners
The modern way to handle events is by using addEventListener. This method can be called on any DOM element (and even the document or window objects) to register a callback function for a specific event type.
Syntax:
element.addEventListener(eventType, handlerFunction);
- eventType is a string like "click", "input", "submit", "mouseover", etc. (There are many event types.) - handlerFunction is the function to execute when the event fires. This can be a named function or an anonymous function (or arrow function). You can also pass an options object or use a third parameter for things like once or capture, but by default it's fine.
Example:
<button id="myButton">Click me</button>
let btn = document.getElementById("myButton");
btn.addEventListener("click", function() {
  console.log("Button was clicked!");
});
Now whenever the button is clicked, the message will log. We can also change content or style:
btn.addEventListener("click", function() {
  btn.textContent = "Clicked!";
  btn.style.backgroundColor = "green";
});
This will change the button text and color on click.
Common events: - Mouse events: "click", "dblclick", "mouseup", "mousedown", "mouseover", "mouseout", "mousemove". - Keyboard events: "keydown", "keyup", "keypress" (though keypress is somewhat deprecated in favor of keydown/keyup). - Form/input events: "input" (fires when text is entered in inputs), "change" (fires when an input loses focus after change, or on selection changes), "submit" (form submission), "focus", "blur. - Document events: "DOMContentLoaded" (when initial HTML parsed), "load" (when all resources loaded), "scroll", "resize on window, etc.
The Event Object and this in Handlers
When an event happens, the browser provides an event object to the handler function. We can accept it as a parameter:
btn.addEventListener("click", function(event) {
  console.log("You clicked at coordinates:", event.clientX, event.clientY);
});
The event object has properties and methods related to the event. For example, in a click event: - event.clientX, event.clientY: coordinates of the click relative to the viewport. - event.target: the element that triggered the event (often the same as this inside the handler when using function, but not for arrow functions). - event.preventDefault(): a useful method to cancel the default browser action for that event (like preventing a form from submitting or a link from navigating). - event.key in a keyboard event gives which key was pressed, etc.
this in event handlers: If you use a normal function as the handler, inside it this will refer to the element that the event is attached to (the element that handled the event). For example:
btn.addEventListener("click", function() {
  console.log("Clicked button id:", this.id);
});
this.id would give "myButton". However, if you use an arrow function, this is not bound to the element (it will use the enclosing this, which could be something else or undefined in strict mode)[6]. In arrow function handlers, use event.target or just reference the element from outer scope if needed. Usually, using this with regular function is fine for event handlers.
Removing Event Listeners
If needed, you can remove an event listener using removeEventListener, but you need to have the handler function reference to remove:
function handleClick() {
  console.log("Handled");
}
btn.addEventListener("click", handleClick);
// ...later:
btn.removeEventListener("click", handleClick);
This removes that specific listener. (Note: if you had added an anonymous function, you can't remove it easily since you don't have a reference to the exact function object.)
Event Propagation (Bubbling and Capturing) and Delegation
By default, most events bubble up the DOM tree. That means if you click a button inside a div, the click event first triggers on the button, then on its parent (the div), then maybe on the body, up to the document. You can catch that event on a parent if you want.
Event delegation is a common pattern where you attach a single event listener on a parent element, and handle events for its child items within that listener. This is useful for lists or tables where adding individual listeners to many items can be inefficient. For example:
<ul id="menu">
  <li data-item="home">Home</li>
  <li data-item="about">About</li>
  <li data-item="contact">Contact</li>
</ul>
Instead of adding click to each li, we do:
let menu = document.getElementById("menu");
menu.addEventListener("click", function(event) {
  if (event.target.tagName === "LI") {
    let item = event.target.getAttribute("data-item");
    console.log(item + " clicked");
    // do something based on item
  }
});
Here, when any <li> is clicked, the event bubbles to the #menu ul, and we catch it there. We check event.target to see if it was an LI (the target of the click). We used a custom data-item attribute to know which item. This way, one listener handles all items. If we later add more <li> inside ul (perhaps dynamically), the listener still works, without needing to add new listeners.
Event propagation can be controlled: event.stopPropagation() can stop the event from bubbling further up (or capturing down). And by adding a third argument to addEventListener {capture: true} you can catch events on the way down (capturing phase). Typically, though, for most uses, the default bubbling is fine.
Default Actions and preventDefault
Some events have default browser actions: e.g., clicking a link navigates, submitting a form sends it to the server, pressing "enter" in a text field might submit a form, etc. If you want to prevent those, you call event.preventDefault() in your handler:
document.querySelector("a#myLink").addEventListener("click", function(e) {
  e.preventDefault();
  console.log("Link click intercepted, not navigating");
});
Now clicking that link will not actually navigate.
Similarly, for a form:
form.addEventListener("submit", function(e) {
  e.preventDefault();
  // validate inputs, then maybe send via AJAX instead
});
Using preventDefault is crucial when handling form submissions via JavaScript to stop the page from reloading.
Example: Changing content on a button click
We saw an example earlier of adding a task on a button click. Let's do another quick one: a button that toggles dark mode for the page.
HTML:
<button id="modeToggle">Dark Mode</button>
CSS:
.dark {
  background-color: black;
  color: white;
}
JS:
let modeBtn = document.getElementById("modeToggle");
modeBtn.addEventListener("click", function() {
  document.body.classList.toggle("dark");
  if (document.body.classList.contains("dark")) {
    modeBtn.textContent = "Light Mode";
  } else {
    modeBtn.textContent = "Dark Mode";
  }
});
What this does: - On button click, it toggles the "dark" class on the body element. The CSS class changes the appearance. - It also changes the button text accordingly to indicate the mode.
This is a typical pattern for theme toggling. It shows classList toggling and reading classList state.
Exercise: Event Handling
1. Create a button that, when clicked, alerts "Button clicked!" (Use addEventListener).
2. Add an input field and as the user types (on the "input" event), display the current text in a <p> below. (Hint: use inputElem.value inside the handler to get current text.)
3. Make a simple "counter" buttons: one button with "+" and one with "-", and a <span id="counter">0</span> in between displaying the count. Attach events to increment or decrement the counter value when the buttons are clicked. (Use a variable to track count, or even retrieve from the text using parseInt each time.)
4. Create a list of items. Attach a single event listener to the <ul> (parent) for clicks. When an <li> is clicked, highlight it (for example, change its background color). This will use event.target and event delegation. (Bonus: maybe toggle highlight off if already highlighted, perhaps by toggling a class.)[8]
5. (Advanced) Build a simple key logger: When the user presses any key (on document or an input field), capture the key and display it. For example, display "Last key pressed: X". Use keydown event and event.key property. If the key is Enter (event.key === "Enter"), maybe do something special like add a line break to an output or indicate "Enter pressed". This gives practice with keyboard events and the event object.
11. Working with Forms
Handling forms is a common task for front-end JavaScript, as you often want to validate user input, provide instant feedback, or handle form submission via AJAX without a page reload. Forms in HTML include inputs, checkboxes, radio buttons, select dropdowns, etc., and a submit mechanism.
Let's go over key points: - Accessing form elements: You can get references to input/select/textarea elements via the same DOM methods (getElementById, etc.). Often giving each important field an id is helpful. - Reading values: For an <input> or <textarea>, use .value property to get the current value (string). For a checkbox, .checked property is a boolean indicating if it's checked. For a select, .value gives the value of the selected option (or you can get selected index or text). - Setting values: You can set these properties too (e.g., input.value = "new value"; or checkbox.checked = true;). - Form submission: When a form is submitted (e.g., by clicking a <button type="submit"> or pressing Enter in a text field), a "submit" event is fired on the form element. If you don't preventDefault, the browser will attempt to send the form data to the URL specified in form's action attribute (or reload current page if none). - Preventing submission: Often you use e.preventDefault() in a submit handler to stop actual submission, so you can handle it via JS (like validate and then maybe send via fetch or so). - Validation: You can manually check fields and show messages. Also, HTML5 provides some built-in validation (e.g., required attribute, type="email" for email format, etc.) which you can leverage.
Basic Example: Form validation on submit
HTML:
<form id="contactForm">
  <label>Name: <input type="text" id="nameField" required></label><br>
  <label>Email: <input type="email" id="emailField" required></label><br>
  <label>Message: <textarea id="msgField" rows="4" required></textarea></label><br>
  <button type="submit">Send</button>
</form>
<p id="errorMsg" style="color: red;"></p>
This form requires name, email, message. The browser will actually prevent submission if required fields are empty or if email is not in valid format because of HTML5 validation. But let's handle it ourselves too.
JS:
let form = document.getElementById("contactForm");
let errorMsg = document.getElementById("errorMsg");

form.addEventListener("submit", function(e) {
  e.preventDefault();  // prevent actual form submission/refresh

  // Get field values
  let name = document.getElementById("nameField").value.trim();
  let email = document.getElementById("emailField").value.trim();
  let msg = document.getElementById("msgField").value.trim();

  // Simple validation
  if (name === "" || email === "" || msg === "") {
    errorMsg.textContent = "Please fill in all fields.";
    return;
  }
  // rudimentary email check:
  if (!email.includes("@")) {
    errorMsg.textContent = "Please enter a valid email address.";
    return;
  }

  // If validation passes:
  errorMsg.textContent = "";
  console.log("Form Data:", { name, email, msg });
  alert("Thank you, " + name + "! Your message has been sent.");
  // Optionally, clear the form
  form.reset();
});
What we did: - On submit, we prevented default. - Fetched values from the fields (.value) and trimmed whitespace. - Checked if any are empty, or if email doesn't contain '@' (very simplistic email validation; real validation might be more complex). - If any check fails, we set an error message in a <p> and return (stop processing). - If all good, we cleared any error message, and here we just log the data and show an alert to simulate sending. We then called form.reset() which resets all fields to their initial state (clears them in this case, since they were empty initially). - In a real scenario, instead of alert, you might use fetch or another method to send the data to a server endpoint, then show a success message or update the page accordingly.
Note: We accessed inputs by id. Alternatively, form.elements collection can be used (e.g., form.elements["nameField"].value or using the name attribute of inputs). But using getElementById for each is fine and clear.
Real-time Validation and Feedback
Instead of only validating on submit, you can also validate as the user types or leaves a field: - Use input event on a field for real-time checking (e.g., show a green checkmark if password meets criteria). - Use blur event (fires when field loses focus) to validate once user finishes typing. - Change styles or show hints accordingly.
For example:
let nameField = document.getElementById("nameField");
nameField.addEventListener("input", function() {
  if (nameField.value.trim().length > 0) {
    nameField.style.borderColor = "green";
  } else {
    nameField.style.borderColor = "red";
  }
});
This will make the border green when there's something typed, red when empty (just as a simple feedback).
Handling checkbox or radio
Check boxes:
<label><input type="checkbox" id="subscribeBox"> Subscribe to newsletter</label>
JS:
let subscribeBox = document.getElementById("subscribeBox");
subscribeBox.addEventListener("change", function() {
  console.log("Subscribed:", subscribeBox.checked);
});
change event is often used for checkboxes or select dropdowns (because they don't continuously emit input events like text fields do; change fires when the value is committed).
Radio buttons: similar, but usually grouped by name:
<label><input type="radio" name="gender" value="M"> Male</label>
<label><input type="radio" name="gender" value="F"> Female</label>
We could listen to change on each radio or on the parent (like a fieldset) and check which is checked.
Select dropdown:
<select id="countrySelect">
  <option value="">-- Select Country --</option>
  <option value="sg">Singapore</option>
  <option value="us">USA</option>
</select>
JS:
let countrySelect = document.getElementById("countrySelect");
countrySelect.addEventListener("change", function() {
  console.log("Selected country code:", countrySelect.value);
});
Form best practices
Use label elements for accessibility (they can also tie to input via for attribute and id).
Validate input thoroughly, and also have server-side validation (never fully rely on client-side, but it's good for UX).
Use .preventDefault() to handle submission via JS if needed.
Provide feedback on what went wrong (like we did with errorMsg).
You can also use the Constraint Validation API (like checkValidity, setCustomValidity) of HTML5 if you want to integrate with native form validation (outside scope here, but good to know exists).
Exercise: Forms
1. Create a simple login form with two fields: username and password, and a "Login" button. Use JavaScript to validate that both fields are not empty when the button is clicked. If either is empty, show an error message (in a div or alert). If both filled, show a success message (e.g., alert "Logging in..."). Prevent actual form submission for this exercise.
2. Make a form with an <input type="range" id="volumeSlider" min="0" max="100"> and a <span id="volumeValue"></span> next to it. Use an input event on the slider to continuously update the span with the slider's current value (to simulate a volume control display).
3. Create a form with a text field for a phone number. As the user types, automatically format it in a certain pattern (e.g., add parentheses or dashes after certain digits). For example, typing "1234567890" could dynamically become "(123) 456-7890". (Hint: use input event and manipulate value, but be mindful of cursor position.) This is more advanced, but an interesting challenge in form handling.
4. Add a <select> dropdown for choosing a country, and based on the selection, show or hide an additional field. For example, if "Other" country is selected, show a text field "Please specify:". Use the change event on the select to handle this dynamic behavior.
5. (Advanced) Build a simple registration form that checks password strength as the user types the password. For instance, require a minimum length and at least one number. As the user types, display a message like "Strength: weak/medium/strong" with color coding. Use keyup or input events on the password field to evaluate the string and update the message. (This combines string handling with form events.)
12. Asynchronous JavaScript
Up until now, our code has been mostly synchronous – meaning each statement executes one after the previous, in order, and the next line waits for the previous to finish. However, in web development, we frequently deal with operations that take time (like loading data from a server, waiting for user input, or timers). JavaScript in the browser executes in a single thread, so to keep the page responsive, these long operations are handled asynchronously – meaning they start, and the program can continue running while waiting for the operation to complete. When the operation finishes, it triggers some callback or promise to handle the result.
Key asynchronous mechanisms in JavaScript: - Callbacks – the traditional way: passing a function that gets called when an async operation completes. - Promises – a newer abstraction that represents a future value or error; you attach .then and .catch callbacks. - async/await – syntactic sugar over promises to write asynchronous code that looks more like synchronous code.
Let's go through them in order of evolution.
12.1 Callbacks
A callback is just a function passed into another function to be invoked later. Many older asynchronous APIs use callbacks. For example: - setTimeout(callback, delay) uses a callback function that runs after a delay. - Old AJAX (XMLHttpRequest) or Node-style functions use callbacks.
Example with setTimeout:
console.log("Before");
setTimeout(function() {
  console.log("3 seconds passed");
}, 3000);
console.log("After");
What happens: - "Before" logs. - setTimeout is called, scheduling the callback to run after 3000ms (3 sec). Then it immediately returns (doesn't block). - "After" logs immediately, because we didn't wait 3 seconds to move on. - Then, after 3 seconds, the timeout callback executes, logging "3 seconds passed".
This shows how the asynchronous callback executes later, not blocking the main thread.
Another example: a fake asynchronous data fetch using a callback:
function fakeFetchData(callback) {
  console.log("Fetching data...");
  setTimeout(function() {
    // simulate data retrieved after 2 sec
    let data = { message: "Hello", id: 123 };
    callback(data);
  }, 2000);
}

// Using the fake fetch:
fakeFetchData(function(result) {
  console.log("Data received:", result);
});
console.log("This logs before data is received, due to async behavior.");
We pass a function to fakeFetchData. That function will be called later when data is "ready". Meanwhile, execution continues.
Callback hell: A drawback of callbacks is when you have to do many async operations in sequence, you end up nesting callbacks inside callbacks, leading to deeply indented code that's hard to read/maintain (often called "callback hell" or the pyramid of doom). For example:
doStep1(function(r1) {
  doStep2(r1, function(r2) {
    doStep3(r2, function(r3) {
      // ...and so on
    });
  });
});
This nesting is ugly. Promises help flatten this structure.
12.2 Promises
A Promise is an object representing the eventual completion (or failure) of an asynchronous operation and its resulting value[9]. You can attach callbacks to a promise instead of passing callbacks into functions.
Promises have states: pending, fulfilled (resolved with a value), or rejected (errored with a reason).
To create a promise manually, you'd do:
let p = new Promise((resolve, reject) => {
  // do something async
  setTimeout(() => {
    let success = true; // just example
    if (success) resolve("Yay!");
    else reject(new Error("Something went wrong"));
  }, 1000);
});
But more often, you'll be using functions that return promises (like the modern fetch API returns a promise).
Using a promise:
p.then(value => {
  console.log("Promise fulfilled with:", value);
}).catch(error => {
  console.error("Promise rejected:", error);
});
The then callback runs when resolve is called (with the value), catch runs if reject is called (or an error thrown). You can chain .then() calls for sequential operations.
Let's use the built-in fetch API as a real example (which fetches a URL and returns a promise):
console.log("Starting fetch...");
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())  // parse JSON from response
  .then(data => {
    console.log("Received post:", data);
  })
  .catch(error => {
    console.error("Fetch error:", error);
  });
console.log("Fetch initiated, waiting for response...");
Output flow: - "Starting fetch..." logs. - fetch initiated (non-blocking). - Immediately "Fetch initiated..." logs. - After some time when network responds, the first then runs with response object, we return response.json() which itself returns a promise to parse JSON. - When JSON is parsed, second then runs with the actual data (post object) and logs it. - If any error happens (network error or JSON parse error), the catch would run and log the error.
This demonstrates how promises allow chaining (then returns a new promise, enabling chain) and error catching. It's more linear than nested callbacks.
Promise chaining vs nesting: With promises you do:
doStep1()
  .then(result1 => doStep2(result1))
  .then(result2 => doStep3(result2))
  .then(result3 => {
    // final result handling
  })
  .catch(err => {
    // handle any error from any step
  });
This is flat and easier to read than nested callbacks.
There are also utility functions like Promise.all (to run multiple promises in parallel and wait for all) and Promise.race (first one wins), etc., which are useful in certain scenarios (like waiting for multiple data endpoints to load).
12.3 async/await
ES2017 introduced async functions and the await keyword, which is built on promises but allows writing code in a synchronous-looking style.
You mark a function as async, and then inside it you can await a promise. await will pause the function execution until the promise settles (fulfills or rejects). Meanwhile, the rest of the program can run (the function is asynchronous and doesn't block the main thread).
Example rewriting the fetch example with async/await:
async function fetchPost() {
  try {
    console.log("Starting fetch...");
    let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    let data = await response.json();  // await parsing as well
    console.log("Received post:", data);
  } catch (error) {
    console.error("Fetch error:", error);
  }
  console.log("This will log after the data is fetched (in sequence inside function).");
}

fetchPost();
console.log("This logs while fetchPost is running asynchronously.");
Points: - We define fetchPost as async. Inside, we use await for fetch and for response.json. - We wrap in try/catch to handle errors (like a .catch). - The console.log after the awaits only runs after data is fetched, making it easy to handle sequential steps. - We call fetchPost() (it returns a promise, which we don't even need to handle explicitly here, but we could if we wanted to know when it's done). - The final outside log shows that outside code isn't blocked by the await; fetchPost runs asynchronously.
The result is code that's easier to write and read for multiple steps, without .then chaining. Under the hood, it's still using promises.
Important: You can only use await inside an async function (or at top-level in modules or some environments). If you need top-level, you might do async function main(){...; await ...; } main(); structure.
Real usage scenario:
Let's simulate something: using setTimeout and Promise:
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function demoAsync() {
  console.log("Wait for 1 second...");
  await delay(1000);
  console.log("1 second passed.");
  console.log("Wait for another 2 seconds...");
  await delay(2000);
  console.log("2 more seconds passed. Done!");
}
demoAsync();
This uses a helper delay that returns a promise which resolves after given milliseconds (essentially a promise version of setTimeout). Then inside demoAsync we await it to pause.
Note on error handling: In promise chain, you typically have a .catch. In async/await, use try/catch around await calls to handle rejections (or allow them to bubble up to an outer catch if the function returns a promise and you catch that).
The Event Loop (briefly)
JavaScript's concurrency model is based on an "event loop". The event loop handles the execution of multiple chunks of code over time, coordinating between the call stack and a message queue (or task queue). When an asynchronous task completes (like a timer finishes, or fetch returns data), a callback (or promise resolution) is queued to be executed. The event loop will only execute these queued callbacks when the main thread is free (call stack is empty). This is why even a setTimeout with 0ms doesn't run immediately, but only after the current code finishes and event loop picks up the callback[10].
Understanding this helps you realize that, for example:
setTimeout(() => console.log("timeout"), 0);
console.log("end");
will always log "end" then "timeout", because the timeout callback goes to the queue and will run after the current call finishes.
Exercise: Asynchronous JS
(Note: some of these might require running in an environment where you can use fetch or simulate with setTimeouts.)
1. Use setTimeout to log "Hello" after 2 seconds. Then schedule another setTimeout inside that callback to log "World" after an additional 1 second. (This is a callback chain; try to predict the timing.)
2. Create a promise-based function wait(ms) that returns a promise which resolves after ms milliseconds (like the delay function above). Use it with .then to wait 1 second, then log a message. Then chain another wait(1 second) and log another message.
3. Using Promise.all: Suppose you have two promises p1 and p2 that each resolve after a random time (simulate with setTimeout inside). Use Promise.all([p1, p2]) to know when both are done, and then log both results. Also attach a .then to each individually to see when each finishes. (This shows parallel async operations.)
4. If you have an array of URLs, how would you fetch all of them and log the results when all have finished? (Hint: Promise.all on an array of fetch promises). This is a conceptual exercise unless you have actual endpoints to hit.
5. (Advanced) Write an async function that fetches data from two endpoints sequentially (one after the other, using await), and then returns combined data. For example, fetch user info from /user/1, then fetch that user's posts from /user/1/posts, and return an object containing both user info and posts. Use try/catch to handle errors. (You can use a public API or just simulate with delay and dummy data.)
13. Modern JavaScript (ES6+) Features
JavaScript has evolved, and ES6 (also known as ECMAScript 2015) was a big update that introduced many new features to make the language more powerful and developer-friendly. Since ES6, each year new features have been added (ES2016, ES2017, ..., up to ES2021/ES2022 at this point). Collectively, we might call these "ES6+" or modern JS features.
We've already been using some (like let, const, arrow functions, classes, etc.). Let's summarize and cover the key ones:
13.1 Block-Scoped Variables (let & const)
let and const (introduced in ES6) provide block scope for variables, unlike var which is function-scoped or global-scoped[11]. Block scope means they only exist within the nearest enclosing { } block (like inside an if, loop, or function).
We've replaced var with let and const in our examples: - Use let when the variable will change (a mutable binding). - Use const for constants (immutable binding) - you cannot reassign a const, which helps prevent accidental changes.
Example:
if (true) {
  let x = 5;
  const y = 10;
  // x and y exist here
}
console.log(typeof x); // undefined, x is not visible outside the block
var would have hoisted out of the block (if not in a function), but let/const do not.
Temporal Dead Zone: let/const are hoisted in a sense but not initialized. You cannot access them before their declaration in the code. If you try, you'll get a ReferenceError instead of undefined as with var.
Good practice: Use const by default, and only use let if you need to reassign the variable later. This makes your intentions clear and prevents unintended changes[12].
13.2 Template Literals (Template Strings)
ES6 introduced template literals using backtick ` characters. They allow embedding expressions and multi-line strings easily.
Example:
let name = "Alice";
let age = 25;
console.log(`My name is ${name} and I am ${age} years old.`);
// Output: My name is Alice and I am 25 years old.
The ${...} syntax evaluates the expression inside and inserts it into the string. This is much nicer than concatenating with +. Template strings also respect newlines:
let text = `This is line 1
and this is line 2.`;
No need for \n manually.
They also allow using complex expressions inside ${} and even calling functions or using ternaries:
console.log(`I am ${age >= 18 ? 'an adult' : 'a minor'}.`);
13.3 Destructuring and Rest/Spread
Destructuring allows you to unpack values from arrays or properties from objects into distinct variables in a convenient way.
Array destructuring:
let arr = [10, 20, 30];
let [a, b, c] = arr;
console.log(a, b, c); // 10 20 30

// Skipping and default:
let [x, , z = 99] = [5, 6];
console.log(x, z); // 5 99 (z got default because third element was undefined)
Object destructuring:
let person = { firstName: "Bob", lastName: "Smith", age: 40 };
let { firstName, age } = person;
console.log(firstName, age); // Bob 40

// Using different variable names:
let { firstName: f, lastName: l } = person;
console.log(f, l); // Bob Smith

// Default and missing:
let { country = "Unknown" } = person;
console.log(country); // Unknown (person.country was undefined)
Destructuring is great for pulling out what you need from a returned object or array. For example, if a function returns { data, error }, you can do:
let { data, error } = someFunction();
instead of accessing properties individually.
Rest and Spread: - Spread operator ... (in arrays or objects) expands an iterable or object in places where multiple elements/keys are expected. - Rest operator ... in function parameters or destructuring collects multiple elements into an array or remaining properties into an object.
Spread with arrays:
let arr1 = [1, 2, 3];
let arr2 = [4, 5];
let combined = [...arr1, ...arr2, 6];
console.log(combined); // [1,2,3,4,5,6]
We merged arrays easily. Spread can also spread a string into letters:
console.log([...'hello']); // ['h','e','l','l','o']
Spread with objects (ES2018):
let obj1 = { a: 1, b: 2 };
let obj2 = { b: 5, c: 6 };
let mergedObj = { ...obj1, ...obj2 };
console.log(mergedObj); // { a:1, b:5, c:6 } (obj2's b overwrote obj1's b)
This is great for cloning objects or merging, instead of Object.assign.
Rest in function parameters:
function sumAll(...numbers) {
  return numbers.reduce((sum, n) => sum + n, 0);
}
console.log(sumAll(1, 2, 3, 4)); // 10
...numbers in parameters means any extra arguments will be an array named numbers inside the function. So sumAll can accept any number of arguments.
Rest in destructuring:
let [head, ...tail] = [100, 200, 300, 400];
console.log(head); // 100
console.log(tail); // [200, 300, 400]

let { a, ...others } = { a: 10, b: 20, c: 30 };
console.log(a);     // 10
console.log(others); // { b: 20, c: 30 }
In arrays, rest collects the "rest" of elements. In objects, it collects remaining properties not picked.
13.4 ES6 Classes
ES6 introduced a class syntax to make object constructor and inheritance easier to write (though under the hood it uses prototypes).
Example:
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hello, I'm ${this.name}.`);
  }
}

let p = new Person("Alice", 30);
p.greet(); // "Hello, I'm Alice."
The class syntax: - constructor is a special method that runs when new Person() is called. It sets up the object. - Methods defined in class (like greet) go on the prototype (shared by instances). - We can also have getters, setters, and static methods (prefixed with static for class-level methods).
Inheritance with classes:
class Employee extends Person {
  constructor(name, age, position) {
    super(name, age); // call parent constructor
    this.position = position;
  }

  // override greet method:
  greet() {
    console.log(`Hello, I'm ${this.name}, and I work as a ${this.position}.`);
  }
}

let e = new Employee("Bob", 25, "Developer");
e.greet(); // "Hello, I'm Bob, and I work as a Developer."
extends sets up prototype chaining. super calls the parent class's constructor (must do before using this in subclass constructor). You can also call super.methodName() to call a parent method if you override it.
Under the hood, classes use prototypes (so methods are shared, etc.), but you don't need to manually manipulate Function.prototype etc. It's cleaner and more similar to classes in other languages, which helps many developers.
Important: Classes in JS are mostly "syntactic sugar"[13]. The actual mechanism is still prototypal inheritance.
13.5 Modules (Import/Export)
ES6 added native modules. We have a whole section on modules coming up next, so here just to note: you can use export and import to split code into files. This replaced older patterns like IIFEs or AMD/RequireJS or CommonJS in browser context.
Using modules ensures each file has its own scope and we explicitly import what we need.
Example:
// math.js
export function add(a, b) { return a + b; }
export const PI = 3.14159;
// main.js
import { add, PI } from './math.js';
console.log(add(2, 3)); // 5
console.log(PI); // 3.14159
We will detail this in the next section.
13.6 Other ES6+ Features
A few other notable ones: - Arrow functions: we covered. - Default parameters: We saw in best practices. You can give function parameters default values: function multiply(a, b = 1) { return a*b; }. - Iterators and for-of: for...of loop (we used it for arrays). Also Strings, Maps, Sets, etc. are iterable. - Maps and Sets: New data structures. - Map: A dictionary of key-value pairs, like an object but keys can be any type (even objects). Methods: set(key, value), get(key), has(key), delete(key), and it preserves insertion order. Example:
let map = new Map();
map.set('name', 'Alice');
map.set(obj, 42); // an object as key
console.log(map.get('name')); // Alice
- Set: A collection of unique values. Methods: add(value), has(value), delete(value). Good for checking existence, eliminating duplicates, etc. - Symbols: A new primitive type for unique identifiers (mostly for advanced use, like to define hidden object properties or for certain JS internal hooks). - Promises: as discussed. - String.includes, String.startsWith, String.endsWith: easier string checks than using indexOf. - Array.find, Array.findIndex, Array.includes: we mentioned includes for arrays; find returns the first element satisfying a condition, etc. - Object enhancements: - Shorthand property names: if variable name and object property name are same, you can do:
let name = "Charlie";
let age = 30;
let obj = { name, age }; // same as { name: name, age: age }
- Shorthand method definitions: we showed greet() { } in class and object literal too:
let obj = {
  greet() { console.log("hi"); }
};
- Computed property names:
let propName = "custom";
let obj = {
  [propName + "Name"]: "Value"  // creates property "customName": "Value"
};
- Optional chaining (ES2020): ?. operator to safely access nested properties. For example:
let user = { profile: { name: "Sam" } };
console.log(user.profile?.name); // "Sam"
console.log(user.contact?.email); // undefined (without error, since user.contact is undefined, it short-circuits)
Very handy to avoid Cannot read property X of undefined errors. - Nullish coalescing (ES2020): ?? operator to provide a default only if value is null or undefined (as opposed to || which treats falsy like 0 or "" as well). Example:
let input = 0;
console.log(input || 5); // 5 (because 0 is falsy)
console.log(input ?? 5); // 0 (because 0 is not null/undefined, so ?? leaves it)
- Async/await (ES2017): we covered.
The above features together make modern JS much nicer to work with than older ES5 code. When reading older code, you might see var, manual function constructors for objects, or concatenation for strings, but nowadays we use these improved constructs.
Exercise: Modern JS Features
(This will reinforce usage of some features.) 1. Use template literals to create a multi-line string that contains a quote and an interpolated value (e.g., someone's name and age).
2. Given an object {a:1, b:2, c:3}, use destructuring to extract a and c into variables, and use the rest operator to collect the remaining properties into another object.
3. Use the spread operator to merge two arrays, and also to clone an object (e.g., let objCopy = {...originalObj}). Verify that modifying the clone doesn't affect the original.
4. Write a function maxOfThree(x, y, z) that uses Math.max but passes the arguments using the spread operator (hint: Math.max(...array) can spread array values into arguments). Perhaps accept an array and do Math.max(...arr).
5. Create a Map of student names to scores (e.g., let scores = new Map([ ["Alice", 90], ["Bob", 85] ]);). Add a new entry, then retrieve and log a score. Iterate over the Map with a for-of loop [for (let [name, score] of scores) { ... }] and print each entry. Do a similar creation of a Set of some values, and demonstrate adding and checking values.
6. (Optional, if environment supports) Use optional chaining and nullish coalescing in an example: e.g., let user = null; console.log(user?.name ?? "Anonymous"); and explain the result.
14. Modules in JavaScript
As programs grow, it's essential to organize code into separate files (modules) for clarity and reuse. Historically, before ES6 modules, people used libraries or module bundlers (like Webpack, using CommonJS require or AMD define) to simulate modular code in the browser. But now browsers support native JS modules via the import and export syntax.
Using modules helps avoid polluting the global namespace with variables and functions (each module has its own scope) and allows us to explicitly control what is exposed to other modules.
Enabling modules
To use modules in a browser environment, include your main script with type="module" in the HTML:
<script type="module" src="main.js"></script>
This tells the browser to treat main.js as a module (so you can use import/export). One important detail is that when running from files (file:// protocol), modules may not work due to security restrictions (browsers often require them to be loaded via a server). So typically you'll test modules via a local server or a bundler. But conceptually, let's proceed with how to use them.
Exporting from a module
In a module file, you can mark certain functions, objects, or values as exported.
Two ways: - Named exports: You can export multiple values by name. - Default export: One module can designate a default export (like the main thing exported).
Named exports example (mathUtils.js):
// Exporting individual things
export function add(x, y) {
  return x + y;
}

export function multiply(x, y) {
  return x * y;
}

// You can also declare first, then export later:
function square(x) {
  return x * x;
}
export { square };  // named export after declaration

// Export a variable (could be const, let, var):
export const PI = 3.14159;
This module exports add, multiply, square, and PI as named exports.
Default export example (greet.js):
export default function greet(name) {
  console.log(`Hello, ${name}!`);
}
// Could also do: export default someVariable or default class, etc.
Here greet is the default export of this module.
Note: You can have multiple named exports per module, but only one default export.
Importing into another module
In another file (say main.js), you import what you need:
Importing named exports:
import { add, PI, square } from './mathUtils.js';
console.log(add(2, 3));
console.log("Area of circle radius 2:", PI * square(2));
You can also rename on import:
import { multiply as mul } from './mathUtils.js';
console.log(mul(3, 4)); // 12
If you want all exports as an object:
import * as math from './mathUtils.js';
console.log(math.add(5,5));
console.log(math.PI);
This imports everything under the namespace math.
Importing default exports:
import greet from './greet.js';  // no braces, you can choose a name for default import
greet('Alice');  // Hello, Alice!
If a module had both default and named, you could:
import defaultExport, { named1, named2 } from './someModule.js';
But the default one is rarely mixed with multiple named in practice; often modules either export a bunch of named or one default.
Modules and strict mode
Modules by default run in strict mode (no need for "use strict") and have their own scope. Top-level this in a module is undefined (not window)[14], which is usually fine. Variables you declare in a module are not global.
Module loading and execution order
If one module imports another, the imported module is loaded and executed first (once, even if multiple modules import it, thanks to caching). Module imports are static (you can't conditionally import at runtime without dynamic import, which is another feature). The browser loads modules asynchronously by default (deferred until after HTML parsing), so they're non-blocking like scripts with defer.
Dynamic import
There's also a import() function (since ES2020) to dynamically load modules on the fly, returning a promise. E.g., import('./module.js').then(module => { module.doSomething(); });. This is used for code-splitting or loading code on demand.
Example:
Let's illustrate with a small module usage: File: utils.js
export function toUpper(str) {
  return str.toUpperCase();
}

export const version = "1.0";
File: app.js
import { toUpper, version } from './utils.js';
import greet from './greet.js';

console.log("Utils version:", version);
greet(toUpper("world"));  // expected greet to say "Hello, WORLD!"
File: greet.js
export default function(name) {
  console.log(`Hello, ${name}!`);
}
When app.js runs (assuming it's included as type=module script): - It sees the import statements and will load utils.js and greet.js first. - In utils.js, the functions are defined and exported. - In greet.js, the default function is defined. - Then back in app.js, it has the imported functions ready to use, and it calls them.
Note on file paths: Typically, when using modules in browser, you'll use relative or absolute paths. Ensure correct path and maybe use .js extension explicitly. Modules are fetched with CORS rules (so if not same origin or no proper headers, might get issues, but in local dev on a server, it's fine).
Pitfalls: - Modules must be served from a server for most browsers (like running a local static server, e.g., using http://localhost). If you just open an HTML file via file://, imports may fail due to security. - Circular dependencies (module A imports B and B imports A) can be problematic. The modules partially load, with any declarations available but not the full evaluation. It's best to avoid if possible or refactor shared pieces into a third module. - You cannot import non-JS files directly without build tools (browsers only understand JS modules, but build systems allow importing CSS or images, etc., by bundling them differently).
Exercise: Modules
(This might be theoretical if not actually running files, but it's to test understanding)
1. Imagine you have two files: helpers.js exporting a function export function sayHi(name) { console.log("Hi " + name); }, and main.js which imports and uses it. Write the import statement and usage in main.js.
2. Suppose math.js has a default export of a class Calculator. Show how you'd import that default class in another file and instantiate it.
3. If moduleA.js exports const a = 1; export const b = 2;, and moduleB.js does import * as stuff from './moduleA.js';, what is stuff.a and stuff.b? And if moduleB also had export { stuff }, what would another module get if it imported stuff from moduleB? (This is to think about re-exporting, which is possible: export { something } from './othermodule.js';).
4. How would you dynamically import a module only when needed? (E.g., using import('./math.js').then(mod => ...)). What type of object do you get in the .then?
5. (Advanced) Outline how you would break a larger project (say a to-do app) into modules: e.g., maybe a module for DOM interactions, a module for data logic (like an array of tasks and functions to manipulate it), and a main module to tie them together. What might each export or import from others? (This is more of a design thought exercise.)
15. Closures
A closure is a fundamental concept in JavaScript that allows a function to access variables from an outer function’s scope even after the outer function has finished executing. In other words, a closure is formed when an inner function "closes over" (captures) variables from its surrounding scope. This is possible because in JavaScript, functions are first-class citizens and they carry their lexical scope with them wherever they go.
Let's break that down in a simpler way: - When you create a function inside another function, the inner function has access to the variables of the outer function (and global scope too). - If the outer function finishes executing and its local variables would normally go out of scope, they remain alive if an inner function still references them. The inner function remembers the environment it was created in – that's the closure.
Why are closures useful?
They enable powerful patterns like: - Data privacy / Emulating private variables: You can keep some data hidden inside a closure and only expose functions that access it. - Function factories: Functions that generate other functions with preset environments. - Maintaining state in an asynchronous callback or event handler after an outer function has returned.
Let's see a classic closure example:
function makeCounter() {
  let count = 0;
  return function() {
    count++;
    console.log(count);
  };
}

let counter1 = makeCounter();
counter1(); // 1
counter1(); // 2

let counter2 = makeCounter();
counter2(); // 1 (it's independent of counter1)
What happened here: - makeCounter is an outer function that declares a local variable count. - It returns an inner function (without a name, an anonymous function) that increments and logs count. - When we call makeCounter(), it returns that inner function (and its closed-over state). - counter1 and counter2 are two separate closure instances, each with their own count variable that persists between calls.
Even though makeCounter finished executing, the variable count lives on in the closures created (one for counter1, one for counter2). The inner function forms a closure with count. Each time we call counter1(), it updates the count from its own closed-over scope.
To emphasize: A closure gives you access to an outer function’s scope from an inner function[15]. JavaScript uses lexical scoping, meaning the inner function's scope chain includes the scope where it was defined.
Another example (to illustrate capturing function arguments or outer variables):
function greetMaker(greeting) {
  return function(name) {
    console.log(greeting + ", " + name);
  };
}

let sayHello = greetMaker("Hello");
sayHello("Alice"); // Hello, Alice
sayHello("Bob");   // Hello, Bob

let sayHi = greetMaker("Hi");
sayHi("Charlie");  // Hi, Charlie
Here: - greetMaker takes a greeting string and returns an inner function that uses greeting. - The inner function closes over the greeting variable. Even after greetMaker returns, the inner function remembers the greeting that was passed. - sayHello closure has greeting = "Hello", sayHi has greeting = "Hi".
This is a very handy pattern for creating specialized functions (we created two "greeter" functions with different preset greeting messages).
Closures and Loops: A common pitfall: using var in loops with closures often led to needing closures to capture the loop variable each iteration. For example:
for (var i = 1; i <= 3; i++) {
  setTimeout(function() {
    console.log("var loop i:", i);
  }, 100 * i);
}
Because var is function-scoped, the three timeouts all share the same i (which ends as 4 after loop). So they'd all print 4 after delays. Using let solves this because let is block-scoped (each iteration has its own i). Or with closures:
for (var j = 1; j <= 3; j++) {
  (function(x) {
    setTimeout(function() {
      console.log("closure loop j:", x);
    }, 100 * x);
  })(j);
}
Here an IIFE (immediately-invoked function expression) captures the current j as x, so each timeout gets the right value. But nowadays simpler: use let j and no extra closure needed:
for (let k = 1; k <= 3; k++) {
  setTimeout(() => console.log("let loop k:", k), 100 * k);
}
That works due to block scoping and arrow's lexical capturing.
Memory considerations: Variables in closures are not garbage-collected as long as the function that closed over them is still reachable. This means if you create too many closures holding large structures, memory can be retained. Usually not an issue, but something to be aware of.
Summary: A closure is like a backpack that a function carries around; it holds all the variables from the outer scopes that were in-scope when the function was created[15]. Whenever the function is called, it has access to those variables from when it was defined, not just when called.
Exercise: Closures
1. Write a function makeAdder(x) that returns a new function. The returned function should take a parameter y and return x + y. Use a closure to remember x. Test it: e.g., let add5 = makeAdder(5); console.log(add5(10)); // 15.
2. Create a function rememberMe(message) that stores a message string, and returns a function that when called, logs "Remember: [message]". Try using it to create a couple of reminder functions with different messages and call them later.
3. Use a closure to create a simple "once" utility: Write once(fn) that returns a new function that wraps a given function fn, such that the first time the new function is called, it runs fn normally, but subsequent calls do nothing. (Hint: use a flag variable in the closure to track if it has been called already.) Example:
let justOnce = once(() => console.log("This should appear only once"));
justOnce(); // prints message
justOnce(); // does nothing
4. Make a module pattern using closures (without using ES6 imports): Define a function createCounter() that uses closure to encapsulate a count variable and returns an object with two methods: increment() (which increases count) and get() (which returns current count). Demonstrate usage:
let c = createCounter();
c.increment();
c.increment();
console.log(c.get()); // 2
The count should not be directly accessible from outside, only via the methods (this is classic closure for data privacy).
5. (Advanced) Closures in asynchronous callbacks: Write a function countdown(n) that for a given number n, uses setInterval to log the numbers n, n-1, ... 1 one per second, then logs "Done!". Use a closure to ensure the callback of setInterval can access the current count. (Note: setInterval returns an interval ID you can clear with clearInterval; consider clearing it when reaching 0). This will test understanding of closure with timed callbacks. (Alternatively, can use nested setTimeout for a simpler sequential solution.)
16. The this Keyword
The this keyword in JavaScript is a bit tricky at first because its value depends on how a function is called, not where or how it was defined (except for arrow functions, which are an exception). It basically refers to the "owner" or context of the function invocation.
Let's break down common scenarios:
Global context (non-strict mode vs strict)
In the global scope (outside any function), this refers to the global object (window in browsers) when not in strict mode[14].
In strict mode, this would be undefined if not set otherwise.
Modules (ES6) and classes are always in strict mode by default, so at top-level of a module, this is undefined (not window).
Inside a function (non-arrow) - default binding
If a function is called standalone (not as a method on an object), in non-strict mode this will be the global object (window). In strict mode, this will be undefined[14].
function showThis() {
  console.log(this);
}
showThis(); // in sloppy mode: Window, in strict mode: undefined.
When you intend to use this but call a function without context, it can lead to unexpected behavior (e.g., this being global or undefined).
As a method of an object - implicit binding
When a function is called as a property of an object, this refers to that object.
let obj = { name: "Alice", sayName: function() { console.log(this.name); } };
obj.sayName(); // "Alice" (this refers to obj)
Here, obj.sayName() sets this to obj inside sayName.
It's the base of how methods work. If you lose the reference to the object, this can change. For example:
let f = obj.sayName;
f(); // called without obj context, this is now global or undefined.
That is a common pitfall: extracting a method into a variable and then calling it, loses the original this.
this in constructor functions / classes - new binding
When you use new with a function (constructor or class), this inside that function is a brand new object being constructed (and returned implicitly).
function Person(name) {
  // this = {} (implicitly)
  this.name = name;
  // return this (implicitly)
}
let p = new Person("Bob");
console.log(p.name); // "Bob"
In classes, the constructor and methods work similarly (in a method defined in a class, this refers to the instance).
Explicit binding with call/apply/bind
You can manually set this of a function using function.call(thisValue, arg1, arg2, ...) or function.apply(thisValue, [args]).
function greet() { console.log(this.message); }
let obj1 = { message: "Hi" };
greet.call(obj1); // "Hi" (this in greet is obj1)
bind(thisValue) returns a new function with this permanently set to the given value.
let greetObj1 = greet.bind(obj1);
greetObj1(); // "Hi"
bind is often used to fix the this for callbacks, etc.
Arrow Functions and this
Arrow functions are special: they do not have their own this. Instead, an arrow function uses the this from its surrounding lexical context (the enclosing function or module)[16]. So this inside an arrow is the same as this outside the arrow (at definition time).
Example:
let obj2 = {
  name: "Carol",
  regularFunc: function() { console.log("reg:", this.name); },
  arrowFunc: () => { console.log("arrow:", this.name); }
};
obj2.regularFunc(); // "reg: Carol" (this is obj2)
obj2.arrowFunc();   // "arrow: undefined" or maybe window.name if defined, because arrowFunc's this = global or undefined
In that snippet, arrowFunc was defined in the global scope (or module scope) likely, so this inside it is the global this (window or undefined in strict). It doesn't matter that it's called as obj2.arrowFunc; arrow doesn't care how it's called, it only cares where it was created. It was created with this probably undefined (if module) or window (if not strict). So, arrow functions are not suitable as methods if you need to access object properties via this. But they are very handy in callbacks because they don't rebind this. For instance, if you have an object with a method that uses a callback, an arrow callback can see the this of the outer method.
Example:
let obj3 = {
  name: "Dan",
  friends: ["Eve", "Frank"],
  printFriends: function() {
    this.friends.forEach(friend => {
      console.log(this.name + " knows " + friend);
    });
  }
};
obj3.printFriends();
// "Dan knows Eve"
// "Dan knows Frank"
Here, inside forEach callback (arrow), this is the same as in printFriends, i.e., obj3, so we could use this.name. If we used a regular function in forEach, this would be undefined or global inside it unless we used .bind or a var self = this trick. Arrow made it easier.
this in event handlers: - When using element.addEventListener("click", function() { ... }), inside that regular function, this will refer to the element that the handler is attached to (the element that received the event)[17]. - If you use an arrow function as a listener, this will not be the element (it will be the outer this), so better use event.target or a normal function if you need this to be element.
Summary rules: 1. If a function is called with new, this is the new object. 2. If a function is called via obj.method(), this is obj (the object to the left of the dot). 3. If a function is called standalone (no dot, not new, not bind/call), this is global (window) in non-strict, or undefined in strict. 4. If call or apply is used, this is explicitly what you pass in. 5. Arrow functions: this is lexically inherited (no new, no call can change it).
Common mistakes: - Losing this by assigning method to variable or passing as callback. Solutions: use bind or arrow to retain context. - Thinking this refers to function itself or its scope – it does not. It's about how function is invoked.
Exercises: this
1. Create an object with a property name and a method sayName that console.logs the name via this.name. Call it as a method (obj.sayName()) and verify it prints the name. Then assign the method to a separate variable and call it, what happens to this?
2. In strict mode, call a regular function (not as a method) that logs this. What do you get? (Answer: undefined). In non-strict (if possible to test), this would be window.
3. Show using call or apply to borrow a method from one object for another. For example, person.sayName.call(otherPerson).
4. Write a constructor function Car(make, model) that sets properties on this. Then create two car objects with new Car("Toyota", "Corolla") etc. Add a method to Car's prototype that uses this to print something like "This car is a Toyota Corolla." Call that method on both instances to show this refers to each individual instance.
5. (Advanced) Create a simple HTML with a button. Attach an event via addEventListener using a normal function and inside it console.log(this). What is logged? (It should be the button element). Then change the handler to an arrow function and see what this is (likely window or undefined, since arrow doesn't bind to the element). This will solidify the difference in event handler context.
17. Prototypes and Inheritance
JavaScript uses prototypal inheritance, meaning objects can inherit properties and methods from a prototype object. Every object has an internal link to a prototype (accessible via __proto__ or Object.getPrototypeOf)[13]. If you try to access a property on an object and it’s not found, JavaScript will look for it on the object's prototype, then on the prototype's prototype, and so on, forming the prototype chain[18].
Let's explain with an example:
let animal = {
  eats: true,
  walk: function() {
    console.log("Animal walking");
  }
};

let rabbit = {
  jumps: true
};

// Set animal as prototype of rabbit
rabbit.__proto__ = animal;  // Not recommended in modern code to set like this, but for understanding.
console.log(rabbit.eats);   // true (found via prototype chain: rabbit -> animal -> found eats)
rabbit.walk();             // "Animal walking" (walk found on animal)

console.log(rabbit.jumps); // true (own property)
Here, rabbit inherits from animal. So rabbit has access to properties eats and walk as if they were on itself (but they actually reside on animal). The __proto__ property is a way to access the prototype (though in modern code, use Object.create or Object.setPrototypeOf to manage prototypes, or class syntax which under the hood sets up prototypes for you).
Constructor function prototypes: When you create objects via constructor functions (using new), the prototype of the new object is ConstructorFunction.prototype property.
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  console.log("Hi, I'm " + this.name);
};

let alice = new Person("Alice");
alice.greet(); // "Hi, I'm Alice"
How this works: - Person.prototype is an object (by default has constructor property). - When we do new Person, the new object’s internal prototype is set to Person.prototype. - So alice.__proto__ === Person.prototype. - Therefore, alice inherits greet from Person.prototype.
If we add methods to Person.prototype, all Person instances can use them.
Prototype chain end: The chain ends at Object.prototype, which is the prototype of most base objects (unless you create an object with no prototype via Object.create(null)). Object.prototype has some common methods like toString, hasOwnProperty etc. And Object.prototype.__proto__ is null, meaning no further chain.
Class syntax and prototypes: Classes in ES6 under the hood do this: - The methods you define in class (not inside constructor, but as methods) are placed on the prototype. - extends sets up the prototype chain for inheritance between classes.
Example:
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} barks.`);
  }
}

let rex = new Dog("Rex");
rex.speak(); // "Rex barks."
Under the hood: - Dog.prototype is an object that has its proto pointing to Animal.prototype. - So if a property isn't found on Dog.prototype, it checks Animal.prototype, then Object.prototype. - The super() in constructor sets up Animal's part of initialization, and Dog.prototype automatically inherits from Animal.prototype.
Shadowing properties: If a property exists on both the object and its prototype, the object's own property is used (it shadows the prototype property).
rabbit.eats = false; 
console.log(rabbit.eats); // false (own property now, shadowing animal.eats)
console.log(animal.eats); // true (remains)
If you delete rabbit.eats, then rabbit.eats would again be found on prototype returning true.
Checking own properties vs inherited: Use obj.hasOwnProperty(prop) to check if a property is directly on object (not on prototype)[11].
console.log(rabbit.hasOwnProperty('eats')); // false (since comes from prototype)
console.log(rabbit.hasOwnProperty('jumps')); // true
Why use prototypes? - Memory efficiency: Methods defined on prototype are shared by all instances, rather than each instance having its own copy of the method. - Dynamic extension: You can add methods to prototypes even after objects are created, and they'll gain those methods (though modifying built-in prototypes like Array.prototype is not recommended unless polyfilling, as it affects all arrays). - Inheritance: one object can extend another and override or add new behavior while reusing existing logic.
Performance note: Looking up properties on the prototype chain is slightly slower than direct properties, but typically negligible. If in a very hot loop, direct might be microscopically faster, but usually it's fine.
Using Object.create: Another way to create an object with a given prototype:
let catProto = {
  speak() { console.log(`${this.name} meows.`); }
};
let myCat = Object.create(catProto);
myCat.name = "Whiskers";
myCat.speak(); // "Whiskers meows."
Object.create sets the prototype of new object to catProto (without needing a constructor).
Inheritance with prototypes (without class):
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function() {
  console.log(this.name + " makes a noise.");
};

function Dog(name) {
  Animal.call(this, name); // call super constructor
}
// Set Dog's prototype to Animal's prototype:
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // fix the constructor reference
Dog.prototype.speak = function() {
  console.log(this.name + " barks.");
};

let d = new Dog("Rex");
d.speak(); // Rex barks.
This is how we did inheritance pre-ES6 classes.
Summary: Prototypes are JavaScript's way of doing inheritance and sharing properties between objects[13]. Understanding prototypes helps in understanding how built-in objects (like arrays inherit from Array.prototype, which inherits from Object.prototype) and how instanceof works (checks the prototype chain).
instanceof example:
console.log(d instanceof Dog); // true
console.log(d instanceof Animal); // true (because Dog.prototype inherits from Animal.prototype)
console.log(d instanceof Object); // true
Exercises: Prototypes
1. Create a constructor function Animal(type) that sets this.type. Add a method Animal.prototype.sayType that logs "I am a [type]". Create two animal objects and test sayType on them.
2. Create a Shape constructor with a color property. Add a method describe() on Shape.prototype that prints something like "A [color] shape.". Then create a constructor Circle(radius, color) that calls Shape.call(this, color) and sets this.radius. Set up Circle.prototype = Object.create(Shape.prototype) and Circle.prototype.constructor = Circle, then add a method Circle.prototype.area() that returns πr^2. Create a Circle instance and call both describe() (inherited) and area() (own).
3. Examine the prototype chain of a built-in type: e.g., console.dir(Array.prototype) in a browser console to see what's on it. Or programmatically:
let arr = [1,2,3];
console.log(Object.getPrototypeOf(arr) === Array.prototype); // true
console.log(Object.getPrototypeOf(Array.prototype) === Object.prototype); // true
Explain what the above indicates (basically that an array inherits from Array.prototype, which in turn inherits from Object.prototype).
4. Use Object.create to create an object that prototypically inherits from another. For example, let parent = {hello: function(){console.log("hello");}}; let child = Object.create(parent); child.name = "child";. Test that child.hello() works (inherited from parent). Also verify child.hasOwnProperty('hello') is false (inherited, not own).
5. (Advanced) Implement a simple version of inherit function: Write a function inherit(childProto, parentProto) that sets up childProto to inherit from parentProto (basically does what Object.create(parentProto) would do and sets constructor). Use it to link two prototypes of constructors. (This is mainly for practice; in real code you'd use Object.create or class extends.)
18. Performance Tips
Writing efficient JavaScript can make a big difference in how responsive and smooth your web application feels, especially in complex applications or on lower-powered devices. Here are some performance considerations and tips:
Minimize DOM Access and Manipulation
Interacting with the DOM (reading or writing elements) is relatively slow compared to plain JavaScript operations. Each DOM query or update can trigger re-calculation of styles or layout. Tips: - Batch DOM updates: If you need to add a lot of elements, create a document fragment or build a string of HTML, then append it once, rather than adding elements one-by-one in a loop[19][20]. (Frequent appends cause multiple reflows.) - Example: Instead of appending 1000 list items in a loop to the DOM, build them in a DocumentFragment and append that fragment once[21][22]. - Cache DOM lookups: If you need the same element multiple times, get it once and store in a variable. Querying the DOM repeatedly (like document.getElementById("x") in a loop) wastes time. - Use efficient selectors: querySelector is powerful but if you're selecting thousands of elements, ID or class based methods might be slightly faster. In modern browsers, the difference is minor, but it's a consideration. - Avoid layout thrashing: Layout (reflow) happens when you measure DOM elements (like reading offsetHeight/width) or change their size. If you alternate reading and writing styles in series, you force repeated reflows. Try to group all DOM reads together and DOM writes together to allow the browser to optimize. - Simplify the DOM structure if possible: Deeply nested or very large DOM trees can be slower to update[23].
Optimize Loops and Algorithms
Choose right loops/iterators: For large data, a basic for-loop can be slightly faster than higher-order methods like forEach (due to function call overhead), but readability might suffer. Often these differences are tiny unless in a very hot loop.
Avoid unnecessary computations inside loops: e.g., computing arr.length on every iteration is unnecessary. Store it in a variable before the loop if the length isn't changing[24][25]. (Though modern JS engines might optimize this, it's a common tip).
Break out early: If searching, break the loop when found[5]. No need to traverse entire array if not needed.
Use performant data structures: If you do a lot of lookups, consider using a Map or object for O(1) access, rather than searching an array each time (O(n))[26][27].
Throttle/Debounce frequent events
Events like window resizing, scrolling, or mouse movement can fire many times per second. If you attach heavy computations to them, you can bog down the page. - Debouncing: Wait until the action stops for a certain time. E.g., for a search input field, you might wait 300ms after user stops typing before firing an AJAX request[28]. - Throttling: Ensure the handler runs at most once every X milliseconds, ignoring intermediate calls[29]. - Libraries or simple utility functions can help implement throttle/debounce (we saw an example earlier in performance excerpt)[28][29].
Web Workers for heavy computation
If you have to do expensive calculations, they can freeze the UI since JS runs on a single thread (the main thread). Web Workers allow you to run scripts in a separate background thread[30]: - Use a Worker for crunching large data sets, image processing, etc., so the main thread (UI) isn't blocked[31]. - Communication with workers is via message passing (postMessage), which is asynchronous.
Memory Leaks and Garbage Collection
JavaScript is garbage-collected, but it's still possible to accidentally cause memory leaks (memory that is no longer needed but isn't freed). - Remove event listeners you no longer need, especially if DOM elements are removed. Event handlers can keep references preventing garbage collection[32][33]. - Closures holding large structures can leak if not managed (e.g., if you attach a closure to something and forget to remove it when not needed). - Be mindful of global variables; they live for the life of the page and accumulate if not cleared.
Avoid blocking the main thread
Don't do synchronous waits (like long while loops). Use asynchronous techniques or break up work using setTimeout/queue microtasks to allow UI updates in between.
Network requests: use async (fetch/Ajax) so that fetching data doesn't block JS execution.
Use DevTools and profiling
Modern browsers have performance profilers. If your page is slow: - Use the Performance tab to record and see where time is spent. - Use the Timeline to see if you have frequent reflows or repaints. - Use memory profiling to see if objects are accumulating. - Use console.time() / console.timeEnd() around sections of code to measure them quickly during development[34].
Other micro-optimizations (less critical in most cases):
Avoid with (it's banned in strict mode anyway, and poor for performance).
Avoid eval() or new Function() unless absolutely needed; they are slow and a security risk[35].
Minimize use of synchronous XHR (which anyway is deprecated) or localStorage synchronously in critical paths because those can block.
Use CSS transitions/animations instead of heavy JS in intervals for animations when possible, as browsers can optimize those (e.g., requestAnimationFrame for smoother JS animations).
If doing canvas or visual heavy stuff, ensure you're not doing more work than necessary (clearing only regions that change, etc).
Example of performance improvement:
Suppose you have to add a thousand list items to a UL. A naive approach:
for(let i=0; i<1000; i++) {
  let li = document.createElement('li');
  li.textContent = 'Item ' + i;
  document.getElementById('list').appendChild(li);
}
This will manipulate the DOM 1000 times. Better:
let list = document.getElementById('list');
let fragment = document.createDocumentFragment();
for(let i=0; i<1000; i++) {
  let li = document.createElement('li');
  li.textContent = 'Item ' + i;
  fragment.appendChild(li);
}
list.appendChild(fragment);
Now the DOM is updated once (when appending the fragment)[36], and intermediate operations didn't constantly force reflow.
Another tip: Event delegation as we covered: Instead of 100 row elements each with a click handler (100 handlers), you might put one handler on the table parent and figure out which row was clicked using event.target. That reduces number of handlers and overhead of tracking them[37].
Remember: Premature optimization can be a pitfall. It's often best to write clear code first. Profile the application if you encounter slowness, then target the bottlenecks. Most of these tips become important when dealing with large amounts of data or complex interfaces, or if you notice a particular operation is slow.
Exercises: Performance
1. If you had to update the text of 100 DOM elements, why might it be beneficial to collect the new text in a single string and update innerHTML once, versus updating each element's textContent in a loop? (Think about reflow/layout cost.)
2. How does using requestAnimationFrame improve performance for animations compared to using setInterval or a tight loop?
3. Write a simple throttle function: function throttle(fn, limit) that returns a new function which calls fn at most once every limit milliseconds, ignoring calls in between. (Test by logging the event timestamp on a throttled scroll handler for example.)[29]
4. Consider an array of 10,000 items. What is generally faster: a for loop or array.forEach or for...of for iterating and summing them? Try reasoning or even writing a test in a JS environment to compare. (The differences might be small in modern engines, but a for loop is often marginally faster, though readability might be higher with forEach or for...of. In many cases, the difference is negligible relative to higher-level optimizations.)
5. (Advanced) If you find that a certain function is taking a lot of time (say sorting a large array or doing expensive calculations), what techniques could you use to avoid freezing the UI? (Possible answers: web workers to move it off main thread, break the work into smaller chunks and use setTimeout or requestAnimationFrame to schedule them, optimize the algorithm (e.g., use better sorting algorithm or data structure), etc.)
19. Best Practices
Finally, let's cover some general best practices and coding conventions that will help you write better, more maintainable JavaScript code:
Use Strict Mode
Always opt in to strict mode by placing "use strict"; at the top of your scripts or wrapping your code in an ES6 module or function that has strict mode. Strict mode catches common mistakes (like using an undeclared variable) and disables some problematic features. (In modules and classes, strict mode is automatic.)
Consistent Code Style
Indentation and formatting: Use consistent indentation (2 or 4 spaces commonly). Group and format code blocks for readability.
Semicolons: JavaScript has automatic semicolon insertion, but it's best to explicitly use semicolons to avoid edge-case pitfalls. (Though some style guides omit semicolons, it's safer as a beginner to include them.)
Naming conventions: Use camelCase for variables and functions (let userName; function doSomething() {}), PascalCase for constructors/classes (function Person() {} or class Person {}), and UPPER_SNAKE_CASE for constants (const MAX_LIMIT = 100;).
Meaningful names: Name variables and functions after their purpose. E.g., calculateAverage is better than calc or foo.
Avoid too short or too long names: Single-letter loop indices like i or j are fine for small loops, but in general be descriptive. But don't go overboard with extremely verbose names.
Commenting: Write comments for non-obvious code, complex algorithms, or important reasoning. But don't over-comment trivial things. Keep comments up-to-date if code changes.
Declare Variables Properly
Always declare variables with let or const. Never use an undeclared variable (which would create a global). In strict mode, using undeclared variables causes errors.
Declare variables at the top of their scope (function or block) if possible, to give a quick view of what's being used.
Use const for values that are not meant to be reassigned. This makes the code's intent clear and prevents accidental reassignment[12].
Avoid global variables if possible. They can conflict and are hard to track. Instead, wrap your code in functions or modules to keep variables local[38].
Avoid Duplication (DRY Principle)
DRY = Don't Repeat Yourself. If you find yourself writing similar code multiple times, consider refactoring into a function or a loop or a more general solution. Repeated code is harder to maintain (if a change is needed, you might forget one of the places).
Error Handling
Anticipate possible errors (e.g., invalid inputs, null values) and handle them gracefully. Use try...catch around code that can throw, especially asynchronous code inside async functions (with try/catch) or promise chains (with .catch).
Provide helpful error messages or fallback behaviors when something goes wrong, rather than letting the script crash or silently fail.
When debugging, console.error and console.warn can be used in development to output problems.
Use === for Comparison
Use the strict equality/inequality operators (=== and !==) instead of == and != to avoid type conversion issues[1]. - == performs type coercion: e.g., 0 == "0" is true, " " (empty string) == 0 is true (since empty string becomes 0). This can lead to unexpected truthiness. === avoids these by requiring both type and value to match[2]. - The only cases where == might be handy are checking against null (since null == undefined is true), but it's often clearer to explicitly check both or use == null if you intentionally want to allow both null and undefined.
Avoid Eval and new Function
eval() executes a string of code in the current scope, which is a security risk and usually not necessary[35]. It also is slow (the JS engine has to interpret the string each time). Instead of constructing code strings, try to use functions, object lookups, or other safer methods. Similarly, new Function("code") should be avoided unless absolutely needed (it creates a new function from string, similar issues to eval). In modern development, there's rarely a need for eval.
Keep Functions Focused
Each function should ideally do one thing or a closely related set of things, and do it well. This makes testing and reuse easier. If a function is very large or doing too many tasks, consider splitting it into smaller functions. Follow the Single Responsibility Principle at a moderate level: each module or object or function should have one main responsibility.
Avoid Polluting Prototypes (except polyfills)
While you can add methods to built-in prototypes (like Array.prototype.myMethod), doing so can be dangerous if not carefully done, because it affects all instances and can conflict with other code or future JS standards. Only time you might do it is to polyfill a missing feature (like adding Array.prototype.includes in an environment that lacks it, but usually you use libraries or polyfill scripts for that). For custom classes, adding to prototype is fine (that's how you define methods), but for built-ins, be cautious.
Modularize Code
If not using ES6 modules, you can use IIFEs or closure modules to avoid globals. With modules, prefer organizing code into logical modules and import/export, rather than one giant file. This aids maintainability and clarity.
Comment and Document
Use JSDoc or similar to document functions (especially public APIs): what they do, their parameters, return values, and side effects. This is more for larger projects, but even in small scripts, a short comment above a complex block of code can save time for you or others later.
Performance and Best Practice Overlap
Some best practices (like using ===, avoiding globals, etc.) incidentally also avoid performance issues or bugs. But note: writing clear code is more important than micro-optimizing everything. JS engines are quite fast. It's more important to avoid big inefficiencies (like heavy DOM thrash, memory leaks, etc.) than to save a nanosecond in a loop.
Linting Tools
Use a linter (like ESLint) with a style guide (like Airbnb's, Google’s, or StandardJS) to catch common issues and enforce style. Linters can warn about undeclared variables, unused variables, accidental assignments in conditions, etc. This can significantly reduce errors.
Testing
Though not a code style issue, best practice is to test your code. Write unit tests for key functions. Use console assertions or a testing framework to ensure your functions behave as expected with different inputs (including edge cases). For web, test across different browsers if targeting multiple (especially if using newer features with polyfills).
By following best practices, your code will be more robust (less bugs), easier to read and maintain, and likely more efficient. It's worth cultivating good habits early on, as it saves a lot of headache later.
Exercises: Best Practices
This is a bit open-ended, but consider these: 1. Identify issues in this snippet and suggest improvements:
x = 10
function foo(a, b) {
  if(a = b) {
    return;
  }
  for(i = 0; i < 5; i++) {
    // something
  }
}
(Issues: undeclared x and i (global leaks), the if uses assignment instead of comparison, no braces on if which can be error-prone, could use ===, etc.) 2. Write an example of a self-contained module pattern (if not using ES6 modules) using an IIFE that exposes a function but keeps some data private (to demonstrate avoiding global variables using closure). 3. Why is it recommended to declare all variables at the top of their scope? (One reason: hoisting can confuse if not, and it's clearer to see what's being used. Also prevents usage before declaration in non-strict which could be a bug.) 4. Show the difference between == and === with a couple of examples (like [] == false vs [] === false, or "" == 0 vs "" === 0) and explain why the strict version is usually preferable. 5. If a codebase is inconsistent in style (mixed use of var/let, inconsistent naming, etc.), what tools or approaches can help standardize it? (Answer: Linters like ESLint, prettier for formatting, adopting a style guide and perhaps auto-fixing with tools, code reviews focusing on consistency.)
20. Conclusion
Congratulations on making it through this comprehensive learning path for JavaScript! We've covered a lot of ground, from the basic syntax and core concepts all the way to advanced topics and best practices. By now, you should have a solid foundation to start building interactive web pages and applications using vanilla JavaScript.
What you've learned: - How to include and execute JavaScript in the browser. - Fundamental language features: variables, data types, operators, control flow (if/loops), and functions. - Data structures: arrays and objects, and how to manipulate them. - How to interact with the web page through the DOM: selecting elements, changing content/styles, creating elements, and removing them. - Handling user input and events to make pages interactive (buttons, forms, etc.). - The concept of asynchronous operations and how to handle them with callbacks, promises, and async/await – crucial for things like fetching data from a server without freezing the UI. - Modern ES6+ features that make coding more efficient and modern patterns like modules for code organization. - Deeper insights into how JavaScript works (closures, this, prototypal inheritance) which helps in writing more advanced code and understanding frameworks/library internals. - Performance considerations to keep your web app running smoothly, and general best practices to write clean, maintainable code.
Next steps: - Practice, practice, practice: The exercises provided are a starting point. Try building something from scratch. Maybe a to-do list app, a simple game, or a form that does calculations. Apply what you've learned; you'll solidify concepts and discover new questions. - Read documentation: The Mozilla Developer Network (MDN) is an excellent resource for JavaScript documentation and tutorials. If you're curious about a specific API or method, MDN likely has detailed info and examples. - Learn debugging: Use the browser DevTools to step through your code, inspect variables, and debug issues. Being proficient at debugging is as important as writing code. - Explore the ecosystem: Once comfortable with vanilla JS, you might explore libraries or frameworks (like React, Vue, Angular) which build on JS and help manage complex apps. But having vanilla JS knowledge will make learning them much easier. - Stay updated: JavaScript is evolving. New features (like optional chaining, etc. we mentioned) come in, and best practices evolve. Follow some JS blogs or communities. But don't worry, the core knowledge you have will remain relevant. - Back-end JavaScript: If interested, explore Node.js to run JS outside the browser (on servers). The syntax is the same, but you'll use different APIs (file system, network, etc.) and you'll see JS in a different context.
Remember that becoming proficient in JavaScript (or any programming language) takes time and continuous learning. Revisit topics that are complex (it's normal if things like closures or this feel tricky at first). With each project you build, you'll gain confidence and insight.
Keep experimenting, break things (in a good way!) and understand why they broke, and you'll become a better developer each day. Happy coding!
JavaScript for Frontend Web Development: A Complete Learning Path (Beginner to Advanced)
Table of Contents
Introduction
Getting Started: Running JavaScript in a Browser
Variables and Data Types
Operators and Expressions
Control Flow (Conditionals and Loops)
Functions
6.1. Arrow Functions
Arrays
Objects
DOM Manipulation (Interacting with the Web Page)
Event Handling
Working with Forms
Asynchronous JavaScript
12.1. Callbacks
12.2. Promises
12.3. Async/Await
Modern JavaScript (ES6+) Features
13.1. Block-Scoped Variables (let & const)
13.2. Template Literals
13.3. Destructuring and Spread/Rest
13.4. Classes (ES6 Classes)
Modules in JavaScript
Closures
The this Keyword
Prototypes and Inheritance
Performance Tips
Best Practices
Conclusion

1. Introduction
Welcome to the JavaScript Frontend Web Development learning path! This comprehensive guide will take you from a beginner with no knowledge of JavaScript to an advanced user capable of building interactive web pages with vanilla JavaScript (meaning we will not use frameworks or libraries, just plain JavaScript). JavaScript is the programming language of the web, enabling dynamic and interactive content in web pages. Whether you want to create image sliders, form validations, or entire web applications, mastering JavaScript is key.
In this learning path, we'll start with the very basics: understanding how to include and run JavaScript in a web page. We'll then move through fundamental programming concepts (variables, data types, functions, control flow, etc.), gradually introducing more complex topics (working with the DOM, handling user events, forms, asynchronous operations). By the end, we'll cover advanced concepts like closures, the prototype chain, and performance optimization tips. We'll also touch on modern JavaScript features (ES6 and beyond) and how to organize code using modules.
How to Use This Guide: It's structured in a logical sequence – each section builds on the previous ones. You'll find step-by-step explanations, annotated code examples, and exercises/mini-projects to practice what you've learned. The tone is beginner-friendly, so don't worry if some terms sound unfamiliar – everything will be explained in simple language. By following along and coding as you go, you'll gain hands-on experience.
Before we dive in, remember: practice is crucial. Try out the examples, attempt the exercises, and play with the code. JavaScript is best learned by doing. You can experiment in your browser's developer console or by writing HTML files and including your scripts – we'll show you how in the next section.
Alright, let's get started on your journey to mastering JavaScript for interactive web development!
2. Getting Started: Running JavaScript in a Browser
To begin writing and testing JavaScript, you don't need any special software – a web browser and a simple text editor will do. There are two common ways to run JavaScript in a browser:
Using the Browser Console: All modern browsers have a JavaScript console. You can open it (for example, in Chrome press F12 or right-click → "Inspect" and find the Console tab). In the console, you can type JavaScript commands and see immediate results. This is great for quick experiments or debugging.
Including JavaScript in an HTML File: Typically, you'll write JavaScript in a <script> tag within an HTML file, or in a separate .js file that you include via a <script src="..."> tag. The browser executes the JavaScript when the HTML page is loaded.
Let's try a quick example by creating a simple HTML file that runs a JavaScript "Hello World":
<!DOCTYPE html>
<html>
<head>
  <title>JS Test</title>
</head>
<body>

<h1 id="greeting">Hello</h1>

<!-- Include a script directly in HTML -->
<script>
  // This code runs when the page loads
  console.log("Hello from JavaScript!");  // This will print to the browser console
  document.getElementById("greeting").textContent = "Hello, World!";
  // The line above finds the <h1> element and changes its text content.
  alert("JavaScript is working!");  // This will pop up an alert in the browser
</script>

</body>
</html>
Save this as test.html and open it in a browser. You should see the heading text on the page change to "Hello, World!" and an alert message pop up, while "Hello from JavaScript!" is logged to the console. This demonstrates three things: - Using console.log() to output to the browser's console (useful for debugging). - Manipulating the page content via the DOM (we'll explain this more later). - Using alert() to show a message box (a simple way to output text to the user).
External JS Files: For larger scripts, it's often better to keep JavaScript in its own file. Create a file app.js and move your script code there. In the HTML, replace the script content with a src attribute:
<script src="app.js"></script>
This tells the browser to load and run the code from app.js. Make sure the script tag is placed at the end of the body or use the defer attribute in the <script> tag. Placing it at the end ensures the HTML elements are loaded before your script runs (so getElementById("greeting") finds the element). Alternatively, you can add the attribute defer to the script tag to achieve a similar effect (scripts with defer wait to execute until the HTML document is fully parsed).
Note: For now, we'll stick to writing scripts that run after the page loads. As you progress, you'll learn better techniques to structure and load scripts (like modules and the defer/async attributes for performance).
With our environment set up, let's start learning the fundamentals of the JavaScript language.
3. Variables and Data Types
Variables are used to store data values that can change (or vary) during the execution of your program. You can picture variables as containers or labeled boxes in memory that hold information. In JavaScript, you can create (declare) a variable using the keywords let, const, or (traditionally) var. In modern JavaScript, we prefer let and const for variable declarations, as they provide better scoping rules and help prevent certain bugs.
Declaring Variables
Use let for variables that you plan to change (their values will vary).
Use const for variables that you want to fix to a value (constant) and not reassign. This is great for values that shouldn't change, like configuration values or references to DOM elements.
Avoid using var in new code. var is the old way of declaring variables and has function-scoped (or global) behavior that can be confusing. let and const are block-scoped and generally safer.
Example of declaring variables:
let userName;            // declare a variable (initialized as undefined by default)
userName = "Alice";      // assign a value to the variable
console.log(userName);   // outputs "Alice"

let age = 25;            // declare and assign in one step
age = 26;                // reassign a new value
console.log(age);        // outputs 26

const birthYear = 1995;  // declare a constant
// birthYear = 1996;     // ERROR: cannot reassign a const variable
In the above snippet: - userName is declared then later assigned the string "Alice". - age is declared with initial value 25, then changed to 26. - birthYear is a constant and cannot be reassigned after the initial assignment.
Variable Naming Rules: You can name variables with letters, digits, $ or _, but the name cannot start with a digit. Names are case-sensitive (myVar vs myvar are different). It's good practice to use descriptive names (e.g., firstName instead of x) so your code is easier to understand. You should also avoid using JavaScript reserved words (like if, for, let, etc.) as variable names.
Data Types in JavaScript
JavaScript is a dynamically typed language, meaning a variable can hold any type of data and can even change type later. The main data types in JavaScript are:
Number: Used for all numerical values (integers, floats, etc.). Example: let count = 42;, let price = 19.99;. JavaScript does not differentiate between integer and floating-point – it's all just "Number". There are also special numeric values like Infinity, -Infinity, and NaN ("Not a Number", which is a result of invalid math operations).
String: Textual data enclosed in quotes (single '...' or double "..." quotes, or backticks `...` for template literals, which we'll cover later). Example: let city = "Singapore";.
Boolean: Logical true/false values. Example: let isLoggedIn = false; (only two boolean values: true and false).
Null: A special value meaning "no value". You can set a variable to null to indicate that it is intentionally empty or not set.
Undefined: This value means a variable has been declared but not assigned a value, or a function with no return returns undefined. By default, if you do let x; without assigning, x is undefined.
Object: A complex data type used to store collections of data or more complex entities. Objects can hold many values as properties. (We'll explore objects in detail later.)
Symbol: A unique and immutable value often used as an identifier (advanced use, we won't need it in basic sections).
BigInt: A numeric type for integers beyond the safe range of the Number type (useful for very large integers, introduced in ES2020). This is an advanced feature, so just be aware it exists.
For now, focus on Number, String, Boolean, Null, Undefined, and simple Objects/Arrays. These will cover the majority of use cases as you begin.
Examples of Data Types:
let score = 100;             // Number
let price = 49.99;           // Number (can be decimal)
let name = "Charlie";        // String (using double quotes)
let message = 'Hi there!';   // String (using single quotes)
let isOpen = true;           // Boolean
let notSet = null;           // Null (explicitly no value)
let x;                       // Undefined (declared but not assigned)
console.log(x);              // outputs undefined
You can use the typeof operator to check the type of a value or variable:
console.log(typeof score);    // "number"
console.log(typeof name);     // "string"
console.log(typeof isOpen);   // "boolean"
console.log(typeof notSet);   // "object"  (quirk: typeof null returns "object" due to a historical bug)
console.log(typeof x);        // "undefined"
A Note on Dynamic Typing
Because variables can change type, you must be careful with operations that might produce unexpected results. For example:
let data = "5";
console.log(typeof data);  // "string"
data = 5;
console.log(typeof data);  // "number"
JavaScript will also sometimes convert types implicitly when combining values:
let result = 5 + "7";      // "57" (number 5 becomes string "5" and concatenates with "7")
result = "5" * "3";        // 15 (strings "5" and "3" are converted to numbers for multiplication)
Generally, be mindful when mixing types. We'll cover more on operators and type conversion next.
Exercise: Variables and Types
1. Create a variable to store your name and another for your age. Print a greeting using both (for example: "Hello, my name is Alice and I am 25 years old.").
2. What happens if you add a number and a string in JavaScript? Try console.log(10 + "5"); and see the result and type. Can you explain why it happened?
3. Declare a variable with let without initializing it, log its value, then assign a value and log it again to observe the change.
4. Operators and Expressions
Operators are symbols or keywords that perform operations on values (operands). An expression is a combination of values, variables, and operators that computes to a value. JavaScript supports various types of operators:
Arithmetic Operators
Used for mathematical calculations: - + (addition): Adds numbers or concatenates strings. - - (subtraction) - * (multiplication) - / (division) - % (modulus): Remainder of division. For example, 7 % 3 is 1 (because 7 divided by 3 leaves remainder 1). - ** (exponentiation): For example, 2 ** 3 is 8 (2 to the power of 3).
Examples:
let a = 10;
let b = 3;
console.log(a + b);   // 13
console.log(a - b);   // 7
console.log(a * b);   // 30
console.log(a / b);   // 3.333...
console.log(a % b);   // 1
console.log(2 ** 4);  // 16 (2 to the power of 4)
String concatenation: The + operator also concatenates (joins) strings:
let firstName = "John";
let lastName = "Doe";
let fullName = firstName + " " + lastName;
console.log(fullName);  // "John Doe"
Be cautious: if one operand is a string, the + will convert the other to string (as we saw "5" + 7 became "57"). For numeric addition, ensure both operands are numbers or convert them explicitly.
Assignment Operators
Used to assign values to variables. The simple assignment is =. There are also compound assignment operators for convenience: - +=: Add and assign. (x += 5; is equivalent to x = x + 5;) - -=: Subtract and assign. - *= , /=, %=, **= similarly perform the operation and reassign.
Example:
let x = 10;
x += 5;  // now x is 15 (same as x = x + 5)
x *= 2;  // now x is 30 (same as x = x * 2)
Comparison Operators
Used to compare two values, yielding a Boolean (true or false): - == (equality) and != (inequality) – not recommended, because they perform type coercion before comparison. - === (strict equality) and !== (strict inequality) – check if values are equal (or not equal) without converting types[1]. Use these in practice to avoid unexpected results. For example, 5 == "5" is true (because "5" is converted to 5) but 5 === "5" is false (different types)[2]. - < (less than), > (greater than), <= (less or equal), >= (greater or equal).
Examples:
console.log(5 == "5");    // true (not strict, types differ but value coerced)
console.log(5 === "5");   // false (strict, different types)[2]
console.log(10 != "10");  // false (they are considered equal after coercion)
console.log(10 !== "10"); // true (10 is not equal to "10" when types considered)
console.log(7 < 3);       // false
console.log(7 > 3);       // true
console.log(5 <= 5);      // true
console.log(8 >= 10);     // false
Logical Operators
Operate on Boolean values (and expressions that result in booleans): - && (AND): a && b is true if both a and b are true. - || (OR): a || b is true if either a or b is true. - ! (NOT): !a is true if a is false (it inverts the boolean value).
These are useful for combining conditions (we'll see them in the next section with if-statements). They also have a property of short-circuiting: in a && b, if a is false, b is not evaluated (because the whole expression can't possibly be true). In a || b, if a is true, b is not evaluated (since it's already true regardless of b).
Example:
let n = 7;
console.log(n > 0 && n < 10);  // true (n is between 0 and 10)
console.log(n % 2 === 0 || n % 2 === 1);  // true (n is even or odd – which is always true for any integer!)
console.log(!(n === 7));  // false (n === 7 is true, !true is false)
Other Operators
Unary + and -: + can convert a value to a number (e.g., +"5" becomes 5), and - negates a number or can convert to number and negate (e.g., - "3" becomes -3).
++ / --: Increment or decrement. i++ increases i by 1 (returns the old value), ++i increases and returns the new value. Similarly for --.
let i = 0;
i++;
console.log(i);  // 1
++i;
console.log(i);  // 2
console.log(i--); // prints 2 (then i becomes 1)
console.log(--i); // i becomes 0, then prints 0
Use these with care to avoid confusion; you can always use i += 1 instead of i++ if preferred.
Ternary operator: A shorthand for if. Syntax: condition ? value_if_true : value_if_false. It evaluates the condition, and returns one of two values depending on the result.
let max = (a > b) ? a : b;  // if a > b, max = a, else max = b
Comma operator (,): Rarely used, allows multiple expressions where one is expected. It evaluates each operand (left to right) and returns the value of the last one. You likely won't need this as a beginner, and it can be confusing, so we won't focus on it.
Expressions: Whenever you use operators with values or variables, you form expressions. For example, 3 * (x + 2) is an expression that will be evaluated to some value depending on x. You can assign the result of an expression to a variable:
let result = 3 * (x + 2);
This computes the expression on the right and stores it in result.
Order of Operations: JavaScript follows typical operator precedence (similar to math). Multiplication and division happen before addition and subtraction, etc. You can always use parentheses ( ) to make the order explicit and ensure the intended calculation.
Exercise: Operators
1. Create two variables a and b with numeric values. Compute their sum, difference, product, and quotient, and log the results.
2. Use a comparison operator to check if a is greater than b and log the boolean result. Then check if they are equal using strict equality.
3. Try out the modulus operator: given an integer, determine if it's even or odd by checking number % 2. (Hint: if the remainder is 0, it's even.)
4. Write a small snippet using a ternary operator: For example, let access = (age >= 18) ? "Granted" : "Denied"; and test it with different age values.
5. Control Flow (Conditionals and Loops)
In programming, control flow refers to the order in which statements are executed and the ability to make decisions (branching) or repeat actions (loops). JavaScript provides several structures to control flow: if/else for branching, and various loops for repetition.
Conditional Statements: if, else if, else
The if statement allows you to execute code only if a certain condition is true. Optionally, you can include an else part to execute code when the condition is false.
Syntax:
if (condition) {
   // code to run if condition is true
} else if (otherCondition) {
   // (optional) code if the first condition was false, but another condition is true
} else {
   // (optional) code if none of the above conditions are true
}
The condition is an expression that is evaluated to a boolean (true/false). If it's true, the following block executes; if false, it skips to the next condition or else.
Example:
let temperature = 30;
if (temperature > 35) {
  console.log("It's really hot outside!");
} else if (temperature > 25) {
  console.log("It's warm outside.");
} else {
  console.log("It's cool or cold outside.");
}
In this example, if temperature is 30, the first condition (>35) is false, so it checks the else if: 30 > 25 is true, so it prints "It's warm outside." and then skips the else. If temperature were 40, it would print the first message; if it were 20, it would skip both if and else-if and run the else block.
Any expression can be a condition; JavaScript will convert it to boolean using its truthiness rules. Commonly, we compare values or call functions that return boolean. Remember to use strict comparisons (===, !==) for clarity and correctness when comparing values.
Truthy and Falsy Values
JavaScript has the concept of "truthy" and "falsy" values. In a boolean context (like an if condition), the following values are considered falsy: false, 0, "" (empty string), null, undefined, and NaN. Everything else is truthy. For example:
if ("hello") { console.log("This runs"); }      // "hello" is truthy (non-empty string)
if (0) { console.log("This will NOT run"); }    // 0 is falsy
Be careful relying on this implicit conversion; it's often clearer to explicitly compare (if (str !== "") instead of if (str), for instance).
The switch Statement
For multiple possible values of a variable, a switch can sometimes be cleaner than many else ifs. A switch checks a value against multiple case patterns:
let day = 3;
switch (day) {
  case 1:
    console.log("Monday");
    break;
  case 2:
    console.log("Tuesday");
    break;
  case 3:
    console.log("Wednesday");
    break;
  default:
    console.log("Unknown day");
}
Here, day is matched against the cases. Since day is 3, it will print "Wednesday". The break is important: without it, execution would continue into the next cases. The default case runs if none of the cases match. It's good practice to always include a default case to handle unexpected values (even if just for debugging)[3][4].
Loops
Loops allow repeating a block of code multiple times. JavaScript offers a few kinds of loops:
for loop: Ideal for running code a specific number of times or iterating over sequences.
while loop: Repeats as long as a condition remains true.
do...while loop: Similar to while, but ensures the loop runs at least once (condition is checked after one iteration).
for...of loop: A newer loop for iterating over iterable objects like arrays (we'll see in the array section).
for...in loop: Used for iterating over object properties (used less frequently, careful as it iterates enumerable properties including prototypes potentially).
for Loop
Syntax:
for (initialization; condition; finalExpression) {
   // code to run each loop iteration
}
- initialization: executed once at the start (e.g., let i = 0). - condition: checked before each iteration; loop runs while true. - finalExpression: executed at end of each iteration (e.g., i++ to increment a counter).
Example:
for (let i = 1; i <= 5; i++) {
  console.log("Counting: " + i);
}
This will print numbers 1 through 5. i starts at 1, and as long as i <= 5 is true, it runs the loop and then increments i by 1 each time.
while Loop
Executes as long as the condition remains true:
let j = 1;
while (j <= 5) {
  console.log("Counting: " + j);
  j++;
}
This will do the same as the for loop above. Be careful: if the condition never becomes false, you'll create an infinite loop. Always ensure something in the loop eventually makes the condition false (like incrementing j here).
do...while Loop
Runs the loop block once, then checks the condition:
let k = 1;
do {
  console.log("Counting: " + k);
  k++;
} while (k <= 5);
This will also print 1 to 5. The difference is that the condition is checked after the loop body, meaning the loop runs at least one time regardless of the condition initially.
Breaking out of Loops and Continuing
break: You can use break inside any loop (or switch) to exit immediately out of it. This is useful if you found what you were looking for and don't need to continue, for example.
continue: Skips the rest of the current loop iteration and moves to the next one.
Example:
for (let i = 1; i <= 10; i++) {
  if (i === 3) {
    continue;  // skip number 3
  }
  if (i === 7) {
    break;     // stop loop entirely when i is 7
  }
  console.log(i);
}
// This will print 1, 2, 4, 5, 6 and then stop.
Use these when needed to control loop flow. For instance, break is often used to exit early once a condition is met, which is also a performance optimization (no need to loop further)[5].
Looping over Arrays (intro)
We will discuss arrays in the next section, but a common pattern is:
let fruits = ["apple", "banana", "cherry"];
for (let index = 0; index < fruits.length; index++) {
  console.log(fruits[index]);
}
This iterates over the array by index. A more modern way is:
for (let fruit of fruits) {
  console.log(fruit);
}
The for...of loop directly gives you each element in the array without needing an index.
There are also array iteration methods like forEach, map, filter, etc., which are very useful: - array.forEach(function(element, index) { ... }) – calls the function for each element (doesn't return anything). - array.map(func) – creates a new array by applying func to each element. - array.filter(func) – creates a new array with only elements where func returns true. - array.find(func) – finds the first element where func returns true (for example, find an object in array by some property). - array.reduce(func, initialValue) – reduces the array to a single value (like summing all elements, etc.).
These are more advanced functional programming techniques. For now, knowing how to loop and basic push/pop operations is enough. But as a quick peek:
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(n => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

let evens = numbers.filter(n => n % 2 === 0);
console.log(evens);    // [2, 4]

let sum = numbers.reduce((acc, curr) => acc + curr, 0);
console.log(sum);      // 15 (adds all numbers, starting from 0)
We'll not dwell on these now, but it's good to be aware that such methods exist.
Exercise: Control Flow
1. Write an if...else statement that checks a variable score. If score is 90 or above, log "Grade: A"; if 80-89, log "Grade: B"; if 70-79, "Grade: C"; if 60-69, "Grade: D"; otherwise "Grade: F". (Try changing the score value to test each branch.)
2. Create a variable num. If it's positive, print "Positive", if it's negative print "Negative", and if it's zero print "Zero". Use an if, else if, else chain.
3. Use a for loop to calculate the sum of numbers from 1 to 100. (Hint: have a variable total initialized to 0, and loop i from 1 to 100, adding i to total each time. After the loop, total should be 5050.)
4. Use a while loop to find the first power of 2 greater than 1000. (In other words, multiply by 2 until the value exceeds 1000, then stop and print the value.)
5. Challenge: Create a simple "guess the number" routine. Choose a secret number (say 7). Use a loop to simulate guesses (either predetermined or random). For each guess, print "Too high", "Too low", or "Correct" and break out on correct. (This is just a thought exercise; in a real program, you'd get user input, but we haven't covered that yet.)
6. Functions
Functions are one of the most important concepts in JavaScript (and programming in general). A function is a reusable block of code designed to perform a particular task. You can define a function, then "call" it (execute it) multiple times with different inputs, rather than writing the same code over and over. Functions help organize code into logical pieces, avoid repetition, and make code more modular and readable.
Defining a Function (Function Declaration)
The basic syntax to declare a function is:
function functionName(parameter1, parameter2, ...) {
   // code to be executed when the function is called
   // optional: return some value
}
- functionName: the name you give to the function (like a variable, follows similar naming rules). - parameters: placeholders for values that will be passed into the function. - Inside the braces {}, you write the code that runs when the function is called. - A function can optionally use a return statement to send back a result. When return is executed, the function stops and returns that value to the caller.
Example:
function greet(name) {
  console.log("Hello, " + name + "!");
}
This function greet takes one parameter, name, and logs a greeting. It doesn't return a value (so it implicitly returns undefined).
To use (call) the function:
greet("Alice");   // prints "Hello, Alice!"
greet("Bob");     // prints "Hello, Bob!"
Each call executes the function body with the given argument in place of the parameter.
Let's look at a function that returns a value:
function add(x, y) {
  return x + y;    // returns the sum of x and y
}

let result = add(2, 3);
console.log(result);  // 5
console.log(add(10, 5));  // 15 (directly log the returned value)
The add function computes x + y and returns it. We can capture that result in a variable or use it directly.
Important: Code after a return in a function will not execute, as the function exits immediately on return.
Functions can access variables defined outside of them (this is called lexical scope), but it's generally best to rely on parameters and return values for input and output to keep functions self-contained and reusable.
Function Expressions
In JavaScript, functions are first-class citizens; you can treat them like any other value. A function expression is when you define a function and assign it to a variable:
let sayHi = function(name) {
  console.log("Hi, " + name);
};
sayHi("Charlie");  // "Hi, Charlie"
Here we created an anonymous function (no name after the function keyword) and assigned it to sayHi. We then call it via the variable. Function expressions are useful for passing functions as arguments to other functions, or for closures (more on that later).
There's also a concept of Immediately Invoked Function Expressions (IIFE) where a function is defined and called right away, but you won't need that immediately, and it's less common in modern code due to modules.
Arrow Functions (ES6)
Arrow functions are a shorter syntax for writing function expressions and also have some different behavior with this (which we'll discuss separately). An arrow function looks like:
const multiply = (a, b) => {
  return a * b;
};
This defines a function multiply that returns the product of a and b. For a simple one-liner, you can even omit the {} and return:
const multiplyShort = (a, b) => a * b;
If there's only one parameter, you can omit parentheses around it: n => n * 2 is a function that doubles a number. If there are no parameters, use () => ....
Arrow functions are often used for callbacks or short functions. They have the benefit of being more concise. However, they do not have their own this context (they inherit this from the surrounding lexical scope)[6], and they cannot be used as constructors. For regular usage where you don't need the special behaviors of a normal function, arrow functions are great for brevity.
Parameters and Arguments
You can define functions with multiple parameters, or none at all. If a function is called with fewer arguments than parameters, the missing parameters will be undefined inside the function. If it's called with more arguments, the extra arguments can be accessed via the arguments object in a normal function (or simply ignored, or handled via rest parameters which we'll cover later).
Example:
function describePerson(name, city) {
  console.log(name + " lives in " + city);
}
describePerson("Alice", "Paris");             // "Alice lives in Paris"
describePerson("Bob");                        // "Bob lives in undefined" (city was not provided)
describePerson("Charlie", "London", 25);      // "Charlie lives in London" (25 is extra, not used)
To handle default values, you can check inside the function or use ES6 default parameters:
function describePerson(name, city = "an unknown place") {
  console.log(name + " lives in " + city);
}
describePerson("Bob");  // "Bob lives in an unknown place"
Default parameters are a nice feature that assigns a default if an argument is missing or undefined.
Scope and Local Variables
Variables declared inside a function (using let or const or var) are local to that function. You cannot access them from outside. Conversely, a function has access to variables in outer scopes (this is a closure feature, which we'll elaborate on later). Generally, using local variables inside functions and passing things in/out via parameters and return values is the best practice.
Functions as Values
Since functions are values, you can pass them to other functions or return them from functions. For example:
function callTwice(func) {
  func();
  func();
}
function laugh() {
  console.log("Haha!");
}
callTwice(laugh);  // will print "Haha!" twice
We passed the function laugh as an argument to callTwice. This is powerful and allows callback patterns, event handling, etc., which you'll see a lot in JavaScript.
Exercise: Functions
1. Write a function square(num) that returns the square of a number (num * num). Test it with a few values (e.g., square(4) should return 16).
2. Write a function isEven(number) that returns true if the number is even, and false otherwise. Use the % operator to test evenness. Try it on a few numbers.
3. Create a function toCelsius(fahrenheit) that converts Fahrenheit to Celsius. Formula: C = (F - 32) * 5/9. Then create toFahrenheit(celsius) to do the reverse. Test with known values (e.g., 32°F = 0°C, 100°C = 212°F).
4. Write a function max(a, b, c) that returns the largest of three numbers a, b, c. (Hint: you can use a series of if/else or use Math.max in a smart way, but try the logic yourself.)
5. (Advanced) Write a function countChars(str, char) that counts how many times a given character char appears in the string str. For example, countChars("Hello", "l") should return 2. (Hint: loop through the string or use string methods. This will make use of concepts from loops and conditionals as well.)
6.1 Arrow Functions (More Examples)
To reinforce arrow functions: let's convert a couple of the above functions to arrow syntax:
const square = num => num * num;
console.log(square(5)); // 25

const isEven = number => number % 2 === 0;
console.log(isEven(10)); // true
console.log(isEven(7));  // false
If an arrow function needs multiple statements or you want to use a return, you use the {} block:
const maxOfTwo = (a, b) => {
  if (a > b) return a;
  return b;
};
console.log(maxOfTwo(3, 7)); // 7
This arrow function has a couple of statements, so we wrapped them in braces and explicitly returned a value.
Remember, arrow functions inherit their surrounding this value and cannot be used as constructors (you cannot do new myArrowFunction()), but for most purposes (especially for short callback functions), they are extremely convenient.
Next, we'll move to data structures like arrays and objects to handle collections of values.
7. Arrays
An array is a type of object in JavaScript that is used to store a list of values. Arrays are ordered, zero-indexed collections – meaning each item has an index starting from 0 (first item is index 0, second is index 1, etc.). Arrays are great for storing sequences of data (e.g., lists of names, numbers, etc.) and iterating over them.
Creating and Using Arrays
You can create an array using square brackets []:
let fruits = ["Apple", "Banana", "Cherry"];
Here we have an array with 3 string elements. Arrays can hold any type, and you can mix types (though usually they hold a consistent type of elements):
let mixed = [42, "hello", true, null];
This array has a number, a string, a boolean, and a null.
Accessing elements: Use bracket notation with the index:
console.log(fruits[0]);  // "Apple"
console.log(fruits[2]);  // "Cherry"
If you use an index that doesn't exist (e.g., fruits[5] in our case), you'll get undefined.
Modifying elements: You can reassign values at specific indices:
fruits[1] = "Blueberry";
console.log(fruits);  // ["Apple", "Blueberry", "Cherry"]
Array length: Every array has a length property indicating the number of elements:
console.log(fruits.length);  // 3
Be careful: last valid index is length - 1 (since index starts at 0). If an array is empty, length is 0.
Common Array Operations (Methods)
JavaScript arrays come with many built-in methods to manipulate them. Here are essential ones:
push(item) – add an item to the end of the array. Returns the new length.
pop() – remove the last item from the array and return it.
unshift(item) – add an item to the beginning of the array.
shift() – remove the first item from the array and return it.
indexOf(item) – search for an item and return its index (or -1 if not found).
includes(item) – returns true if the item is present in the array.
slice(start, end) – returns a new array with a copy of a portion of the array (does not modify original). start index is inclusive, end is exclusive.
splice(start, deleteCount, ...items) – powerful method to remove or insert elements. It modifies the original array. For example, arr.splice(2, 1) removes 1 element at index 2. arr.splice(1, 0, "x") inserts "x" at index 1 without removing any (second parameter 0).
join(separator) – join all elements into a string with separator between.
reverse() – reverse the array in place.
sort() – sort the array (by default, lexicographically as strings; you can pass a comparison function for numeric or custom sorts).
Let's see some in action:
let nums = [10, 20, 30];
nums.push(40);
console.log(nums);        // [10, 20, 30, 40]
let last = nums.pop();
console.log(last);        // 40 (removed element)
console.log(nums);        // [10, 20, 30]

nums.unshift(5);
console.log(nums);        // [5, 10, 20, 30]
let first = nums.shift();
console.log(first);       // 5
console.log(nums);        // [10, 20, 30]

console.log(nums.indexOf(20));   // 1 (20 is at index 1)
console.log(nums.includes(20));  // true
console.log(nums.includes(40));  // false

let sub = nums.slice(1, 3);
console.log(sub);         // [20, 30] (elements from index 1 up to 3, not including 3)
console.log(nums);        // [10, 20, 30] (original unchanged)

nums.splice(1, 1, 15, 17);
// At index 1, remove 1 element (the 20), and insert 15 and 17 in its place
console.log(nums);        // [10, 15, 17, 30]

console.log(nums.join(", "));    // "10, 15, 17, 30"

nums.reverse();
console.log(nums);        // [30, 17, 15, 10] (array is now reversed)
nums.sort();
console.log(nums);        // [10, 15, 17, 30] (sorted as numbers; actually sort as strings by default but these are fine)
A note on sort(): By default, sort converts elements to strings and compares lexicographically (dictionary order). For example, [2, 30, 100].sort() yields [100, 2, 30] as strings! To sort numbers properly, you pass a compare function:
let arr = [2, 30, 100];
arr.sort((a, b) => a - b);
console.log(arr);  // [2, 30, 100] (now correct numerically)
We sort ascending by subtracting (if a-b is negative, a comes first, etc.).
Iterating Over Arrays
We often use loops to go through array elements:
let cars = ["Toyota", "Honda", "Tesla"];
for (let i = 0; i < cars.length; i++) {
  console.log(cars[i]);
}
This prints each car brand. As mentioned earlier, we can use a for...of loop for convenience:
for (let car of cars) {
  console.log(car);
}
This does the same without needing an index.
There are also array iteration methods as noted: forEach, map, filter, etc. For completeness:
cars.forEach((car, index) => {
  console.log(index + ": " + car);
});
That would log "0: Toyota", "1: Honda", "2: Tesla".
And map example we showed earlier (to create a new transformed array), or filter to pick a subset. These functional methods are very useful as you get comfortable.
Array and String relationship
Strings can be thought of as arrays of characters (though they are immutable). You can do some array-like operations on strings: e.g., str.split(",") to split into an array, or array join to make a string. And you can access characters by index: "hello"[1] gives "e". But note, strings are immutable, meaning you cannot change a character by index (you'd have to create a new string).
Exercise: Arrays
1. Create an array of several of your favorite foods. Then:
a. Log the number of items (length).
b. Log the first and last item.
c. Add a new food to the end using push.
d. Remove the first food using shift.
e. Print the modified array.
2. Given an array of numbers, e.g. let values = [8, 3, 12, 5, 22], write code to find the largest number. (Try it with a loop, or sort the array and take the last element).
3. Write a function sumArray(arr) that returns the sum of all numbers in an array. Use a loop to accumulate the sum. Test it on a few arrays.
4. Use an array to store a sequence of numbers 1 to 10, then use a loop to print out only the even numbers from the array.
5. (Advanced) Write a function removeDuplicates(arr) that takes an array and returns a new array with duplicates removed. (Hint: You can use a second array to push items that haven't been seen, or use includes to check before adding. Or more advanced, use a Set, but that might be beyond scope here.)
8. Objects
Objects are the heart of JavaScript. An object in JavaScript is a collection of key-value pairs, where each key (also called a property name) maps to a value. The value can be of any type: primitive (number, string, etc.), another object, a function (in which case it's called a method of the object), and so on. Objects allow you to group related data and functions together, modeling real-world entities and structures.
Creating Objects
The easiest way to create an object is using object literal syntax with curly braces {}:
let person = {
  name: "Alice",
  age: 30,
  city: "Singapore"
};
This defines an object person with three properties: name, age, and city. Each property has a value.
You can also start with an empty object and add properties:
let car = {};
car.brand = "Toyota";
car.model = "Corolla";
car.year = 2010;
But usually literal initialization is cleaner when you know the properties upfront.
Accessing Object Properties
There are two ways to access (read or write) properties: dot notation and bracket notation.
Dot notation: objectName.propertyName
Bracket notation: objectName["propertyName"]
Example:
console.log(person.name);       // "Alice"
console.log(person.age);        // 30

person.age = 31;                // update age
person.country = "Singapore";   // add new property
console.log(person.country);    // "Singapore"
Using bracket notation:
console.log(person["name"]);    // "Alice"
let prop = "city";
console.log(person[prop]);      // "Singapore" (because prop was "city")
Bracket notation is useful when property name is in a variable or not a valid identifier (e.g., has a space or starts with a number, though those are not common cases). Most of the time, you'll use dot notation for standard property names.
If you try to access a property that doesn't exist, you get undefined. You can check for existence using the in operator or by comparing to undefined:
if ("age" in person) {
  console.log("Age is", person.age);
}
if (person.job === undefined) {
  console.log("job is not defined in person.");
}
Methods (Functions on Objects)
Functions can be stored in object properties. When a function is a property of an object, we call it a method of that object. Methods typically perform actions related to that object.
Example:
let calculator = {
  x: 10,
  y: 20,
  add: function() {
    return this.x + this.y;
  }
};
console.log(calculator.add());  // 30
Here calculator.add is a function that uses this.x and this.y. The keyword this inside an object method refers to the object itself (the one that the method was accessed on)[7]. In the example, inside add, this refers to calculator, so this.x is calculator.x.
We could add another method:
calculator.multiply = function() {
  return this.x * this.y;
};
console.log(calculator.multiply()); // 200
Notice how we define functions: we can use the function keyword or, in shorthand (ES6), define methods without the function keyword:
let person2 = {
  name: "Bob",
  greet() {
    console.log("Hi, I'm " + this.name);
  }
};
person2.greet(); // "Hi, I'm Bob"
This is equivalent to greet: function() { ... } but shorter. Using this.name inside the method accesses the name property of the same object.
We'll discuss this more in the dedicated section, because understanding its behavior is crucial (especially in different contexts and with arrow functions).
Iterating over Object Properties
If you need to inspect all properties of an object, you can use a for...in loop:
for (let key in person) {
  console.log(key + ": " + person[key]);
}
This will print each property name and value in person. However, for...in will also iterate over inherited properties (from the prototype chain). To ensure it's the object's own property, you can use person.hasOwnProperty(key). But for most straightforward uses on plain objects, for...in is fine.
Modern JS also has Object.keys(person) which returns an array of own property names, or Object.entries(person) for an array of [key, value] pairs, and Object.values(person) for values.
Example:
console.log(Object.keys(person));   // ["name", "age", "city", "country"]
console.log(Object.values(person)); // ["Alice", 31, "Singapore", "Singapore"]
Nested Objects and Arrays
Objects can contain other objects or arrays as values, enabling you to model complex data:
let company = {
  name: "TechCorp",
  address: {
    street: "123 Main St",
    city: "Metropolis"
  },
  employees: [
    { name: "Alice", role: "Developer" },
    { name: "Bob", role: "Designer" }
  ]
};
Here, company.address is itself an object with its own properties, and company.employees is an array of objects. You can access nested data like:
console.log(company.address.city);         // "Metropolis"
console.log(company.employees[1].role);    // "Designer"
Understanding how to traverse nested structures is important for working with JSON data or configuration objects, etc.
Object vs Array: When to use what?
Use arrays for ordered collections of items (especially if they are of the same type/kind of thing). Use objects for named properties, representing a concept or entity with various attributes. Sometimes you might use an array of objects (like employees above) to represent multiple entities.
Special Objects: Math, Date, etc.
JavaScript has some built-in objects like Math (with properties and methods for mathematical constants and functions, e.g., Math.PI, Math.max(), Math.random()) and Date for dealing with dates and times. You create a date with new Date(), for example:
let now = new Date();
console.log(now.getFullYear()); // prints the current year
These are beyond just object literal usage, but it's good to know they exist as utility objects.
Exercise: Objects
1. Create an object book with properties: title, author, year. Then:
a. Log the title and author.
b. Add a new property publisher.
c. Change the year property to a new value.
d. Log the updated object.
2. Create an object rectangle with properties width and height. Add a method area that returns the area (width * height). Test the method. Add another method perimeter that returns 2*(width+height). Test it.
3. Write a function printContact(person) that takes a person object (with name and phone properties) and prints something like "Name: Alice, Phone: 123-4567". Try it with a couple of person objects.
4. Make an object counter with a property count (starting at 0) and methods increment() (add 1 to count), decrement() (minus 1), and reset() (set count to 0). Use this.count inside methods to access the current count. Test calling these methods and check counter.count.
5. (Advanced) Nested object challenge: Create an object library that has a property books which is an array of book objects (each book has title, author). Add a method findBook(title) on library that returns the book object with the matching title, or null if not found. Test it by adding a few books to the library and searching for some titles.
9. DOM Manipulation (Interacting with the Web Page)
One of the main things that makes JavaScript powerful in the browser is the ability to interact with the DOM. The DOM (Document Object Model) is a representation of the HTML document as a tree of objects (nodes). Every element in HTML (like paragraphs, buttons, divs, etc.) becomes a node in this tree that JavaScript can access and manipulate. By using JavaScript to alter the DOM, you can change the content, structure, and style of the page on the fly, enabling interactive experiences.
The document Object
The document global object is the entry point for DOM manipulation. It represents the web page loaded in the browser.
Commonly used document methods to select elements: - document.getElementById("id") – Selects a single element with the given id. - document.getElementsByClassName("class") – Selects all elements with the given class (returns an HTMLCollection, which is array-like). - document.getElementsByTagName("tagName") – Selects elements by tag name (e.g., "div", "p"). - document.querySelector(cssSelector) – Selects the first element that matches a CSS selector (e.g., #id, .class, div > p, etc.). - document.querySelectorAll(cssSelector) – Selects all elements that match the CSS selector (returns a NodeList, which can be iterated).
querySelector and querySelectorAll are very powerful because you can use any CSS selector. For example:
let mainTitle = document.getElementById("main-title");
let items = document.getElementsByClassName("item");
let firstParagraph = document.querySelector("p");
let allParas = document.querySelectorAll("p");
let special = document.querySelector(".container > .special");
These assume the HTML has elements corresponding to those selectors.
Manipulating Content and Attributes
Once you have a reference to a DOM element, you can manipulate it. For example, if you selected an element as let elem = document.getElementById("main-title"), you can: - Change its text content: elem.textContent = "New Title";. This sets the textual content inside the element (without HTML). - Change its HTML content: elem.innerHTML = "<span>New</span> Title";. This interprets the string as HTML, so use it carefully (especially with user input to avoid security issues). - Change or read an attribute: e.g., elem.id (to get or set the id), elem.src for an image src, elem.href for a link, or generic elem.getAttribute("attrName") / elem.setAttribute("attrName", value). - Change CSS styles: elem.style.color = "red"; or elem.style.fontSize = "20px"; etc. You can manipulate any CSS property via the style object (in camelCase form). - Change classes: elem.className = "highlight" (sets the class string), or better, use elem.classList which provides methods like add, remove, toggle:
elem.classList.add("active");
elem.classList.remove("hidden");
elem.classList.toggle("open");
- Remove or create elements (see below).
Example:
<h1 id="main-title">Welcome</h1>
<p class="desc">Hello, <span id="name">friend</span>!</p>
let title = document.getElementById("main-title");
title.textContent = "Welcome to My Site";  // update text

let nameSpan = document.getElementById("name");
nameSpan.textContent = "Alice";            // change "friend" to "Alice"

let descPara = document.querySelector(".desc");
descPara.style.color = "blue";             // change text color of the paragraph
descPara.style.fontWeight = "bold";        // make it bold via inline style
Creating and Removing Elements
You can dynamically create new elements and add them to the DOM, or remove existing ones:
Create element: document.createElement("tagName") creates a new element object. E.g., let newDiv = document.createElement("div");.
Set its content or attributes: e.g., newDiv.textContent = "Hello"; or newDiv.id = "section1";.
Append to the DOM: Use a method like parent.appendChild(newElement) or parent.append(...children) to add the element as a child of a parent node. There's also parent.insertBefore(newElem, referenceElem) to insert in a specific position.
Remove an element: If elem is a DOM node, elem.remove() will remove it from its parent. Alternatively, parent.removeChild(child) if older browser support needed.
Example:
// Create a new list item and add to a ul with id "todoList"
let todoList = document.getElementById("todoList");
let newItem = document.createElement("li");
newItem.textContent = "Learn DOM manipulation";
todoList.appendChild(newItem);
This assumes <ul id="todoList"> exists in HTML. Now it will have a new <li> at the end.
To remove:
newItem.remove();  // this will remove the item we just added
Or:
todoList.removeChild(todoList.firstElementChild);  // remove first <li>
DOM Tree Navigation
From a given DOM node, you can navigate: - elem.parentElement – the parent node (element) in the DOM tree. - elem.children – a collection of child elements (ignores text nodes). - elem.firstElementChild, elem.lastElementChild – first and last child element. - elem.nextElementSibling, elem.previousElementSibling – adjacent siblings in the DOM (elements only). - There's also older elem.childNodes (includes text nodes, comments, etc.) but most often children and related are sufficient.
Example:
<ul id="menu">
  <li>Home</li>
  <li id="about">About</li>
  <li>Contact</li>
</ul>
let aboutItem = document.getElementById("about");
console.log(aboutItem.parentElement.id);         // "menu" (the ul)
console.log(aboutItem.previousElementSibling.textContent);  // "Home"
console.log(aboutItem.nextElementSibling.textContent);      // "Contact"
This shows how to traverse relative to an element.
Putting it together – an example mini-project
Let's demonstrate a small dynamic behavior: imagine you have a list of items and a button to add a new item.
<h2>Tasks</h2>
<ul id="tasks">
  <li>Buy groceries</li>
  <li>Call Alice</li>
</ul>
<button id="addTaskBtn">Add Task</button>
Now some JavaScript:
let tasksUl = document.getElementById("tasks");
let addBtn = document.getElementById("addTaskBtn");

addBtn.addEventListener("click", function() {
  // when button is clicked, prompt for a new task and add to list
  let newTask = prompt("Enter a new task:");
  if (newTask) {  // if user entered something (prompt returns null if cancelled)
    let li = document.createElement("li");
    li.textContent = newTask;
    tasksUl.appendChild(li);
  }
});
Here we've introduced the concept of an event listener (we'll cover events in the next section). When the button is clicked, we use prompt() to get input from the user (a simple way to get input; not pretty but works for demonstration). Then if a string was provided, we create a new <li> element, set its text, and append it to the <ul>. This dynamically updates the page with a new list item.
We also see reading user input and altering the DOM accordingly.
Note: prompt() and alert() are basic blocking dialogs. In practice, you might instead have an <input> field or form to get user input for adding tasks. But for quick demos, prompt is fine.
Exercise: DOM Manipulation (These exercises assume you have an HTML document to play with.) 1. Create a simple HTML page with a <div id="box" style="width:100px; height:100px; background:red;"></div> and a button <button id="toggleBtn">Toggle</button>. Using JavaScript, make it so that clicking the button toggles the visibility of the red box (hint: you can toggle a CSS class like "hidden" that sets display: none, or toggle the inline style box.style.display).
2. Add an input field <input id="nameInput" type="text"> and a button <button id="helloBtn">Say Hello</button> to the page. Write JS so that when the button is clicked, it reads the value from the input and then displays a greeting message in a new <p> or in an existing <p id="greetMsg">Hello, [name]!</p>. (If the input is empty, maybe show an error or do nothing.)
3. Make a simple image carousel: have an <img id="photo"> element on the page and two buttons "Next" and "Prev". In JS, have an array of image URLs. When Next is clicked, change the src of the image to the next URL in the array (and wrap around at the end). Similarly for Prev. (This practices changing element attributes and using event listeners, coming up next.)
4. (Advanced) Create a list of items in HTML, e.g., <ul id="list"><li>Item 1</li><li>Item 2</li></ul>. Add a button "Remove Last Item". When clicked, remove the last <li> from the list (if there is one). Also add a button "Add Item", which adds a new <li> with a random or sequential name ("Item 3", "Item 4", etc.). This tests creating and removing DOM nodes.
5. (Advanced) Create a small HTML form: <input type="text" id="todoText"> and <button id="addTodo">Add</button> and an empty <ul id="todoList"></ul>. When the button is clicked, take the text, create a new <li> with that text and add to the list, then clear the input. Also, each added list item could have a "Done" button appended to it that, when clicked, removes that item from the list (hint: use event delegation or attach event when creating the element).
10. Event Handling
Web pages become interactive largely through events. An event is an action or occurrence such as a user clicking a button, typing in a field, moving the mouse, submitting a form, or a page finishing loading. JavaScript can listen for these events and run code (event handlers) in response, allowing us to create interactive behaviors.
Adding Event Listeners
The modern way to handle events is by using addEventListener. This method can be called on any DOM element (and even the document or window objects) to register a callback function for a specific event type.
Syntax:
element.addEventListener(eventType, handlerFunction);
- eventType is a string like "click", "input", "submit", "mouseover", etc. (There are many event types.) - handlerFunction is the function to execute when the event fires. This can be a named function or an anonymous function (or arrow function). You can also pass an options object or use a third parameter for things like once or capture, but by default it's fine.
Example:
<button id="myButton">Click me</button>
let btn = document.getElementById("myButton");
btn.addEventListener("click", function() {
  console.log("Button was clicked!");
});
Now whenever the button is clicked, the message will log. We can also change content or style:
btn.addEventListener("click", function() {
  btn.textContent = "Clicked!";
  btn.style.backgroundColor = "green";
});
This will change the button text and color on click.
Common events: - Mouse events: "click", "dblclick", "mouseup", "mousedown", "mouseover", "mouseout", "mousemove". - Keyboard events: "keydown", "keyup", "keypress" (though keypress is somewhat deprecated in favor of keydown/keyup). - Form/input events: "input" (fires when text is entered in inputs), "change" (fires when an input loses focus after change, or on selection changes), "submit" (form submission), "focus", "blur. - Document events: "DOMContentLoaded" (when initial HTML parsed), "load" (when all resources loaded), "scroll", "resize on window, etc.
The Event Object and this in Handlers
When an event happens, the browser provides an event object to the handler function. We can accept it as a parameter:
btn.addEventListener("click", function(event) {
  console.log("You clicked at coordinates:", event.clientX, event.clientY);
});
The event object has properties and methods related to the event. For example, in a click event: - event.clientX, event.clientY: coordinates of the click relative to the viewport. - event.target: the element that triggered the event (often the same as this inside the handler when using function, but not for arrow functions). - event.preventDefault(): a useful method to cancel the default browser action for that event (like preventing a form from submitting or a link from navigating). - event.key in a keyboard event gives which key was pressed, etc.
this in event handlers: If you use a normal function as the handler, inside it this will refer to the element that the event is attached to (the element that received the event)[17]. For example:
btn.addEventListener("click", function() {
  console.log("Clicked button id:", this.id);
});
this.id would give "myButton". However, if you use an arrow function, this is not bound to the element (it will use the enclosing this, which could be something else or undefined in strict mode)[6]. In arrow function handlers, use event.target or just reference the element from outer scope if needed. Usually, using this with regular function is fine for event handlers.
Removing Event Listeners
If needed, you can remove an event listener using removeEventListener, but you need to have the handler function reference to remove:
function handleClick() {
  console.log("Handled");
}
btn.addEventListener("click", handleClick);
// ...later:
btn.removeEventListener("click", handleClick);
This removes that specific listener. (Note: if you had added an anonymous function, you can't remove it easily since you don't have a reference to the exact function object.)
Event Propagation (Bubbling and Capturing) and Delegation
By default, most events bubble up the DOM tree. That means if you click a button inside a div, the click event first triggers on the button, then on its parent (the div), then maybe on the body, up to the document. You can catch that event on a parent if you want.
Event delegation is a common pattern where you attach a single event listener on a parent element, and handle events for its child items within that listener. This is useful for lists or tables where adding individual listeners to many items can be inefficient. For example:
<ul id="menu">
  <li data-item="home">Home</li>
  <li data-item="about">About</li>
  <li data-item="contact">Contact</li>
</ul>
Instead of adding click to each li, we do:
let menu = document.getElementById("menu");
menu.addEventListener("click", function(event) {
  if (event.target.tagName === "LI") {
    let item = event.target.getAttribute("data-item");
    console.log(item + " clicked");
    // do something based on item
  }
});
Here, when any <li> is clicked, the event bubbles to the #menu ul, and we catch it there. We check event.target to see if it was an LI (the target of the click). We used a custom data-item attribute to know which item. This way, one listener handles all items. If we later add more <li> inside ul (perhaps dynamically), the listener still works, without needing to add new listeners.
Event propagation can be controlled: event.stopPropagation() can stop the event from bubbling further up (or capturing down). And by adding a third argument to addEventListener {capture: true} you can catch events on the way down (capturing phase). Typically, though, for most uses, the default bubbling is fine.
Default Actions and preventDefault
Some events have default browser actions: e.g., clicking a link navigates, submitting a form sends it to the server, pressing "enter" in a text field might submit a form, etc. If you want to prevent those, you call event.preventDefault() in your handler:
document.querySelector("a#myLink").addEventListener("click", function(e) {
  e.preventDefault();
  console.log("Link click intercepted, not navigating");
});
Now clicking that link will not actually navigate.
Similarly, for a form:
form.addEventListener("submit", function(e) {
  e.preventDefault();
  // validate inputs, then maybe send via AJAX instead
});
Using preventDefault is crucial when handling form submissions via JavaScript to stop the page from reloading.
Example: Changing content on a button click
We saw an example earlier of adding a task on a button click. Let's do another quick one: a button that toggles dark mode for the page.
HTML:
<button id="modeToggle">Dark Mode</button>
CSS:
.dark {
  background-color: black;
  color: white;
}
JS:
let modeBtn = document.getElementById("modeToggle");
modeBtn.addEventListener("click", function() {
  document.body.classList.toggle("dark");
  if (document.body.classList.contains("dark")) {
    modeBtn.textContent = "Light Mode";
  } else {
    modeBtn.textContent = "Dark Mode";
  }
});
What this does: - On button click, it toggles the "dark" class on the body element. The CSS class changes the appearance. - It also changes the button text accordingly to indicate the mode.
This is a typical pattern for theme toggling. It shows classList toggling and reading classList state.
Exercise: Event Handling
1. Create a button that, when clicked, alerts "Button clicked!" (Use addEventListener).
2. Add an input field and as the user types (on the "input" event), display the current text in a <p> below. (Hint: use inputElem.value inside the handler to get current text.)
3. Make a simple "counter" buttons: one button with "+" and one with "-", and a <span id="counter">0</span> in between displaying the count. Attach events to increment or decrement the counter value when the buttons are clicked. (Use a variable to track count, or even retrieve from the text using parseInt each time.)
4. Create a list of items. Attach a single event listener to the <ul> (parent) for clicks. When an <li> is clicked, highlight it (for example, change its background color). This will use event.target and event delegation. (Bonus: maybe toggle highlight off if already highlighted, perhaps by toggling a class.)[37]
5. (Advanced) Build a simple key logger: When the user presses any key (on document or an input field), capture the key and display it. For example, display "Last key pressed: X". Use keydown event and event.key property. If the key is Enter (event.key === "Enter"), maybe do something special like add a line break to an output or indicate "Enter pressed". This gives practice with keyboard events and the event object.
11. Working with Forms
Handling forms is a common task for front-end JavaScript, as you often want to validate user input, provide instant feedback, or handle form submission via AJAX without a page reload. Forms in HTML include inputs, checkboxes, radio buttons, select dropdowns, etc., and a submit mechanism.
Let's go over key points: - Accessing form elements: You can get references to input/select/textarea elements via the same DOM methods (getElementById, etc.). Often giving each important field an id is helpful. - Reading values: For an <input> or <textarea>, use .value property to get the current value (string). For a checkbox, .checked property is a boolean indicating if it's checked. For a select, .value gives the value of the selected option (or you can get selected index or text). - Setting values: You can set these properties too (e.g., input.value = "new value"; or checkbox.checked = true;). - Form submission: When a form is submitted (e.g., by clicking a <button type="submit"> or pressing Enter in a text field), a "submit" event is fired on the form element. If you don't preventDefault, the browser will attempt to send the form data to the URL specified in form's action attribute (or reload current page if none). - Preventing submission: Often you use e.preventDefault() in a submit handler to stop actual submission, so you can handle it via JS (like validate and then maybe send via fetch or so). - Validation: You can manually check fields and show messages. Also, HTML5 provides some built-in validation (e.g., required attribute, type="email" for email format, etc.) which you can leverage.
Basic Example: Form validation on submit
HTML:
<form id="contactForm">
  <label>Name: <input type="text" id="nameField" required></label><br>
  <label>Email: <input type="email" id="emailField" required></label><br>
  <label>Message: <textarea id="msgField" rows="4" required></textarea></label><br>
  <button type="submit">Send</button>
</form>
<p id="errorMsg" style="color: red;"></p>
This form requires name, email, message. The browser will actually prevent submission if required fields are empty or if email is not in valid format because of HTML5 validation. But let's handle it ourselves too.
JS:
let form = document.getElementById("contactForm");
let errorMsg = document.getElementById("errorMsg");

form.addEventListener("submit", function(e) {
  e.preventDefault();  // prevent actual form submission/refresh

  // Get field values
  let name = document.getElementById("nameField").value.trim();
  let email = document.getElementById("emailField").value.trim();
  let msg = document.getElementById("msgField").value.trim();

  // Simple validation
  if (name === "" || email === "" || msg === "") {
    errorMsg.textContent = "Please fill in all fields.";
    return;
  }
  // rudimentary email check:
  if (!email.includes("@")) {
    errorMsg.textContent = "Please enter a valid email address.";
    return;
  }

  // If validation passes:
  errorMsg.textContent = "";
  console.log("Form Data:", { name, email, msg });
  alert("Thank you, " + name + "! Your message has been sent.");
  // Optionally, clear the form
  form.reset();
});
What we did: - On submit, we prevented default. - Fetched values from the fields (.value) and trimmed whitespace. - Checked if any are empty, or if email doesn't contain '@' (very simplistic email validation; real validation might be more complex). - If any check fails, we set an error message in a <p> and return (stop processing). - If all good, we cleared any error message, and here we just log the data and show an alert to simulate sending. We then called form.reset() which resets all fields to their initial state (clears them in this case, since they were empty initially). - In a real scenario, instead of alert, you might use fetch or another method to send the data to a server endpoint, then show a success message or update the page accordingly.
Note: We accessed inputs by id. Alternatively, form.elements collection can be used (e.g., form.elements["nameField"].value or using the name attribute of inputs). But using getElementById for each is fine and clear.
Real-time Validation and Feedback
Instead of only validating on submit, you can also validate as the user types or leaves a field: - Use input event on a field for real-time checking (e.g., show a green checkmark if password meets criteria). - Use blur event (fires when field loses focus) to validate once user finishes typing. - Change styles or show hints accordingly.
For example:
let nameField = document.getElementById("nameField");
nameField.addEventListener("input", function() {
  if (nameField.value.trim().length > 0) {
    nameField.style.borderColor = "green";
  } else {
    nameField.style.borderColor = "red";
  }
});
This will make the border green when there's something typed, red when empty (just as a simple feedback).
Handling checkbox or radio
Check boxes:
<label><input type="checkbox" id="subscribeBox"> Subscribe to newsletter</label>
JS:
let subscribeBox = document.getElementById("subscribeBox");
subscribeBox.addEventListener("change", function() {
  console.log("Subscribed:", subscribeBox.checked);
});
change event is often used for checkboxes or select dropdowns (because they don't continuously emit input events like text fields do; change fires when the value is committed).
Radio buttons: similar, but usually grouped by name:
<label><input type="radio" name="gender" value="M"> Male</label>
<label><input type="radio" name="gender" value="F"> Female</label>
We could listen to change on each radio or on the parent (like a fieldset) and check which is checked.
Select dropdown:
<select id="countrySelect">
  <option value="">-- Select Country --</option>
  <option value="sg">Singapore</option>
  <option value="us">USA</option>
</select>
JS:
let countrySelect = document.getElementById("countrySelect");
countrySelect.addEventListener("change", function() {
  console.log("Selected country code:", countrySelect.value);
});
Form best practices
Use label elements for accessibility (they can also tie to input via for attribute and id).
Validate input thoroughly, and also have server-side validation (never fully rely on client-side, but it's good for UX).
Use .preventDefault() to handle submission via JS if needed.
Provide feedback on what went wrong (like we did with errorMsg).
You can also use the Constraint Validation API (like checkValidity, setCustomValidity) of HTML5 if you want to integrate with native form validation (outside scope here, but good to know exists).
Exercise: Forms
1. Create a simple login form with two fields: username and password, and a "Login" button. Use JavaScript to validate that both fields are not empty when the button is clicked. If either is empty, show an error message (in a div or alert). If both filled, show a success message (e.g., alert "Logging in..."). Prevent actual form submission for this exercise.
2. Make a form with an <input type="range" id="volumeSlider" min="0" max="100"> and a <span id="volumeValue"></span> next to it. Use an input event on the slider to continuously update the span with the slider's current value (to simulate a volume control display).
3. Create a form with a text field for a phone number. As the user types, automatically format it in a certain pattern (e.g., add parentheses or dashes after certain digits). For example, typing "1234567890" could dynamically become "(123) 456-7890". (Hint: use input event and manipulate value, but be mindful of cursor position.) This is more advanced, but an interesting challenge in form handling.
4. Add a <select> dropdown for choosing a country, and based on the selection, show or hide an additional field. For example, if "Other" country is selected, show a text field "Please specify:". Use the change event on the select to handle this dynamic behavior.
5. (Advanced) Build a simple registration form that checks password strength as the user types the password. For instance, require a minimum length and at least one number. As the user types, display a message like "Strength: weak/medium/strong" with color coding. Use keyup or input events on the password field to evaluate the string and update the message. (This combines string handling with form events.)
12. Asynchronous JavaScript
Up until now, our code has been mostly synchronous – meaning each statement executes one after the previous, in order, and the next line waits for the previous to finish. However, in web development, we frequently deal with operations that take time (like loading data from a server, waiting for user input, or timers). JavaScript in the browser executes in a single thread, so to keep the page responsive, these long operations are handled asynchronously – meaning they start, and the program can continue running while waiting for the operation to complete. When the operation finishes, it triggers some callback or promise to handle the result.
Key asynchronous mechanisms in JavaScript: - Callbacks – the traditional way: passing a function that gets called when an async operation completes. - Promises – a newer abstraction that represents a future value or error; you attach .then and .catch callbacks. - async/await – syntactic sugar over promises to write asynchronous code that looks more like synchronous code.
Let's go through them in order of evolution.
12.1 Callbacks
A callback is just a function passed into another function to be invoked later. Many older asynchronous APIs use callbacks. For example: - setTimeout(callback, delay) uses a callback function that runs after a delay. - Old AJAX (XMLHttpRequest) or Node-style functions use callbacks.
Example with setTimeout:
console.log("Before");
setTimeout(function() {
  console.log("3 seconds passed");
}, 3000);
console.log("After");
What happens: - "Before" logs. - setTimeout is called, scheduling the callback to run after 3000ms (3 sec). Then it immediately returns (doesn't block). - "After" logs immediately, because we didn't wait 3 seconds to move on. - Then, after 3 seconds, the timeout callback executes, logging "3 seconds passed".
This shows how the asynchronous callback executes later, not blocking the main thread.
Another example: a fake asynchronous data fetch using a callback:
function fakeFetchData(callback) {
  console.log("Fetching data...");
  setTimeout(function() {
    // simulate data retrieved after 2 sec
    let data = { message: "Hello", id: 123 };
    callback(data);
  }, 2000);
}

// Using the fake fetch:
fakeFetchData(function(result) {
  console.log("Data received:", result);
});
console.log("This logs before data is received, due to async behavior.");
We pass a function to fakeFetchData. That function will be called later when data is "ready". Meanwhile, execution continues.
Callback hell: A drawback of callbacks is when you have to do many async operations in sequence, you end up nesting callbacks inside callbacks, leading to deeply indented code that's hard to read/maintain (often called "callback hell" or the pyramid of doom). For example:
doStep1(function(r1) {
  doStep2(r1, function(r2) {
    doStep3(r2, function(r3) {
      // ...and so on
    });
  });
});
This nesting is ugly. Promises help flatten this structure.
12.2 Promises
A Promise is an object representing the eventual completion (or failure) of an asynchronous operation and its resulting value[9]. You can attach callbacks to a promise instead of passing callbacks into functions.
Promises have states: pending, fulfilled (resolved with a value), or rejected (errored with a reason).
To create a promise manually, you'd do:
let p = new Promise((resolve, reject) => {
  // do something async
  setTimeout(() => {
    let success = true; // just example
    if (success) resolve("Yay!");
    else reject(new Error("Something went wrong"));
  }, 1000);
});
But more often, you'll be using functions that return promises (like the modern fetch API returns a promise).
Using a promise:
p.then(value => {
  console.log("Promise fulfilled with:", value);
}).catch(error => {
  console.error("Promise rejected:", error);
});
The then callback runs when resolve is called (with the value), catch runs if reject is called (or an error thrown). You can chain .then() calls for sequential operations.
Let's use the built-in fetch API as a real example (which fetches a URL and returns a promise):
console.log("Starting fetch...");
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())  // parse JSON from response
  .then(data => {
    console.log("Received post:", data);
  })
  .catch(error => {
    console.error("Fetch error:", error);
  });
console.log("Fetch initiated, waiting for response...");
Output flow: - "Starting fetch..." logs. - fetch initiated (non-blocking). - Immediately "Fetch initiated..." logs. - After some time when network responds, the first then runs with response object, we return response.json() which itself returns a promise to parse JSON. - When JSON is parsed, second then runs with the actual data (post object) and logs it. - If any error happens (network error or JSON parse error), the catch would run and log the error.
This demonstrates how promises allow chaining (then returns a new promise, enabling chain) and error catching. It's more linear than nested callbacks.
Promise chaining vs nesting: With promises you do:
doStep1()
  .then(result1 => doStep2(result1))
  .then(result2 => doStep3(result2))
  .then(result3 => {
    // final result handling
  })
  .catch(err => {
    // handle any error from any step
  });
This is flat and easier to read than nested callbacks.
There are also utility functions like Promise.all (to run multiple promises in parallel and wait for all) and Promise.race (first one wins), etc., which are useful in certain scenarios (like waiting for multiple data endpoints to load).
12.3 async/await
ES2017 introduced async functions and the await keyword, which is built on promises but allows writing code in a synchronous-looking style.
You mark a function as async, and then inside it you can await a promise. await will pause the function execution until the promise settles (fulfills or rejects). Meanwhile, the rest of the program can run (the function is asynchronous and doesn't block the main thread).
Example rewriting the fetch example with async/await:
async function fetchPost() {
  try {
    console.log("Starting fetch...");
    let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    let data = await response.json();  // await parsing as well
    console.log("Received post:", data);
  } catch (error) {
    console.error("Fetch error:", error);
  }
  console.log("This will log after the data is fetched (in sequence inside function).");
}

fetchPost();
console.log("This logs while fetchPost is running asynchronously.");
Points: - We define fetchPost as async. Inside, we use await for fetch and for response.json. - We wrap in try/catch to handle errors (like a .catch). - The console.log after the awaits only runs after data is fetched, making it easy to handle sequential steps. - We call fetchPost() (it returns a promise, which we don't even need to handle explicitly here, but we could if we wanted to know when it's done). - The final outside log shows that outside code isn't blocked by the await; fetchPost runs asynchronously.
The result is code that's easier to write and read for multiple steps, without .then chaining. Under the hood, it's still using promises.
Important: You can only use await inside an async function (or at top-level in modules or some environments). If you need top-level, you might do async function main(){...; await ...; } main(); structure.
Real usage scenario:
Let's simulate something: using setTimeout and Promise:
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function demoAsync() {
  console.log("Wait for 1 second...");
  await delay(1000);
  console.log("1 second passed.");
  console.log("Wait for another 2 seconds...");
  await delay(2000);
  console.log("2 more seconds passed. Done!");
}
demoAsync();
This uses a helper delay that returns a promise which resolves after given milliseconds (essentially a promise version of setTimeout). Then inside demoAsync we await it to pause.
Note on error handling: In promise chain, you typically have a .catch. In async/await, use try/catch around await calls to handle rejections (or allow them to bubble up to an outer catch if the function returns a promise and you catch that).
The Event Loop (briefly)
JavaScript's concurrency model is based on an "event loop". The event loop handles the execution of multiple chunks of code over time, coordinating between the call stack and a message queue (or task queue). When an asynchronous task completes (like a timer finishes, or fetch returns data), a callback (or promise resolution) is queued to be executed. The event loop will only execute these queued callbacks when the main thread is free (call stack is empty). This is why even a setTimeout with 0ms doesn't run immediately, but only after the current code finishes and event loop picks up the callback[10].
Understanding this helps you realize that, for example:
setTimeout(() => console.log("timeout"), 0);
console.log("end");
will always log "end" then "timeout", because the timeout callback goes to the queue and will run after the current call finishes.
Exercise: Asynchronous JS
(Note: some of these might require running in an environment where you can use fetch or simulate with setTimeouts.)
1. Use setTimeout to log "Hello" after 2 seconds. Then schedule another setTimeout inside that callback to log "World" after an additional 1 second. (This is a callback chain; try to predict the timing.)
2. Create a promise-based function wait(ms) that returns a promise which resolves after ms milliseconds (like the delay function above). Use it with .then to wait 1 second, then log a message. Then chain another wait(1 second) and log another message.
3. Using Promise.all: Suppose you have two promises p1 and p2 that each resolve after a random time (simulate with setTimeout inside). Use Promise.all([p1, p2]) to know when both are done, and then log both results. Also attach a .then to each individually to see when each finishes. (This shows parallel async operations.)
4. If you have an array of URLs, how would you fetch all of them and log the results when all have finished? (Hint: Promise.all on an array of fetch promises). This is a conceptual exercise unless you have actual endpoints to hit.
5. (Advanced) Write an async function that fetches data from two endpoints sequentially (one after the other, using await), and then returns combined data. For example, fetch user info from /user/1, then fetch that user's posts from /user/1/posts, and return an object containing both user info and posts. Use try/catch to handle errors. (You can use a public API or just simulate with delay and dummy data.)
13. Modern JavaScript (ES6+) Features
JavaScript has evolved, and ES6 (also known as ECMAScript 2015) was a big update that introduced many new features to make the language more powerful and developer-friendly. Since ES6, each year new features have been added (ES2016, ES2017, ..., up to ES2021/ES2022 at this point). Collectively, we might call these "ES6+" or modern JS features.
We've already been using some (like let, const, arrow functions, classes, etc.). Let's summarize and cover the key ones:
13.1 Block-Scoped Variables (let & const)
let and const (introduced in ES6) provide block scope for variables, unlike var which is function-scoped or global-scoped[11]. Block scope means they only exist within the nearest enclosing { } block (like inside an if, loop, or function).
We've replaced var with let and const in our examples: - Use let when the variable will change (a mutable binding). - Use const for constants (immutable binding) - you cannot reassign a const, which helps prevent accidental changes.
Example:
if (true) {
  let x = 5;
  const y = 10;
  // x and y exist here
}
console.log(typeof x); // undefined, x is not visible outside the block
var would have hoisted out of the block (if not in a function), but let/const do not.
Temporal Dead Zone: let/const are hoisted in a sense but not initialized. You cannot access them before their declaration in the code. If you try, you'll get a ReferenceError instead of undefined as with var.
Good practice: Use const by default, and only use let if you need to reassign the variable later. This makes your intentions clear and prevents unintended changes[12].
13.2 Template Literals (Template Strings)
ES6 introduced template literals using backtick ` characters. They allow embedding expressions and multi-line strings easily.
Example:
let name = "Alice";
let age = 25;
console.log(`My name is ${name} and I am ${age} years old.`);
// Output: My name is Alice and I am 25 years old.
The ${...} syntax evaluates the expression inside and inserts it into the string. This is much nicer than concatenating with +. Template strings also respect newlines:
let text = `This is line 1
and this is line 2.`;
No need for \n manually.
They also allow using complex expressions inside ${} and even calling functions or using ternaries:
console.log(`I am ${age >= 18 ? 'an adult' : 'a minor'}.`);
13.3 Destructuring and Rest/Spread
Destructuring allows you to unpack values from arrays or properties from objects into distinct variables in a convenient way.
Array destructuring:
let arr = [10, 20, 30];
let [a, b, c] = arr;
console.log(a, b, c); // 10 20 30

// Skipping and default:
let [x, , z = 99] = [5, 6];
console.log(x, z); // 5 99 (z got default because third element was undefined)
Object destructuring:
let person = { firstName: "Bob", lastName: "Smith", age: 40 };
let { firstName, age } = person;
console.log(firstName, age); // Bob 40

// Using different variable names:
let { firstName: f, lastName: l } = person;
console.log(f, l); // Bob Smith

// Default and missing:
let { country = "Unknown" } = person;
console.log(country); // Unknown (person.country was undefined)
Destructuring is great for pulling out what you need from a returned object or array. For example, if a function returns { data, error }, you can do:
let { data, error } = someFunction();
instead of accessing properties individually.
Rest and Spread: - Spread operator ... (in arrays or objects) expands an iterable or object in places where multiple elements/keys are expected. - Rest operator ... in function parameters or destructuring collects multiple elements into an array or remaining properties into an object.
Spread with arrays:
let arr1 = [1, 2, 3];
let arr2 = [4, 5];
let combined = [...arr1, ...arr2, 6];
console.log(combined); // [1,2,3,4,5,6]
We merged arrays easily. Spread can also spread a string into letters:
console.log([...'hello']); // ['h','e','l','l','o']
Spread with objects (ES2018):
let obj1 = { a: 1, b: 2 };
let obj2 = { b: 5, c: 6 };
let mergedObj = { ...obj1, ...obj2 };
console.log(mergedObj); // { a:1, b:5, c:6 } (obj2's b overwrote obj1's b)
This is great for cloning objects or merging, instead of Object.assign.
Rest in function parameters:
function sumAll(...numbers) {
  return numbers.reduce((sum, n) => sum + n, 0);
}
console.log(sumAll(1, 2, 3, 4)); // 10
...numbers in parameters means any extra arguments will be an array named numbers inside the function. So sumAll can accept any number of arguments.
Rest in destructuring:
let [head, ...tail] = [100, 200, 300, 400];
console.log(head); // 100
console.log(tail); // [200, 300, 400]

let { a, ...others } = { a: 10, b: 20, c: 30 };
console.log(a);     // 10
console.log(others); // { b: 20, c: 30 }
In arrays, rest collects the "rest" of elements. In objects, it collects remaining properties not picked.
13.4 ES6 Classes
ES6 introduced a class syntax to make object constructor and inheritance easier to write (though under the hood it uses prototypes).
Example:
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hello, I'm ${this.name}.`);
  }
}

let p = new Person("Alice", 30);
p.greet(); // "Hello, I'm Alice."
The class syntax: - constructor is a special method that runs when new Person() is called. It sets up the object. - Methods defined in class (like greet) go on the prototype (shared by instances). - We can also have getters, setters, and static methods (prefixed with static for class-level methods).
Inheritance with classes:
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // call parent constructor
    this.breed = breed;
  }

  speak() {
    console.log(`${this.name} barks.`);
  }
}

let rex = new Dog("Rex", "German Shepherd");
rex.speak(); // "Rex barks."
extends sets up prototype chaining behind the scenes (Dog.prototype inherits from Animal.prototype). super calls the parent class's constructor (and must be done before using this in the subclass constructor). We overrode speak in Dog, but we can still call super.speak() inside it if we wanted to invoke the parent behavior.
Under the hood, classes use prototypes (so methods are shared, etc.), but you don't need to manually manipulate Function.prototype etc. It's cleaner and more similar to classes in other languages, which helps many developers.
Important: Classes in JS are mostly "syntactic sugar"[13]. The actual mechanism is still prototypal inheritance.
13.5 Modules (Import/Export)
ES6 added native modules. We have a whole section on modules coming up next, so here just to note: you can use export and import to split code into files. This replaced older patterns like IIFEs or AMD/RequireJS or CommonJS in browser context.
Using modules ensures each file has its own scope and we explicitly import what we need.
Example:
// math.js
export function add(a,b) { return a + b; }
export const PI = 3.14;
// main.js
import { add, PI } from './math.js';
console.log(add(2,3));  // 5
console.log(PI);        // 3.14
We will detail this in the next section.
13.6 Other ES6+ Features
A few other notable ones: - Arrow functions: we covered. - Default parameters: We saw in best practices. You can give function parameters default values: function multiply(a, b = 1) { return a*b; }. - Iterators and for-of: for...of loop (we used it for arrays). Also Strings, Maps, Sets, etc. are iterable. - Maps and Sets: New data structures. - Map: A dictionary of key-value pairs, like an object but keys can be any type (even objects). Methods: set(key, value), get(key), has(key), delete(key), and it preserves insertion order. Example:
let map = new Map();
map.set('name', 'Alice');
map.set({ id: 1 }, 42); // an object as key
console.log(map.get('name')); // Alice
- Set: A collection of unique values. Methods: add(value), has(value), delete(value). Good for checking existence, eliminating duplicates, etc. - Symbols: A new primitive type for unique identifiers (mostly for advanced use, like to define hidden object properties or for certain JS internal hooks). - Promises: as discussed. - String.includes, String.startsWith, String.endsWith: easier string checks than using indexOf. - Array.find, Array.findIndex, Array.includes: we mentioned includes for arrays; find returns the first element satisfying a condition, etc. - Object enhancements: - Shorthand property names: if variable name and object property name are same, you can do:
let name = "Charlie";
let age = 30;
let obj = { name, age }; // same as { name: name, age: age }
- Shorthand method definitions: we showed greet() { } in class and object literal too:
let obj = {
  greet() { console.log("hi"); }
};
- Computed property names:
let propName = "custom";
let obj = {
  [propName + "Name"]: "Value"  // creates property "customName": "Value"
};
- Optional chaining (ES2020): ?. operator to safely access nested properties. For example:
let user = { profile: { name: "Sam" } };
console.log(user.profile?.name); // "Sam"
console.log(user.contact?.email); // undefined (without error, since user.contact is undefined, it short-circuits)
Very handy to avoid Cannot read property X of undefined errors. - Nullish coalescing (ES2020): ?? operator to provide a default only if value is null or undefined (as opposed to || which treats falsy like 0 or "" as well). Example:
let input = 0;
console.log(input || 5); // 5 (because 0 is falsy)
console.log(input ?? 5); // 0 (because 0 is not null/undefined, so ?? leaves it)
- Async/await (ES2017): we covered.
The above features together make modern JS much nicer to work with than older ES5 code. When reading older code, you might see var, manual function constructors for objects, or concatenation for strings, but nowadays we use these improved constructs.
Exercise: Modern JS Features
(This will reinforce usage of some features.) 1. Use template literals to create a multi-line string that contains a quote and an interpolated value (e.g., someone's name and age).
2. Given an object {a:1, b:2, c:3}, use destructuring to extract a and c into variables, and use the rest operator to collect the remaining properties into another object.
3. Use the spread operator to merge two arrays, and also to clone an object (e.g., let objCopy = {...originalObj}). Verify that modifying the clone doesn't affect the original.
4. Write a function maxOfThree(x, y, z) that uses Math.max but passes the arguments using the spread operator (hint: Math.max(...array) can spread array values into arguments). Perhaps accept an array and do Math.max(...arr).
5. Create a Map of student names to scores (e.g., let scores = new Map([ ["Alice", 90], ["Bob", 85] ]);). Add a new entry, then retrieve and log a score. Iterate over the Map with a for-of loop (for (let [name, score] of scores) { ... }) and print each entry. Do a similar creation of a Set of some values, and demonstrate adding and checking values.
6. (Optional, if environment supports) Use optional chaining and nullish coalescing in an example: e.g., let user = null; console.log(user?.name ?? "Anonymous"); and explain the result (it should print "Anonymous" because user is null, so user?.name is undefined, then ?? gives the fallback).
14. Modules in JavaScript
As programs grow, it's essential to organize code into separate files (modules) for clarity and reuse. Historically, before ES6 modules, people used libraries or module bundlers (like Webpack, using CommonJS require or AMD define) to simulate modular code in the browser. But now browsers support native JS modules via the import and export syntax.
Using modules helps avoid polluting the global namespace with variables and functions (each module has its own scope) and allows us to explicitly control what is exposed to other modules.
Enabling modules
To use modules in a browser environment, include your main script with type="module" in the HTML:
<script type="module" src="main.js"></script>
This tells the browser to treat main.js as a module (so you can use import/export). One important detail is that when running from files (file:// protocol), modules may not work due to security restrictions (browsers often require them to be loaded via a server). So typically you'll test modules via a local server or a bundler. But conceptually, let's proceed with how to use them.
Exporting from a module
In a module file, you can mark certain functions, objects, or values as exported.
Two ways: - Named exports: You can export multiple values by name. - Default export: One module can designate a default export (like the main thing exported).
Named exports example (mathUtils.js):
// Exporting individual things
export function add(x, y) {
  return x + y;
}

export function multiply(x, y) {
  return x * y;
}

// You can also declare first, then export later:
function square(x) {
  return x * x;
}
export { square };  // named export after declaration

// Export a variable (could be const, let, var):
export const PI = 3.14159;
This module exports add, multiply, square, and PI as named exports.
Default export example (greet.js):
export default function(name) {
  console.log(`Hello, ${name}!`);
}
// Could also do: export default someVariable or default class, etc.
Here greet is the default export of this module (though we didn't name the function, it's an anonymous default export).
Note: You can have multiple named exports per module, but only one default export.
Importing into another module
In another file (say main.js), you import what you need:
Importing named exports:
import { add, PI, square } from './mathUtils.js';
console.log(add(2, 3));
console.log("Area of circle radius 2:", PI * square(2));
You can also rename on import:
import { multiply as mul } from './mathUtils.js';
console.log(mul(3, 4)); // 12
If you want all exports as an object:
import * as math from './mathUtils.js';
console.log(math.add(5,5));
console.log(math.PI);
This imports everything under the namespace math.
Importing default exports:
import greet from './greet.js';  // no braces, you can choose a name for default import
greet('Alice');  // Hello, Alice!
If a module had both default and named, you could:
import defaultExport, { named1, named2 } from './someModule.js';
But mixing can be confusing; it's often one or the other (though using both is legal).
Modules and strict mode
Modules by default run in strict mode (no need for "use strict") and have their own scope. Top-level this in a module is undefined (not window)[14], which is usually fine. Variables you declare in a module are not global.
Module loading and execution order
If one module imports another, the imported module is loaded and executed first (once, even if multiple modules import it, thanks to caching). Module imports are static (you can't conditionally import at runtime without dynamic import, which is another feature). The browser loads modules asynchronously by default (deferred until after HTML parsing), so they're non-blocking like scripts with defer.
Dynamic import
There's also an import() function (since ES2020) to dynamically load modules on the fly, returning a promise. E.g., import('./module.js').then(module => { module.doSomething(); });. This is used for code-splitting or loading code on demand.
Example:
Let's illustrate with a small module usage:
File: utils.js
export function toUpper(str) {
  return str.toUpperCase();
}

export const version = "1.0";
File: greet.js
export default function(name) {
  console.log(`Hello, ${name}!`);
}
File: app.js
import { toUpper, version } from './utils.js';
import greet from './greet.js';

console.log("Utils version:", version);
greet(toUpper("world"));  // expected to log "Hello, WORLD!"
If app.js is included as a module script, it will import utils.js and greet.js. The output should show the version and greeting in uppercase for "world".
Gotchas: - Modules must be served over HTTP (or a proper file server) due to CORS. If you just open the HTML file via file://, the imports likely fail. - You cannot directly import from remote origins unless they allow CORS, but in local dev, you'll typically host all modules on same domain. - A module can import other modules which import others (the browser handles loading dependencies). - Use relative or absolute paths for imports. E.g., ./module.js or full URL if needed. Leaving off the extension might not work in browser (some allow omitting .js, but it's safest to include it). - When writing modules in a project, you'll often use build tools to bundle them for production (for older browsers that didn't support modules, etc.), but nowadays evergreen browsers support them.
Why use modules: They make code organization clearer (each file focuses on something), avoid naming collisions, and help with maintainability and testing (you can import a module in a test, etc.).
Exercise: Modules
(This might be theoretical if not running in a module-supporting environment, but good to think through.)
1. Imagine you have two files: helpers.js exporting a function
export function sayHi(name) { console.log("Hi " + name); }
and main.js which imports and uses it. Write the import statement and usage in main.js.
2. Suppose math.js has a default export of a class Calculator. Show how you'd import that default class in another file and instantiate it.
3. If moduleA.js exports
export const a = 1; 
export const b = 2;
and moduleB.js does
import * as stuff from './moduleA.js';
what is stuff.a and stuff.b? And if moduleB also had
export { stuff };
what would another module get if it imported stuff from moduleB? (This is to think about re-exporting, which is possible: e.g., export { something } from './othermodule.js'; directly.)
4. How would you dynamically import a module only when needed? (Answer: using import('module.js').then(...) which returns a promise, and inside the then you can use the module object). What type of object do you get in the .then? (It resolves to the module, which you then use like module.exportName.)
5. (Advanced) Outline how you would break a larger project (say a to-do app) into modules: e.g., maybe a module for DOM interactions (dom.js), a module for data logic (like managing the tasks array, tasks.js), and a main module to tie them together. What might each export or import from others? (This is more of a design thought exercise.)
15. Closures
A closure is a fundamental concept in JavaScript that allows a function to access variables from an outer function’s scope even after the outer function has finished executing. In other words, a closure is formed when an inner function "closes over" (captures) variables from its surrounding scope. This is possible because in JavaScript, functions are first-class functions and they carry their lexical scope with them wherever they go.
Let's break that down in a simpler way: - When you create a function inside another function, the inner function has access to the variables of the outer function (and any parent scopes) at the time it was defined. - If the outer function finishes executing and its local variables would normally go out of scope, they remain alive if an inner function still references them. The inner function remembers the environment it was created in – that's the closure.
Why are closures useful?
They enable powerful patterns like: - Data privacy / Emulating private variables: You can keep some data hidden inside a closure and only expose functions that access it. - Function factories: Functions that generate other functions with preset environments. - Maintaining state in an asynchronous callback or event handler after an outer function has returned.
Let's see a classic closure example:
function makeCounter() {
  let count = 0;
  return function() {
    count++;
    console.log(count);
  };
}

let counter1 = makeCounter();
counter1(); // 1
counter1(); // 2

let counter2 = makeCounter();
counter2(); // 1 (it's independent of counter1)
What happened here: - makeCounter is an outer function that declares a local variable count. - It returns an inner function (anonymously) that increments and logs count. - When we call makeCounter(), it returns that inner function (and its closed-over state). - counter1 and counter2 are two separate closure instances, each with their own count variable that persists between calls.
Even though makeCounter finished executing, the variable count lives on in the closures created (one for counter1, one for counter2). The inner function forms a closure with count. Each time we call counter1(), it updates the count from its own closed-over scope.
To emphasize: A closure gives you access to an outer function’s scope from an inner function[15]. JavaScript uses lexical scoping, meaning the inner function's scope chain includes the scope where it was defined.
Another example (to illustrate capturing function arguments or outer variables):
function greetMaker(greeting) {
  return function(name) {
    console.log(greeting + ", " + name);
  };
}

let sayHello = greetMaker("Hello");
sayHello("Alice"); // Hello, Alice
sayHello("Bob");   // Hello, Bob

let sayHi = greetMaker("Hi");
sayHi("Charlie");  // Hi, Charlie
Here: - greetMaker takes a greeting string and returns an inner function that uses greeting. - The inner function closes over the greeting variable. Even after greetMaker returns, the inner function remembers the greeting that was passed. - sayHello closure has greeting = "Hello", sayHi has greeting = "Hi".
This is a very handy pattern for creating specialized functions (we created two "greeter" functions with different preset greeting messages).
Closures and Loops: A common pitfall historically was using var in loops with closures, which could cause unexpected behavior because var is function-scoped (not block-scoped). For example:
for (var i = 1; i <= 3; i++) {
  setTimeout(function() {
    console.log("var loop i:", i);
  }, 100 * i);
}
Because var is not block-scoped, there's essentially one i shared, and by the time the timeouts run, i is 4 (loop ended). So it would log "4" three times. Using let fixes this, because each iteration gets a new i binding (block scope).
Alternatively, you could use an IIFE to capture the current value:
for (var j = 1; j <= 3; j++) {
  (function(x) {
    setTimeout(function() {
      console.log("closure loop j:", x);
    }, 100 * x);
  })(j);
}
This uses a immediately invoked function to take j (say 1) as x (local), and then the timeout closes over x. That way each timeout has the correct number. But with let j in the loop, it's much simpler:
for (let k = 1; k <= 3; k++) {
  setTimeout(() => console.log("let loop k:", k), 100 * k);
}
Because let is block-scoped, each arrow callback closes over the correct k.
Memory considerations: Variables in closures are not garbage-collected as long as the function that closed over them is still reachable (in use). This means if you create a lot of closures holding large data, memory can be retained longer. Usually not an issue unless extreme, but be mindful (e.g., don't keep an old huge data array in a closure if you no longer need it).
Summary: A closure is like a backpack that a function carries around; it holds all the variables from the outer scopes that were in-scope when the function was created[15]. Whenever the function is called, it has access to those preserved variables, giving JavaScript its powerful ability to maintain state between calls and create abstractions like private data.
Exercise: Closures
1. Write a function makeAdder(x) that returns a new function. The returned function should take a parameter y and return x + y. Use a closure to remember x. Test it: e.g., let add5 = makeAdder(5); console.log(add5(10)); // 15.
2. Create a function rememberMe(message) that stores a message string, and returns a function that when called, logs "Remember: [message]". Try using it to create a couple of reminder functions with different messages and call them later.
3. Use a closure to create a simple "once" utility: Write once(fn) that returns a new function that wraps a given function fn, such that the first time the new function is called, it runs fn normally, but subsequent calls do nothing. (Hint: use a flag variable in the closure to track if it has been called already.) Example:
let justOnce = once(() => console.log("This should appear only once"));
justOnce(); // prints message
justOnce(); // does nothing (no output)
4. Make a module pattern using closures (without using ES6 imports): Define a function createCounter() that uses closure to encapsulate a count variable and returns an object with two methods: increment() (which increases count) and get() (which returns current count). Demonstrate usage:
let c = createCounter();
c.increment();
c.increment();
console.log(c.get()); // 2
The count should not be directly accessible from outside, only via the methods (this is a classic closure for data privacy pattern).
5. (Advanced) Closures in asynchronous callbacks: Write a function countdown(n) that for a given number n, uses setInterval to log the numbers n, n-1, ... 1 one per second, then logs "Done!". Use a closure to ensure the interval callback can access the current count. (Note: setInterval returns an interval ID you can clear with clearInterval; consider clearing it when reaching 0). This will test understanding of closure with timed callbacks. (Alternatively, you could use a nested setTimeout approach for a sequential countdown.)
16. The this Keyword
The this keyword in JavaScript is a bit tricky at first because its value depends on how a function is called, not where or how it was defined (except for arrow functions, which are an exception). Essentially, this refers to the "context" of the function call, which is usually the object that the function is a property of (the object owning the method), or some specific context if explicitly bound.
Let's break down common scenarios:
Global context (non-strict mode vs strict mode)
In the global scope (outside any function), this refers to the global object (window in browsers) when not in strict mode[14].
In strict mode, this would be undefined in the global context (since strict doesn't default to global object).
For modules (which are always strict) and in ES6 classes, top-level this is undefined.
Inside a regular function (non-arrow) - default binding
If a function is called in the global context (not as a method of an object), in non-strict mode this will be the global object (window). In strict mode, this will be undefined[14].
function showThis() {
  console.log(this);
}
showThis(); // in non-strict, logs Window; in strict, logs undefined
When you intend to use this but call a function without a context, it can lead to this being global or undefined. (E.g., event handlers or callbacks sometimes lose context if not careful.)
As a method of an object - implicit binding
When a function is called as a property of an object, this refers to that object.
let obj = {
  name: "Alice",
  sayName: function() {
    console.log("My name is " + this.name);
  }
};
obj.sayName(); // "My name is Alice"  (`this` inside sayName is obj)
Here, calling obj.sayName() sets this to obj inside the function.
Important: The value of this is determined at call time by the left of the dot. If the function is not called via an object property, this won't be that object.
let f = obj.sayName;
f(); // `this` is now global or undefined; loses context, likely prints "My name is undefined"
Extracting a method and calling it as a bare function loses the original object context.
In a constructor function or class - new binding
When you call a function with new (i.e., as a constructor), this inside that function refers to the newly created object.
function Person(name) {
  // this = {} (new object created)
  this.name = name;
  // (implicitly returns this)
}
let p = new Person("Bob");
console.log(p.name); // "Bob"
Similarly for class constructors, this in the constructor is the instance being created.
Explicit binding with call, apply, bind
Functions have methods call and apply which allow you to call them with a specific this value.
function greet() {
  console.log("Hello, " + this.username);
}
let user1 = { username: "Charlie" };
greet.call(user1); // Hello, Charlie   (`this` set to user1 inside greet)
apply is similar, but takes arguments as an array if the function needs parameters.
bind returns a new function with this permanently bound to the given value.
let greetUser1 = greet.bind(user1);
greetUser1(); // Hello, Charlie
bind is often used to ensure a function uses the desired context when passed around (like ensuring a callback method still refers to its object).
Arrow functions and this
Arrow functions do not have their own this. Instead, an arrow function closes over the this value of its surrounding context at the time it's defined[6][16]. That means: - If you use this inside an arrow function, it refers to the this of the enclosing scope (which could be a surrounding function or the global if not in any function). - Arrow functions cannot be used as constructors (they throw if used with new). - Arrow functions are great for callbacks because they don't change this.
Example:
let obj2 = {
  name: "Dave",
  regular: function() { console.log("Regular:", this.name); },
  arrow: () => { console.log("Arrow:", this.name); }
};
obj2.regular(); // Regular: Dave   (`this` is obj2)
obj2.arrow();   // Arrow: undefined (or maybe Window's name if set, because `this` is not obj2, it's lexically from outside)
In that example, the arrow function this is likely the global object or undefined (since it was defined in the global context of the script, not inside a function with its own this). The regular function works as expected.
Common scenario:
function Person(name) {
  this.name = name;
  // use arrow to retain this
  window.setTimeout(() => {
    console.log("Hi, I'm " + this.name);
  }, 1000);
}
let alice = new Person("Alice"); 
// After 1 second: "Hi, I'm Alice"
If we used a normal function in setTimeout, this inside it would be the global (since setTimeout calls functions without a context), but an arrow keeps the this from the Person function (which is the instance)[39].
In Event Handlers: - When using element.addEventListener('click', function() { ... }), inside that function, this will point to element (the event's current target, essentially)[17]. - If you use an arrow function as the handler, this will not be bound to the element (it inherits surrounding context), so you'll often use event.target or close over a variable if needed.
Summary of this binding rules (non-arrow functions): 1. If called with new: this is the new object (ignoring explicit binding). 2. If called with call or apply (or bound with bind): this is the explicitly provided object. 3. If called as a method (obj.method()): this is obj (the object before the dot). 4. Otherwise (just a normal function call): in non-strict mode, this is global (window); in strict mode, this is undefined.
Exercises: this
1. Create an object robot with a property model and a method sayModel that logs "Model: [model]" using this.model. Call robot.sayModel() and see the correct output. Then assign let f = robot.sayModel and call f(). What does it log, and why? (Expect that this is not robot anymore, likely undefined or window.)
2. Without strict mode, write a standalone function that logs this. Call it normally (it should log the Window object). Then enable strict mode ('use strict') and call the function again; now this should be undefined[14].
3. Show an example using call or apply: Define a function printName that logs this.name. Create two objects with a name property. Use printName.call(obj1) and printName.call(obj2) to print the names, without adding printName as a method of those objects.
4. Create a simple constructor function Dog(name) that stores this.name. Add a method bark on Dog.prototype that uses this.name. Create two Dog instances and call bark on them to confirm this refers to each instance. Then assign one dog's bark to a variable and call it as a plain function; explain why it doesn't know which dog this should refer to (unless you bind it).
5. (Advanced) In an HTML, create a <button id="myBtn">Click</button>. Attach an event listener using a normal function and inside it do console.log(this.id). It should log "myBtn" when clicked (since this is the button). Then change it to an arrow function and test again; you'll likely get undefined (or some outer context) as this[17][39]. This demonstrates the difference of this in arrow vs normal function as event handlers.
17. Prototypes and Inheritance
JavaScript uses prototypal inheritance, meaning objects inherit properties and methods from other objects via a prototype chain. Every object has an internal link to another object (its prototype), from which it can inherit properties. The prototype itself is an object, so it can have its own prototype, forming a chain, and the chain ends at null (usually via Object.prototype which is the top-level prototype of plain objects).
Let's clarify: - Prototype: An object that other objects inherit from. Often, functions have a prototype property that is used when creating new instances with new. - Prototype chain: If you attempt to access a property on an object and it isn't found, JavaScript will look at the object's prototype (one level up the chain). If not found there, it looks at that object's prototype, and so on, until Object.prototype (which has some base methods like toString, etc.)[13][18]. If not found there, it returns undefined.
Example without classes:
let animal = { eats: true };
let rabbit = { jumps: true };

rabbit.__proto__ = animal; // setting animal as the prototype of rabbit (old way)
console.log(rabbit.eats);  // true (found via prototype chain on animal)
console.log(rabbit.jumps); // true (own property)
Here, animal is the prototype of rabbit. So rabbit inherits eats. The __proto__ property is a non-standard (but well-supported) way to access the prototype. Modern code typically uses Object.getPrototypeOf(obj) and Object.setPrototypeOf(obj, proto) or the class/constructor mechanisms instead of setting __proto__ directly.
Using constructors and prototypes:
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  console.log("Hi, I'm " + this.name);
};

let alice = new Person("Alice");
alice.greet(); // "Hi, I'm Alice"
console.log(alice.__proto__ === Person.prototype); // true
What happened: - We defined a constructor function Person. JavaScript automatically gives it a prototype property (initially an object with constructor property). - We added a method greet to Person.prototype. - When we do new Person("Alice"), a new object is created, its internal prototype is set to Person.prototype, and this inside the constructor refers to that new object. - Therefore, alice's prototype is Person.prototype, so alice inherits greet from it. - We verify that with alice.__proto__ === Person.prototype.
So, alice.greet() works because: 1. JS looks for greet on alice (not found as own property). 2. Looks at alice's prototype (which is Person.prototype), finds greet there. 3. Calls it with this as alice (because we called it as a property of alice).
Prototype Chain Example:
console.log(alice.toString()); 
toString isn't defined on alice or Person.prototype, but eventually up the chain alice.__proto__.__proto__ is Object.prototype (because Person.prototype itself inherits from Object.prototype). Object.prototype has toString method, so it gets called.
Thus alice has: - own properties: name. - proto -> Person.prototype (has greet and constructor) - Person.prototype.proto -> Object.prototype (has toString, etc.) - Object.prototype.proto -> null (end of chain).
Almost all objects ultimately inherit from Object.prototype (unless you create with Object.create(null) which makes an object with no prototype).
Inheritance between custom types: Let's say we want Student to inherit from Person:
function Student(name, grade) {
  Person.call(this, name); // call Person constructor to initialize name
  this.grade = grade;
}
// Set up prototype chain:
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student; // fix the constructor reference

Student.prototype.study = function() {
  console.log(this.name + " is studying.");
};

let bob = new Student("Bob", "A");
bob.greet(); // from Person.prototype, logs "Hi, I'm Bob"
bob.study(); // "Bob is studying."
console.log(bob instanceof Student); // true
console.log(bob instanceof Person);  // true, because Student.prototype inherits Person.prototype
We did: - Inside Student constructor, used Person.call(this, name) to reuse initialization (ensuring this.name is set). - Set Student.prototype = Object.create(Person.prototype). This creates a new object whose prototype is Person.prototype, and assigns that to Student.prototype. Now any Student instance's prototype chain will include Person.prototype. - Reset Student.prototype.constructor to Student (because Object.create sets constructor to Person in this case, so we fix it for correctness). - Added a method study to Student.prototype. - Instances of Student now have access to both Person.prototype (greet) and Student.prototype (study).
Using class syntax: The above is what class Student extends Person would do behind the scenes:
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() { console.log("Hi, I'm " + this.name); }
}
class Student extends Person {
  constructor(name, grade) {
    super(name);
    this.grade = grade;
  }
  study() { console.log(`${this.name} is studying.`); }
}
let bob = new Student("Bob", "A");
bob.greet();
bob.study();
Much cleaner and easier to see the inheritance relationship.
Prototypes for built-in objects: Arrays, for example:
let arr = [1, 2, 3];
console.log(arr.__proto__ === Array.prototype); // true
console.log(Array.prototype.__proto__ === Object.prototype); // true
So, arrays inherit from Array.prototype (methods like push, pop, etc. are there), and Array.prototype inherits from Object.prototype.
hasOwnProperty: Earlier, we saw checking own properties:
console.log(bob.hasOwnProperty('name')); // true (set on bob)
console.log(bob.hasOwnProperty('greet')); // false (inherited)
It's recommended to use hasOwnProperty to filter in loops (to avoid iterating inherited properties in for...in loops).
Changing prototypes at runtime: You can add methods to prototypes at any time and instances will see them:
Person.prototype.sayBye = function() {
  console.log(this.name + " says bye.");
};
alice.sayBye(); // works, even though alice was created before sayBye was added
This dynamic nature is powerful but be careful (modifying built-in prototypes like Array.prototype can cause conflicts unless done carefully).
Exercise: Prototypes
1. Create a constructor function Animal(type) that sets this.type. Add a method speak to Animal.prototype that logs "A [type] makes a sound.". Create two animals and call speak on them.
2. Create a constructor Rectangle(width, height). Add a method area to its prototype that returns width * height. Add another method perimeter that returns 2*(width+height). Create a Rectangle instance and test the methods.
3. Show that an array is an object with a prototype: log some array's __proto__ or use Object.getPrototypeOf. Confirm it matches Array.prototype, and that further up the chain is Object.prototype.
4. Using an object literal and Object.create, set up a prototype relationship:
let parent = { hello() { console.log("Hello from parent"); } };
let child = Object.create(parent);
child.name = "Child";
Test that child.hello() works (inherited from parent). Also check child.hasOwnProperty('hello') (should be false, since it's on parent).
5. (Advanced) Implement a simple inheritance without class syntax: Write functions Vehicle(speed) and Car(speed, brand) where Car inherits Vehicle. Vehicle prototype has a method move() that logs "Moving at [speed]". Car prototype should inherit that and have an additional property brand and maybe a method honk(). Create an instance of Car and show it can both move (inherited) and honk (own). Use either the Car.prototype = Object.create(Vehicle.prototype) approach or Car extends Vehicle with classes for comparison if you like.
18. Performance Tips
Writing efficient JavaScript can make your web pages snappier, especially when dealing with large amounts of data or complex animations. Modern JavaScript engines are fast, but it's still possible to write suboptimal code that causes slowdowns. Here are some performance considerations and tips for front-end JavaScript:
Minimize DOM Access and Manipulation
Interacting with the DOM (e.g., querying elements, updating styles, adding/removing nodes) is relatively slow compared to calculations in JavaScript. The browser may need to recalc styles or layout with each change. - Batch DOM updates: If you need to insert many elements, build a string of HTML or use a DocumentFragment, then insert once, instead of inserting one element at a time. Inserting one by one causes multiple reflows. For example, adding 1000 items individually triggers 1000 DOM insertions vs. 1 if you use a fragment[40]. Using document.createDocumentFragment() to collect nodes and append once is a common pattern[36]. - Reduce Layout Thrashing: Avoid querying layout info (like element.offsetHeight) right after modifying the DOM, in a rapid alternation. If you do style changes and then measure, and then style changes, etc., the browser has to recalc layout frequently. Try to group DOM reads and writes separately. - Cache selectors: If you use an element multiple times, get it once and store a reference (e.g., let menu = document.getElementById('menu'); and then use menu in loops rather than querying each time). - Use efficient selectors: querySelector is flexible but if you know you need an element by ID, getElementById is very fast. Class or tag selections returning live HTMLCollections (like getElementsByClassName) can be fast too. But micro-optimizations here are usually minor. Prioritize clarity, then optimize if profiling shows a bottleneck. - Simplify the DOM when possible: A very deep or huge DOM (thousands of elements) can be slower to render and manipulate. Remove elements not needed, or consider virtual rendering for huge lists (render only what's visible).
Optimize Loops and Computations
Choose the right loop: A simple for-loop is marginally faster than higher-order methods like .forEach in some cases (due to function call overhead), but often the difference is minor. Focus on algorithmic improvements first (e.g., avoiding nested loops when not needed).
Avoid heavy operations inside loops: If something can be calculated outside the loop, do it once. For example, caching arr.length in a variable before a for-loop (especially if the length won't change inside) avoids recalculating it each iteration[24]. Or, if you're accessing a property repeatedly in a loop, store it in a variable.
Break out early: If you're searching in a loop and you find what you're looking for, use break to stop further iterations[5]. No need to continue looping once done.
Use fast lookup structures: If you need to check membership of lots of items, consider using a Set (for values) or Map/Object (for key-value) instead of an array search. Checking existence in a Set or Object by key is typically O(1), whereas searching in an array is O(n)[26][27].
Throttle and Debounce
Events like window resizing, scrolling, or keypress can fire many times per second. If your handler is heavy, it could bog down performance. - Debounce: Ensure a function runs only after the event has stopped firing for a certain time. For example, on a search input, wait until the user stops typing for 300ms, then fetch suggestions, instead of on every key stroke[28]. - Throttle: Ensure a function runs at most once every N milliseconds. E.g., on scroll, maybe handle at most every 100ms, ignoring intermediate calls[29]. - You can implement these with timers (setTimeout) or use Lodash's _.throttle/_.debounce utilities if available.
Offload Expensive Work
Web Workers: If you have heavy computations (parsing big data, complex math) that aren't DOM-related, consider using a Web Worker to run it on a background thread[30]. This prevents blocking the main thread (which handles user interactions and rendering). The downside is complexity of messaging between worker and main thread, but for large tasks it can keep the UI fluid[31].
Request Animation Frame: For visual updates (like manual animations), use requestAnimationFrame which syncs with browser's repaint cycle instead of using setInterval or setTimeout blindly. This can improve smoothness.
Async tasks: Use asynchronous APIs (like fetch instead of synchronous XHR) so you don't block the main thread waiting for I/O.
Memory and Garbage
Remove event listeners on removed elements: If you attach events to DOM nodes, and later remove those nodes, the handlers might still reference them preventing GC. Use removeEventListener or ensure no closures accidentally keep references[32].
Be mindful of closures holding large structures. If you have a closure that retains a huge array that you no longer need, you might set it to null or restructure to allow GC.
Garbage collection is automatic but you can help by not creating unnecessary objects in hotspots. For example, if inside a loop you can reuse an object instead of creating a new one each time, it might reduce GC churn (but don't sacrifice code clarity unless profiling shows it's needed).
Miscellaneous
Use ===: Not directly a performance thing, but avoids type coercion overhead and bugs[1].
Minimize reflow and repaint: Batch DOM reads/writes as noted. Also, adding display: none to an element before making a lot of changes to its children and then showing it can reduce intermediate reflows.
Cache computed values: If an expensive computation can be reused, store it (memoization).
Console logging: While debugging, console.log is fine, but in a live loop or real-time scenario, excessive logging can slow things. Remove or limit debug logs in production if possible.
Profiling: Use browser devtools Performance tab to see what's taking time. You might find unexpected bottlenecks (e.g., a particular function or layout reflow). Also monitor memory if needed.
Network optimization: Not code, but remember to optimize how much data you fetch or send, and use caching. Loading 5MB of JSON when you only need 50KB is a performance problem not solved by code tweaks.
Example scenario:
Suppose you have a large list of items to display (say 10,000). Instead of creating 10,000 DOM nodes at once (which is heavy), consider: - Pagination (show 100 at a time). - Or virtual scrolling (only render what's visible). - Use DocumentFragment to insert large chunks as one. - Debounce any filtering on that list as user types.
Another scenario: Animating a box moving across screen: - Instead of setInterval 10ms, use requestAnimationFrame in a loop to update position. It's more efficient and avoids doing extra frames when tab is hidden (rAF pauses when not visible, interval does not). - Or use CSS transitions which are often optimized by browser (offloaded to GPU for example, if just transform or opacity changes, etc.).
Remember: First, make it work and clear; then profile if it's slow, and focus on the actual bottlenecks. Modern JS engines optimize a lot under the hood (like JIT, inlining, etc.). So sometimes micro-optimizations (like for-loop vs forEach) are not as significant as algorithmic changes or reducing DOM interactions.
Exercise: Performance
1. You need to update the text of 1000 list items on a page to "Updated". Which approach might be faster: using a loop to set each element's textContent one by one, or constructing one big string of HTML with all updated items and setting ul.innerHTML once? (The latter avoids 1000 separate DOM operations, so likely faster, though building a huge string also has a cost. In many cases, single innerHTML update is faster for bulk changes.)
2. You have a function that calculates Fibonacci numbers in a very naive recursive way. When asked for fib(45), it hangs the page for seconds. What performance tip would you apply? (Answer: optimize the algorithm using memoization or iteration to avoid exponential time, or offload to a web worker if heavy, since it's CPU bound.)
3. How would you implement a simple debounce for an input event? (Sketch: use a timeout variable outside the function. On event, clearTimeout(if exists) and set a new setTimeout to fire the actual handler after delay. If another event comes in, it resets the timer.)[28]
4. Why is it a bad idea to update the style of each table cell (say 10,000 cells) in a nested loop individually? And how could you optimize it? (Because each style change may trigger reflow, repeated 10k times can be slow. Better: add a CSS class to each or to a parent and use CSS, or build a CSS text and set once, or hide table, update raw HTML, then show.) Also possibly use documentFragment or remove the table from flow during update.
5. (Advanced) Imagine an infinite scroll list where new items are fetched via Ajax as user scrolls down. What performance techniques would you use to ensure smooth scrolling? (Possibly: throttle the scroll event to check scroll position infrequently[29], use requestAnimationFrame for any visual updates, virtualize items (reuse DOM nodes for items that scroll out of view), lazy-load images, etc. Also ensure minimal layout thrashing by not forcing reflows within the scroll handler.)
19. Best Practices
Finally, here are some general best practices and coding guidelines that will help you write clean, maintainable, and robust JavaScript code.
Use Strict Mode
Put "use strict"; at the top of your JS files or functions (or note that modules and ES6 classes are strict by default). Strict mode catches common mistakes by throwing errors. For example, assigning to an undeclared variable in strict mode throws an error, whereas in sloppy mode it would silently create a global variable (bug-prone)[41]. Strict mode also forbids certain bad practices (like with statements, duplicate parameter names, etc.).
Avoid Global Variables
Minimize use of global variables and functions[38]. They can conflict with other scripts and are hard to manage in larger projects. Use function scopes or block scopes to contain variables. If you need a namespace, use an object to hold related functions instead of polluting the global scope with many separate names. With modules, this is even easier: each module has its own scope, and you explicitly export what needs to be global.
Proper Variable Declaration
Always declare variables with let or const (never rely on implicit globals by forgetting let/const/var)[11]. Not declaring a variable (in non-strict) creates a global variable inadvertently. Choose const for values that shouldn't change (it helps prevent accidental reassignment)[12]. Use let when you know you'll reassign. In loops, use let for the index so it's block-scoped.
Consistent Naming and Style
Pick a naming convention and stick to it: - Use camelCase for variables and function names (let userName, function doSomething()) – this is the standard in JS. - Constructor functions or classes start with CapitalPascalCase (function Person(), class UserAccount {}). - Constants that are truly constant (like configuration values that never change) sometimes are written in ALL_CAPS (e.g., const MAX_RETRIES = 5;). Make names descriptive but not overly long. count is better than c, but numberOfItemsInTheShoppingCart might be overkill if used a lot (maybe cartCount). Avoid reserved words or JS keywords as names.
Stick to a consistent code style regarding braces, spacing, etc. Many teams use linters (like ESLint) and formatters (like Prettier) to enforce this.
Comment and Document
Write comments to explain the "why" behind non-obvious code. Especially document functions: what they expect, what they return, and any side effects. For example:
// This function uses the Fisher-Yates algorithm to shuffle an array in place.
function shuffleArray(array) { ... }
Don't over-comment things that are self-evident, but if code could be misunderstood, a comment helps. Consider using JSDoc style comments for functions and modules, which can be processed to generate docs or provide hints in editors.
Keep Functions Focused (Single Responsibility)
Aim for functions to do one thing, or a related set of things at one level of abstraction. This makes them easier to test and reuse. If a function is getting too large or doing disparate tasks, consider refactoring it into smaller functions. E.g., a function that validates user input and also sends an AJAX request might be better split into validateInput and submitData, called in sequence.
DRY - Don't Repeat Yourself
If you notice similar code structures, consider abstracting them. Reuse functions for common logic rather than copy-pasting code. This reduces bugs and makes maintenance easier (change in one place, not many). But also avoid premature abstraction; sometimes slight duplication is better than an abstraction that doesn't fit all cases.
Error Handling
Think about potential errors or edge cases: - Use try/catch around code that can throw (especially JSON parsing, network requests if using async/await, etc.), and handle errors gracefully. - If a function expects a certain type or range, consider handling bad inputs (throwing an error or returning a special value). - In asynchronous code, use .catch on promises or try/catch in async functions to handle rejections. Be careful not to swallow errors silently; at least log them or provide feedback.
Avoid Eval and New Function
eval() executes a string as code. It's dangerous (can run arbitrary code, security risk if input is from user) and slow (has to invoke the JS parser at runtime)[35]. Almost always, there's a better way (like using dynamic data structures or function references). Similarly, new Function(code) creates a function from a string; it's basically eval in another form. Avoid unless absolutely necessary (which in modern JS it rarely is).
Use === and !==
We mentioned this in Operators: for equality checks, use the strict versions to avoid type coercion pitfalls[1]. It makes your intentions clear and avoids weird cases ("" == 0 is true, "5" == 5 true, but you usually don't want that). The only place == might be used legitimately is checking for nullish: e.g., if(x == null) to check for either null or undefined in one go, but even then, explicit x === null || x === undefined is clearer.
Avoid Modifying Built-in Prototypes
It's possible to monkey-patch methods onto Object.prototype or Array.prototype, but doing so can cause conflicts (if another script or future JS adds the same method name) and affects all code. Only modify a built-in prototype if you're polyfilling a standardized feature that isn't in that environment (and even then, use polyfill libraries that do it carefully). Creating your own prototypes (constructors/classes) is fine; just be cautious with core ones.
Optimize Only When Necessary
While performance is important, avoid micro-optimizing things that don't matter or make code hard to read. Typically: - Write clear, correct code. - Profile the code if performance is an issue. - Focus on the hotspots: often a few key functions or loops or interactions with DOM are the bottleneck, not everything. - Use the tips from the performance section for those bottlenecks.
Testing
Write tests for your functions if possible. Even simple console tests help (e.g., trying different inputs). This ensures your code does what you expect and helps catch regressions if you modify things later.
Use Tools
Leverage the ecosystem: - Linters (ESLint) to catch issues (like using a variable that wasn't declared, or an unnecessary == usage, etc.). Linters enforce many best practices automatically or with warnings. - Prettier or other formatters to keep style consistent. - Version control (git) to track changes and collaborate. - DevTools for debugging and performance tuning.
By following these practices, your code will be more predictable, easier for you (and others) to understand, and less prone to bugs.
Exercises: Best Practices
1. The following code has some issues. Identify them and suggest fixes:
x = 5;
function add(a, b) {
  if(a = b) {
    console.log("Equal");
  }
  for(i = 0; i<10; i++) {
    // doing something
  }
}
add(2,3);
(Issues: x is global (missing let/const), the if uses assignment instead of comparison, i is global in loop (no let), function doesn't use strict, etc.)
2. Show an example of using strict mode to catch an error: for instance, assign to an undeclared variable in strict mode and see it throw a ReferenceError. Without strict mode, it would silently create a global variable.
3. How would you refactor code that has the same chunk of logic copy-pasted in five places? (Answer: create a function that encapsulates that logic, and call it from those places. Or use a loop if it's doing something similar five times).
4. Write a short JSDoc comment for a function function multiply(a, b) that describes what it does, its parameters, and return value. For example:
/**
 * Multiplies two numbers.
 * @param {number} a - The first number.
 * @param {number} b - The second number.
 * @returns {number} The product of a and b.
 */
This is a way to practice documenting functions.
5. (Open-ended) Think of a scenario where using a global variable could cause a bug. For example, if two scripts both use a global variable named tempData for different purposes, they might overwrite each other. How can modules or IIFEs help prevent that? (They create a private scope, so the variables don't clash in the global namespace.)
20. Conclusion
Congratulations on completing this journey through JavaScript for frontend web development! 🎉 You've covered a tremendous amount of material, from the basics of syntax and data types all the way to advanced concepts and best practices.
Let's recap what you've learned:
Foundations: Setting up JavaScript in a web page, using the console, and basic syntax. You learned about variables (using modern let and const), the various data types, and how dynamic typing works.
Operators and Control Flow: You can perform arithmetic and manipulate values, compare them, and use logical operators. You know how to use if/else to make decisions, and loops (for, while, etc.) to repeat actions. You also saw how to break out of loops or skip iterations.
Functions: You can define reusable blocks of code with functions, use parameters and return values, and understand different ways to define functions (declarations, expressions, arrow functions). Functions allow you to organize code and avoid repetition.
Data Structures (Arrays and Objects): You can group values in arrays and access them by index, and you've used many helpful array methods (push, pop, slice, etc.). You can create objects to model more complex entities with properties and methods. You've accessed and modified object properties, and even looped over them.
DOM Manipulation: Perhaps one of the most exciting parts — you can now use JavaScript to select elements on a webpage and change them. You've practiced changing text, styles, attributes, creating new elements, and removing elements. This is the basis of making interactive pages.
Event Handling: You learned how to respond to user actions like clicks, key presses, form submissions, etc. By adding event listeners, your code can run at the right moments. You've handled events, accessed the event object, and controlled event propagation and default behavior.
Forms: You know how to collect user input from form elements, validate it, and even prevent forms from doing full page reloads to handle submission via JavaScript. This is crucial for modern web apps which often use client-side validation and AJAX.
Asynchronous JavaScript: A big concept — you learned that not all code runs sequentially. With callbacks, promises, and async/await, you can handle tasks that take time (like server requests or setTimeout) without freezing the page. You understand the event loop conceptually, and how to structure code to deal with asynchronous results.
Modern JS (ES6+): You've started using the newer features that make coding easier: block-scoped variables, template literals for string interpolation, destructuring for easy extraction of values, spread/rest for convenient array/object operations, classes for clearer object-oriented code, and modules for organizing code across files.
Closures and Advanced Concepts: You delved into closures, understanding how functions can retain access to outer scope variables, enabling patterns like function factories and private data. You also tackled this, learning how its value is determined and how to manage it (especially with arrow functions vs normal functions). Prototypes and inheritance were covered, demystifying how objects inherit features and how to set up your own inheritance hierarchies (or use classes to do it).
Performance Considerations: You got tips on writing efficient code: minimizing heavy DOM operations, throttling events, using efficient loops and data structures, and not blocking the main thread. You also learned that modern JS engines are fast, and that you should optimize when needed, but not prematurely.
Best Practices: Finally, you learned general habits for quality code — using strict mode, avoiding globals, writing clean and consistent code, commenting wisely, avoiding risky practices like eval, and leveraging tools (like linters) to maintain code health. These practices will help you as your projects grow in size and complexity.
Now, with this knowledge, you're well-equipped to start building things! Here are some suggestions for next steps:
Build something small: Maybe a to-do list app, a simple quiz, or a personal homepage with interactive elements. Apply what you've learned — you'll find you reinforce concepts best by using them.
Debugging skills: Practice using the browser's developer tools to set breakpoints, inspect variables, and step through code. Debugging is an essential skill; don't be discouraged by bugs — every bug is a learning opportunity.
Read documentation and other resources: The MDN Web Docs (Mozilla Developer Network) is an excellent reference for JavaScript and web APIs. If something isn't clear or you want to learn more about, say, the Fetch API for network requests, MDN likely has a page on it. Also, many tutorials and community answers exist (e.g., on Stack Overflow) for specific problems.
Try challenges: Sites like CodeWars, HackerRank, or LeetCode have JavaScript challenges that can help sharpen your logic and familiarity with the language.
Frameworks and Libraries: Once you're comfortable with vanilla JS, you might explore libraries like jQuery (though less essential now with modern JS and browsers), or front-end frameworks like React, Vue, or Angular. These can help build more complex applications. But having a solid vanilla JS foundation (which you now do!) makes learning them much easier.
Node.js: If you're interested in back-end development or using JS outside the browser, look into Node.js. It's JavaScript running on the server, and you'll find many familiar concepts (though different APIs, like file system or database access). It's a different environment (no DOM, for example), but it's powerful to use one language for both front-end and back-end.
Continuous Learning: The JavaScript ecosystem evolves. New proposals and features come (you've seen ones up to ES2020 like optional chaining). Keep an eye on what's new, but also remember that fundamentals change slowly. Your knowledge now is a strong base — new features usually make things more convenient (like how arrow functions or async/await did) rather than completely changing how you must do things.
Most importantly, keep coding. Build projects that interest you, no matter how simple or silly — each project will teach you something. Over time, concepts that seem tricky now (like closures or this) will become second nature.
Whenever you're stuck or curious, don't hesitate to search online; the developer community is huge, and likely someone else has asked the same question before. Embrace errors and bugs — debugging them will make you a better programmer.
Happy coding, and best of luck on your journey to mastering JavaScript and building awesome web experiences! You've got this! 🚀

[1] [2] [3] [4] [11] [12] [35] [38] [41] JavaScript Best Practices
https://www.w3schools.com/js/js_best_practices.asp
[5] [8] [9] [10] [19] [20] [23] [30] [32] [33] [37] [40] JavaScript performance optimization - Learn web development | MDN
https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/JavaScript
[6] [14] [16] [17] [39] this - JavaScript | MDN
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this
[7] [13] [18] Object prototypes - Learn web development | MDN
https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Advanced_JavaScript_objects/Object_prototypes
[15] Closures - JavaScript | MDN
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures
[21] [22] [24] [25] [26] [27] [28] [29] [31] [34] [36] JavaScript Performance Optimization Strategies: A Comprehensive Guide | by Lavesh Gaurav | Mar, 2025 | Medium
https://medium.com/@laveshgaurav/javascript-performance-optimization-strategies-a-comprehensive-guide-481d85caf93f
